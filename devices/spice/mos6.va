// Model generated by Verilog-A Distiller.
// (c)2025 Arpad Buermen. All rights reserved.
// SPDX-License-Identifier: AGPL-3.0-or-later
// 
// SPICE flavour: ngspice
// Version      : ngspice-44-61-g8da323b50
// Origin       : https://sourceforge.net/u/arpadbuermen/ngspice/ci/vadng-pre-45/tree/
// Date         : 2025-04-24 07:24:24 UTC
// Module name  : sp_mos6
// 
// Notes:
//   Parameter m was replaced with builtin Verilog-A parameter $mfactor.
//
//   All parameters and opvars refer to a single parallel instance,
//   even if $mfactor>1.
//
//   Parameter off was removed. Bypassing is not available in Verilog-A. 
//   
//   Device type is set by the type parameter to NMOS (1) or PMOS (-1). 
//   
//   Opvars rs and rd were removed due to a conflict with model parameters. 
//   Their inverses are available as sourceconductance and drainconductance 
//   opvars. 
//   
//   Opvars cbd and cbs were renamed to c_bd and c_bs due to a conflict 
//   with model parameters. 
//   
//   Meyer charge is not computed and therefore not available. Opvars qgs, 
//   qgd, and qgb were removed. 
//   
//   Parameters ic, icvds, icvgs, and icvbs were removed. Initial conditions 
//   should be set via the simulator's initial conditions mechanism. 
//   
//   Noise is not modelled in this device.
// CKTcircuit member mapping
//   CKTdefaultMosAD -> ('defad', '$simparam("defad", 0)', 'const')
//   CKTdefaultMosAS -> ('defas', '$simparam("defas", 0)', 'const')
//    CKTdefaultMosL -> ('defl', '$simparam("defl", 1e-4)', 'const')
//    CKTdefaultMosW -> ('defw', '$simparam("defw", 1e-4)', 'const')
//       CKTfixLimit -> ('oldlimit', '$simparam("oldlimit", 0)', 'const')
//           CKTgmin -> ('gmin', '$simparam("gmin", 1e-12)')
//        CKTnomTemp -> ('tnom', '($simparam("tnom", 27)+273.15)')
//           CKTtemp -> (None, '$temperature')
//
// Source files and copyright information:
//   devsup.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//   mos6/mos6defs.h
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//   mos6/mos6.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//   mos6/mos6par.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//   mos6/mos6mpar.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//   mos6/mos6ask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//     Modified: 2000 AlansFixes
//   mos6/mos6mask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//   mos6/mos6set.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//     Modified: 2000 AlansFixes
//   mos6/mos6temp.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//   mos6/mos6load.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//     Modified: 2000 AlansFixes

`include "constants.vams"
`include "disciplines.vams"

module sp_mos6(d, g, s, b);
  inout d, g, s, b;
  electrical d, g, s, b, d_int, s_int;

  // Instance parameters
  (* desc = "Length", type = "instance" *) parameter real l = 0;
  (* desc = "Width", type = "instance" *) parameter real w = 0;
  (* desc = "Drain area", type = "instance" *) parameter real ad = 0;
  (* desc = "Source area", type = "instance" *) parameter real as = 0;
  (* desc = "Drain perimeter", type = "instance" *) parameter real pd = 0;
  (* desc = "Source perimeter", type = "instance" *) parameter real ps = 0;
  (* desc = "Drain squares", type = "instance" *) parameter real nrd = 0;
  (* desc = "Source squares", type = "instance" *) parameter real nrs = 0;
  (* desc = "Instance temperature", type = "instance" *) parameter real temp = 0;
  (* desc = "Instance temperature difference", type = "instance" *) parameter real dtemp = 0.0;

  // Model parameters
  (* desc = "NMOS (1) or PMOS (-1)" *) parameter integer type = 1;
  (* desc = "Threshold voltage" *) parameter real vto = 0;
  aliasparam vt0 = vto;
  (* desc = "Saturation voltage factor" *) parameter real kv = 2;
  (* desc = "Saturation voltage coeff." *) parameter real nv = 0.5;
  (* desc = "Saturation current factor" *) parameter real kc = 5e-05;
  (* desc = "Saturation current coeff." *) parameter real nc = 1;
  (* desc = "Threshold voltage coeff." *) parameter real nvth = 0.5;
  (* desc = "Sat. current modification  par." *) parameter real ps_mod = 0;
  (* desc = "Bulk threshold parameter" *) parameter real gamma = 0;
  (* desc = "Bulk threshold parameter 1" *) parameter real gamma1 = 0;
  (* desc = "Static feedback effect par." *) parameter real sigma = 0;
  (* desc = "Surface potential" *) parameter real phi = 0.6;
  (* desc = "Channel length modulation param." *) parameter real lambda = 0;
  (* desc = "Channel length modulation param. 0" *) parameter real lambda0 = 0;
  (* desc = "Channel length modulation param. 1" *) parameter real lambda1 = 0;
  (* desc = "Drain ohmic resistance" *) parameter real rd = 0;
  (* desc = "Source ohmic resistance" *) parameter real rs = 0;
  (* desc = "B-D junction capacitance" *) parameter real cbd = 0;
  (* desc = "B-S junction capacitance" *) parameter real cbs = 0;
  (* desc = "Bulk junction sat. current" *) parameter real is = 1e-14;
  (* desc = "Bulk junction potential" *) parameter real pb = 0.8;
  (* desc = "Gate-source overlap cap." *) parameter real cgso = 0;
  (* desc = "Gate-drain overlap cap." *) parameter real cgdo = 0;
  (* desc = "Gate-bulk overlap cap." *) parameter real cgbo = 0;
  (* desc = "Sheet resistance" *) parameter real rsh = 0;
  (* desc = "Bottom junction cap per area" *) parameter real cj = 0;
  (* desc = "Bottom grading coefficient" *) parameter real mj = 0.5;
  (* desc = "Side junction cap per area" *) parameter real cjsw = 0;
  (* desc = "Side grading coefficient" *) parameter real mjsw = 0.5;
  (* desc = "Bulk jct. sat. current density" *) parameter real js = 0;
  (* desc = "Lateral diffusion" *) parameter real ld = 0;
  (* desc = "Oxide thickness" *) parameter real tox = 0;
  (* desc = "Surface mobility" *) parameter real u0 = 600;
  aliasparam uo = u0;
  (* desc = "Forward bias jct. fit parm." *) parameter real fc = 0.5;
  (* desc = "Gate type" *) parameter integer tpg = 1;
  (* desc = "Substrate doping" *) parameter real nsub = 0;
  (* desc = "Surface state density" *) parameter real nss = 0;
  (* desc = "Parameter measurement temperature" *) parameter real tnom = 0;

  // Instance opvars
  (* desc = "B-S junction capacitance" *) real ibs;
  (* desc = "B-D junction capacitance" *) real ibd;
  (* desc = "Gate-Source voltage" *) real vgs;
  (* desc = "Drain-Source voltage" *) real vds;
  (* desc = "Bulk-Source voltage" *) real vbs;
  (* desc = "Bulk-Drain voltage" *) real vbd;
  (* desc = "Source conductance" *) real sourceconductance;
  (* desc = "Drain conductance" *) real drainconductance;
  (* desc = "Turn-on voltage" *) real von;
  (* desc = "Saturation drain voltage" *) real vdsat;
  (* desc = "Critical source voltage" *) real sourcevcrit;
  (* desc = "Critical drain voltage" *) real drainvcrit;
  (* desc = "Bulk-Source transconductance" *) real gmbs;
  (* desc = "Transconductance" *) real gm;
  (* desc = "Drain-Source conductance" *) real gds;
  (* desc = "Bulk-Drain conductance" *) real gbd;
  (* desc = "Bulk-Source conductance" *) real gbs;
  (* desc = "Gate-Source capacitance" *) real cgs;
  (* desc = "Gate-Drain capacitance" *) real cgd;
  (* desc = "Gate-Bulk capacitance" *) real cgb;
  (* desc = "Bulk-Drain capacitance" *) real c_bd;
  (* desc = "Bulk-Source capacitance" *) real c_bs;
  (* desc = "Zero-Bias B-D junction capacitance" *) real cbd0;
  (* desc = " " *) real cbdsw0;
  (* desc = "Zero-Bias B-S junction capacitance" *) real cbs0;
  (* desc = " " *) real cbssw0;
  (* desc = "Capacitance due to gate-source charge storage" *) real cqgs;
  (* desc = "Capacitance due to gate-drain charge storage" *) real cqgd;
  (* desc = "Capacitance due to gate-bulk charge storage" *) real cqgb;
  (* desc = "Capacitance due to bulk-drain charge storage" *) real cqbd;
  (* desc = "Capacitance due to bulk-source charge storage" *) real cqbs;
  (* desc = "Bulk-Drain charge storage" *) real qbd;
  (* desc = "Bulk-Source charge storage" *) real qbs;

  // Model opvars

  // Instance fields
  real MOS6l;
  real MOS6w;
  real MOS6drainArea;
  real MOS6sourceArea;
  real MOS6drainSquares;
  real MOS6sourceSquares;
  real MOS6sourceConductance;
  real MOS6drainConductance;
  real MOS6temp;
  real MOS6tKv;
  real MOS6tKc;
  real MOS6tSurfMob;
  real MOS6tPhi;
  real MOS6tVto;
  real MOS6tSatCur;
  real MOS6tSatCurDens;
  real MOS6tCbd;
  real MOS6tCbs;
  real MOS6tCj;
  real MOS6tCjsw;
  real MOS6tBulkPot;
  real MOS6tDepCap;
  real MOS6tVbi;
  real MOS6von;
  real MOS6vdsat;
  real MOS6sourceVcrit;
  real MOS6drainVcrit;
  real MOS6cd;
  real MOS6cbs;
  real MOS6cbd;
  real MOS6gmbs;
  real MOS6gm;
  real MOS6gds;
  real MOS6gbd;
  real MOS6gbs;
  real MOS6capbd;
  real MOS6capbs;
  real MOS6Cbd;
  real MOS6Cbdsw;
  real MOS6Cbs;
  real MOS6Cbssw;
  real MOS6f2d;
  real MOS6f3d;
  real MOS6f4d;
  real MOS6f2s;
  real MOS6f3s;
  real MOS6f4s;
  integer MOS6mode;
  real MOS6cgs;
  real MOS6cgd;
  real MOS6cgb;
  real meyer_scale;
  real meyer_unscale;
  integer MOS6tempGiven = 0;

  // Model fields
  real MOS6tnom;
  real MOS6kc;
  real MOS6oxideCapFactor;
  real MOS6vt0;
  real MOS6phi;
  real MOS6gamma;
  real MOS6gamma1;
  real MOS6lamda0;
  real MOS6substrateDoping;
  integer MOS6type;
  integer MOS6tnomGiven = 0;

  // States
  real MOS6vbd;
  real MOS6vbs;
  real MOS6vgs;
  real MOS6vds;
  real MOS6capgs;
  real MOS6qgs;
  real MOS6cqgs;
  real MOS6capgd;
  real MOS6qgd;
  real MOS6cqgd;
  real MOS6capgb;
  real MOS6qgb;
  real MOS6cqgb;
  real MOS6qbd;
  real MOS6cqbd;
  real MOS6qbs;
  real MOS6cqbs;

  // Device setup locals

  // Device temperature dependence locals
  real egfet;
  real egfet1;
  real fact1;
  real fact2;
  real kt;
  real kt1;
  real arg1;
  real ratio;
  real ratio4;
  real phio;
  real pbo;
  real gmanew;
  real gmaold;
  real capfact;
  real pbfact1;
  real pbfact;
  real vt;
  real vtnom;
  real wkfngs;
  real wkfng;
  real fermig;
  real fermis;
  real vfb;
  real czbd;
  real czbdsw;
  real czbs;
  real czbssw;
  real arg;
  real sarg;
  real sargsw;

  // Device load locals
  integer limited;
  real betac;
  real DrainSatCur;
  real EffectiveLength;
  real GateBulkOverlapCap;
  real GateDrainOverlapCap;
  real GateSourceOverlapCap;
  real OxideCap;
  real SourceSatCur;
  real load_arg;
  real cdrain;
  real cdreq;
  real ceq;
  real ceqbd;
  real ceqbs;
  real ceqgb;
  real ceqgd;
  real ceqgs;
  real evbd;
  real evbs;
  real gcgb;
  real gcgd;
  real gcgs;
  real geq;
  real load_sarg;
  real load_sargsw;
  real load_vbd;
  real load_vbs;
  real load_vds;
  real load_vdsat;
  real vgb;
  real vgd;
  real vgdo;
  real load_vgs;
  real load_von;
  real load_vt;
  real xfact;
  integer xnrm;
  integer xrev;
  real capgs;
  real capgd;
  real capgb;
  real m;
  real load_arg1;
  real sarg1;
  real vgon;
  real vdshere;
  real vbsvbd;
  real idsat;
  real load_lambda;
  real vonbm;
  real vdst;
  real vdst2;
  real ivdst1;
  real vdstg;

  // Device noise locals

  // Global constants
  real CONSTroot2 = sqrt(2.0);
  real CONSTvt0 = 1.38064852e-23*(27+273.15)/1.6021766208e-19;
  real CONSTKoverQ = 1.38064852e-23/1.6021766208e-19;
  real CONSTe = exp(1.0);
  real VACONSTcharge = 1.6021766208e-19;
  real VACONSTboltz = 1.38064852e-23;
  real defad = $simparam("defad", 0);
  real defas = $simparam("defas", 0);
  real defl = $simparam("defl", 1e-4);
  real defw = $simparam("defw", 1e-4);
  real oldlimit = $simparam("oldlimit", 0);
  real VACONST_tnom = ($simparam("tnom", 27)+273.15);

  // Evaluation constants
  real lc_gmin = 0;

  // Translated function definitions
  analog function DEVqmeyer;
    input vgs, vgd, vgb, von, _vdsat;
    inout capgs, capgd, capgb;
    input phi, cox;
    real vgs;
    real vgd;
    real vgb;
    real von;
    real _vdsat;
    real capgs;
    real capgd;
    real capgb;
    real phi;
    real cox;
    real vdsat;
    real vds;
    real vddif;
    real vddif1;
    real vddif2;
    real vgst;
    begin
      vdsat = _vdsat;
      vgst = vgs-von;
      vdsat = ((vdsat>0.025) ? (vdsat) : (0.025));
      if (vgst<=-phi) begin
        capgb = cox/2;
        capgs = 0;
        capgd = 0;
      end else if (vgst<=-phi/2) begin
        capgb = -vgst*cox/(2*phi);
        capgs = 0;
        capgd = 0;
      end else if (vgst<=0) begin
        capgb = -vgst*cox/(2*phi);
        capgs = vgst*cox/(1.5*phi)+cox/3;
        vds = vgs-vgd;
        if (vds>=vdsat) begin
          capgd = 0;
        end else begin
          vddif = 2.0*vdsat-vds;
          vddif1 = vdsat-vds;
          vddif2 = vddif*vddif;
          capgd = capgs*(1.0-vdsat*vdsat/vddif2);
          capgs = capgs*(1.0-vddif1*vddif1/vddif2);
        end
      end else begin
        vds = vgs-vgd;
        vdsat = ((vdsat>0.025) ? (vdsat) : (0.025));
        if (vdsat<=vds) begin
          capgs = cox/3;
          capgd = 0;
          capgb = 0;
        end else begin
          vddif = 2.0*vdsat-vds;
          vddif1 = vdsat-vds;
          vddif2 = vddif*vddif;
          capgd = cox*(1.0-vdsat*vdsat/vddif2)/3;
          capgs = cox*(1.0-vddif1*vddif1/vddif2)/3;
          capgb = 0;
        end
      end
    end
  endfunction

  // Verbatim analog functions
  analog function integer initialize_limiting;
    integer il;
    begin
      il = $simparam("iniLim", -1);
      if (il<0) begin
        // iniLim not available, use heuristics
        initialize_limiting = 
          $simparam("iteration", 10)==1 && 
          (analysis("dc") || analysis("static")) && 
          analysis("nodeset");
      end else begin
        initialize_limiting = il;
      end
    end
  endfunction

  analog function DEVlimitOldGet;
    input vnew, vold;
    real vnew, vold, result;
    begin
      DEVlimitOldGet = vold;
    end
  endfunction

  analog function DEVlimitNewSet;
    input vnew, vold, new_value, limited;
    real vnew, vold, new_value;
    integer limited;
    begin
      DEVlimitNewSet = new_value;
      if (limited) begin
        $discontinuity(-1);
      end
    end
  endfunction

  analog function real DEVpnjlim;
    input vnew, vold, vt, vcrit;
    inout limiting_applied;
    real vnew, vold, vt, vcrit, limited, arg;
    integer limiting_applied;
    
    begin
      limited = vnew;
      if ((vnew > vcrit) && (abs(vnew - vold) > (vt + vt))) begin
        // Positive vnew above vcrit, change greater than 2*vt
        if(vold > 0) begin
          arg = (vnew - vold) / vt;
          if(arg > 0) begin
            limited = vold + vt * ln(1+arg);
            limiting_applied = 1;
          end else begin
            limited = vold - vt * ln(1-arg);
            limiting_applied = 1;
          end
        end else begin
          limited = vt *ln(vnew/vt);
          limiting_applied = 1;
        end
      end else if (vnew<0) begin
        // Negative vnew, use ngspice limiting
        if (vold > 0) begin
          arg = -1*vold-1; 
        end else begin
          arg = 2*vold-1;
        end
        if (vnew<arg) begin
          limited = arg;
          limiting_applied = 1;
        end
      end 
      DEVpnjlim = limited;
    end
  endfunction

  analog function real DEVfetlim;
    input vnew, vold, vto;
    inout limiting_applied;
    real vnew, vold, vto, vlimited;
    real vtsthi, vtstlo, vtox, delv, vtemp;
    integer limiting_applied;  
    begin
      vlimited = vnew;
      vtsthi = abs(2*(vold-vto))+2;
      // vtstlo = vtsthi/2 +2;
      vtstlo = abs(vold-vto)+1;
      vtox = vto + 3.5;
      delv = vnew-vold;
      
      if (vold >= vto) begin
        if(vold >= vtox) begin
          if(delv <= 0) begin
            /* going off */
            if(vlimited >= vtox) begin
                if(-delv > vtstlo) begin
                vlimited =  vold - vtstlo;
                end
            end else begin
              vlimited = max(vnew,vto+2);
            end
          end else begin
            /* staying on */
            if(delv >= vtsthi) begin
              vlimited = vold + vtsthi;
            end
          end
        end else begin
          /* middle region */
          if(delv <= 0) begin
            /* decreasing */
            vlimited = max(vnew,vto-0.5);
          end else begin
            /* increasing */
            vlimited = min(vnew,vto+4);
          end
        end
      end else begin
        /* off */
        if(delv <= 0) begin
          if(-delv >vtsthi) begin
            vlimited = vold - vtsthi;
          end
        end else begin
          vtemp = vto + 0.5;
          if(vnew <= vtemp) begin
            if(delv > vtstlo) begin
              vlimited = vold + vtstlo;
            end
          end else begin
            vlimited = vtemp;
          end
        end
      end
      if (vlimited!=vnew) begin
        limiting_applied = 1;
      end
      DEVfetlim = vlimited;
    end
  endfunction

  analog function real DEVlimvds;
    input vnew, vold;
    inout limiting_applied;
    real vnew, vold, vlimited;
    integer limiting_applied;
    begin
      if (vold >= 3.5) begin
        if(vnew > vold) begin
          vlimited = min(vnew, (3 * vold) + 2);
        end else begin
          if (vnew < 3.5) begin
            vlimited = max(vnew, 2);
          end else begin
            vlimited = vnew;
          end
        end
      end else begin
        if(vnew > vold) begin
          vlimited = min(vnew, 4);
        end else begin
          vlimited = max(vnew, -0.5);
        end
      end
      DEVlimvds = vlimited;
      if (vlimited!=vnew) begin
        limiting_applied = 1;
      end
    end
  endfunction

  // Analog block
  analog begin

    // Instance field assignments
    if ($param_given(l)) begin
      MOS6l = l;
    end
    if ($param_given(w)) begin
      MOS6w = w;
    end
    if ($param_given(ad)) begin
      MOS6drainArea = ad;
    end
    if ($param_given(as)) begin
      MOS6sourceArea = as;
    end
    if ($param_given(nrd)) begin
      MOS6drainSquares = nrd;
    end
    if ($param_given(nrs)) begin
      MOS6sourceSquares = nrs;
    end
    if ($param_given(temp)) begin
      MOS6temp = temp+273.15;
      MOS6tempGiven = 1;
    end

    // Model field assignments
    MOS6type = type;
    if ($param_given(vto)) begin
      MOS6vt0 = vto;
    end
    if ($param_given(kc)) begin
      MOS6kc = kc;
    end
    if ($param_given(gamma)) begin
      MOS6gamma = gamma;
    end
    if ($param_given(gamma1)) begin
      MOS6gamma1 = gamma1;
    end
    if ($param_given(phi)) begin
      MOS6phi = phi;
    end
    if ($param_given(lambda0)) begin
      MOS6lamda0 = lambda0;
    end
    if ($param_given(nsub)) begin
      MOS6substrateDoping = nsub;
    end
    if ($param_given(tnom)) begin
      MOS6tnom = tnom+273.15;
      MOS6tnomGiven = 1;
    end

    // Evaluation constants
    lc_gmin = $simparam("gmin", 1e-12);

    // Tag: setup, function: MOS6setup
    if (!$param_given(kc)) begin
      MOS6kc = 5e-5;
    end
    if (!$param_given(vto)) begin
      MOS6vt0 = 0;
    end
    if (!$param_given(phi)) begin
      MOS6phi = 0.6;
    end
    if (!$param_given(lambda0)) begin
      MOS6lamda0 = 0;
      if ($param_given(lambda)) begin
        MOS6lamda0 = lambda;
      end
    end
    if (!$param_given(gamma)) begin
      MOS6gamma = 0;
    end
    if (!$param_given(gamma1)) begin
      MOS6gamma1 = 0;
    end
    MOS6vdsat = 0;
    MOS6von = 0;
    if (!(rd!=0||rsh!=0&&MOS6drainSquares!=0)) begin
      V(d_int, d) <+ 0;
    end
    if (!(rs!=0||rsh!=0&&MOS6sourceSquares!=0)) begin
      V(s_int, s) <+ 0;
    end

    // Tag: temp, function: MOS6temp
    if (!MOS6tnomGiven) begin
      MOS6tnom = VACONST_tnom;
    end
    fact1 = MOS6tnom/(27.0+273.15);
    vtnom = MOS6tnom*CONSTKoverQ;
    kt1 = 1.38064852e-23*MOS6tnom;
    egfet1 = 1.16-7.02e-4*MOS6tnom*MOS6tnom/(MOS6tnom+1108);
    arg1 = -egfet1/(kt1+kt1)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact1 = -2*vtnom*(1.5*ln(fact1)+1.6021766208e-19*arg1);
    if (MOS6phi<=0.0) begin
      $fatal(0, "Phi is not positive.");
    end
    if (!$param_given(tox)||tox==0) begin
      MOS6oxideCapFactor = 0;
    end else begin
      MOS6oxideCapFactor = 3.9*8.854214871e-12/tox;
      if (!$param_given(kc)) begin
        MOS6kc = 0.5*u0*MOS6oxideCapFactor*1e-4;
      end
      if ($param_given(nsub)) begin
        if (MOS6substrateDoping*1e6>1.45e16) begin
          if (!$param_given(phi)) begin
            MOS6phi = 2*vtnom*ln(MOS6substrateDoping*1e6/1.45e16);
            MOS6phi = ((0.1>MOS6phi) ? (0.1) : (MOS6phi));
          end
          fermis = MOS6type*0.5*MOS6phi;
          wkfng = 3.2;
          if (tpg!=0) begin
            fermig = MOS6type*tpg*0.5*egfet1;
            wkfng = 3.25+0.5*egfet1-fermig;
          end
          wkfngs = wkfng-(3.25+0.5*egfet1+fermis);
          if (!$param_given(gamma)) begin
            MOS6gamma = sqrt(2*11.70*8.854214871e-12*1.6021766208e-19*MOS6substrateDoping*1e6)/MOS6oxideCapFactor;
          end
          if (!$param_given(gamma1)) begin
            MOS6gamma1 = 0.0;
          end
          if (!$param_given(vto)) begin
            vfb = wkfngs-nss*1e4*1.6021766208e-19/MOS6oxideCapFactor;
            MOS6vt0 = vfb+MOS6type*(MOS6gamma*sqrt(MOS6phi)+MOS6phi);
          end
        end else begin
          MOS6substrateDoping = 0;
          $fatal(0, "Nsub < Ni");
        end
      end
    end
    if (!MOS6tempGiven) begin
      MOS6temp = $temperature+dtemp;
    end
    vt = MOS6temp*CONSTKoverQ;
    ratio = MOS6temp/MOS6tnom;
    fact2 = MOS6temp/(27.0+273.15);
    kt = MOS6temp*1.38064852e-23;
    egfet = 1.16-7.02e-4*MOS6temp*MOS6temp/(MOS6temp+1108);
    arg = -egfet/(kt+kt)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact = -2*vt*(1.5*ln(fact2)+1.6021766208e-19*arg);
    if (!$param_given(ad)) begin
      MOS6drainArea = defad;
    end
    if (!$param_given(l)) begin
      MOS6l = defl;
    end
    if (!$param_given(as)) begin
      MOS6sourceArea = defas;
    end
    if (!$param_given(w)) begin
      MOS6w = defw;
    end
    if (MOS6l-2*ld<=0) begin
      $warning("effective channel length less than zero");
    end
    ratio4 = ratio*sqrt(ratio);
    MOS6tKv = kv;
    MOS6tKc = MOS6kc/ratio4;
    MOS6tSurfMob = u0/ratio4;
    phio = (MOS6phi-pbfact1)/fact1;
    MOS6tPhi = fact2*phio+pbfact;
    MOS6tVbi = MOS6vt0-MOS6type*(MOS6gamma*sqrt(MOS6phi))+0.5*(egfet1-egfet)+MOS6type*0.5*(MOS6tPhi-MOS6phi);
    MOS6tVto = MOS6tVbi+MOS6type*MOS6gamma*sqrt(MOS6tPhi);
    MOS6tSatCur = is*exp(-egfet/vt+egfet1/vtnom);
    MOS6tSatCurDens = js*exp(-egfet/vt+egfet1/vtnom);
    pbo = (pb-pbfact1)/fact1;
    gmaold = (pb-pbo)/pbo;
    capfact = 1/(1+mj*(4e-4*(MOS6tnom-(27.0+273.15))-gmaold));
    MOS6tCbd = cbd*capfact;
    MOS6tCbs = cbs*capfact;
    MOS6tCj = cj*capfact;
    capfact = 1/(1+mjsw*(4e-4*(MOS6tnom-(27.0+273.15))-gmaold));
    MOS6tCjsw = cjsw*capfact;
    MOS6tBulkPot = fact2*pbo+pbfact;
    gmanew = (MOS6tBulkPot-pbo)/pbo;
    capfact = 1+mj*(4e-4*(MOS6temp-(27.0+273.15))-gmanew);
    MOS6tCbd = MOS6tCbd * (capfact);
    MOS6tCbs = MOS6tCbs * (capfact);
    MOS6tCj = MOS6tCj * (capfact);
    capfact = 1+mjsw*(4e-4*(MOS6temp-(27.0+273.15))-gmanew);
    MOS6tCjsw = MOS6tCjsw * (capfact);
    MOS6tDepCap = fc*MOS6tBulkPot;
    if (MOS6tSatCurDens==0||MOS6drainArea==0||MOS6sourceArea==0) begin
      MOS6drainVcrit = vt*ln(vt/(CONSTroot2*MOS6tSatCur));
      MOS6sourceVcrit = MOS6drainVcrit;
    end else begin
      MOS6drainVcrit = vt*ln(vt/(CONSTroot2*MOS6tSatCurDens*MOS6drainArea));
      MOS6sourceVcrit = vt*ln(vt/(CONSTroot2*MOS6tSatCurDens*MOS6sourceArea));
    end
    if ($param_given(cbd)) begin
      czbd = MOS6tCbd;
    end else begin
      if ($param_given(cj)) begin
        czbd = MOS6tCj*MOS6drainArea;
      end else begin
        czbd = 0;
      end
    end
    if ($param_given(cjsw)) begin
      czbdsw = MOS6tCjsw*pd;
    end else begin
      czbdsw = 0;
    end
    arg = 1-fc;
    sarg = exp(-mj*ln(arg));
    sargsw = exp(-mjsw*ln(arg));
    MOS6Cbd = czbd;
    MOS6Cbdsw = czbdsw;
    MOS6f2d = czbd*(1-fc*(1+mj))*sarg/arg+czbdsw*(1-fc*(1+mjsw))*sargsw/arg;
    MOS6f3d = czbd*mj*sarg/arg/MOS6tBulkPot+czbdsw*mjsw*sargsw/arg/MOS6tBulkPot;
    MOS6f4d = czbd*MOS6tBulkPot*(1-arg*sarg)/(1-mj)+czbdsw*MOS6tBulkPot*(1-arg*sargsw)/(1-mjsw)-MOS6f3d/2*(MOS6tDepCap*MOS6tDepCap)-MOS6tDepCap*MOS6f2d;
    if ($param_given(cbs)) begin
      czbs = MOS6tCbs;
    end else begin
      if ($param_given(cj)) begin
        czbs = MOS6tCj*MOS6sourceArea;
      end else begin
        czbs = 0;
      end
    end
    if ($param_given(cjsw)) begin
      czbssw = MOS6tCjsw*ps;
    end else begin
      czbssw = 0;
    end
    arg = 1-fc;
    sarg = exp(-mj*ln(arg));
    sargsw = exp(-mjsw*ln(arg));
    MOS6Cbs = czbs;
    MOS6Cbssw = czbssw;
    MOS6f2s = czbs*(1-fc*(1+mj))*sarg/arg+czbssw*(1-fc*(1+mjsw))*sargsw/arg;
    MOS6f3s = czbs*mj*sarg/arg/MOS6tBulkPot+czbssw*mjsw*sargsw/arg/MOS6tBulkPot;
    MOS6f4s = czbs*MOS6tBulkPot*(1-arg*sarg)/(1-mj)+czbssw*MOS6tBulkPot*(1-arg*sargsw)/(1-mjsw)-MOS6f3s/2*(MOS6tDepCap*MOS6tDepCap)-MOS6tDepCap*MOS6f2s;
    if ($param_given(rd)) begin
      if (rd!=0) begin
        MOS6drainConductance = 1/rd;
      end else begin
        MOS6drainConductance = 0;
      end
    end else if ($param_given(rsh)) begin
      if (!$param_given(nrd)||MOS6drainSquares==0) begin
        MOS6drainSquares = 1;
      end
      if (rsh!=0) begin
        MOS6drainConductance = 1/(rsh*MOS6drainSquares);
      end else begin
        MOS6drainConductance = 0;
      end
    end else begin
      MOS6drainConductance = 0;
    end
    if ($param_given(rs)) begin
      if (rs!=0) begin
        MOS6sourceConductance = 1/rs;
      end else begin
        MOS6sourceConductance = 0;
      end
    end else if ($param_given(rsh)) begin
      if (!$param_given(nrs)||MOS6sourceSquares==0) begin
        MOS6sourceSquares = 1;
      end
      if (rsh!=0) begin
        MOS6sourceConductance = 1/(rsh*MOS6sourceSquares);
      end else begin
        MOS6sourceConductance = 0;
      end
    end else begin
      MOS6sourceConductance = 0;
    end

    // Tag: load, function: MOS6load
    xfact = 0.0;
    capgs = 0.0;
    capgd = 0.0;
    capgb = 0.0;
    load_vt = CONSTKoverQ*MOS6temp;
    EffectiveLength = MOS6l-2*ld;
    if (MOS6tSatCurDens==0||MOS6drainArea==0||MOS6sourceArea==0) begin
      DrainSatCur = MOS6tSatCur;
      SourceSatCur = MOS6tSatCur;
    end else begin
      DrainSatCur = MOS6tSatCurDens*MOS6drainArea;
      SourceSatCur = MOS6tSatCurDens*MOS6sourceArea;
    end
    GateSourceOverlapCap = cgso*MOS6w;
    GateDrainOverlapCap = cgdo*MOS6w;
    GateBulkOverlapCap = cgbo*EffectiveLength;
    betac = MOS6tKc*MOS6w/EffectiveLength;
    OxideCap = MOS6oxideCapFactor*EffectiveLength*MOS6w;
    limited = 0;
    /* Previous vgs, vds, vbs, and vbd */
    MOS6vgs = MOS6type * $limit(V(g, s_int), DEVlimitOldGet);
    MOS6vds = MOS6type * $limit(V(d_int, s_int), DEVlimitOldGet);
    MOS6vbs = MOS6type * $limit(V(b, s_int), DEVlimitOldGet);
    MOS6vbd = MOS6type * $limit(V(b, d_int), DEVlimitOldGet);
    
    /* Simplified von value used in limiting, does not require introduction of a hidden state */
    load_von = MOS6type*MOS6tVbi;
    MOS6von = MOS6type*load_von;
    load_vbs = MOS6type*V(b, s_int);
    load_vgs = MOS6type*V(g, s_int);
    load_vds = MOS6type*V(d_int, s_int);
    load_vbd = load_vbs-load_vds;
    vgd = load_vgs-load_vds;
    vgdo = MOS6vgs-MOS6vds;
    if (!(MOS6mode>=0)) begin

    end
    load_von = MOS6type*MOS6von;
    if (MOS6vds>=0) begin
      load_vgs = DEVfetlim(load_vgs, MOS6vgs, load_von, limited);
      load_vds = load_vgs-vgd;
      load_vds = DEVlimvds(load_vds, MOS6vds, limited);
      vgd = load_vgs-load_vds;
    end else begin
      vgd = DEVfetlim(vgd, vgdo, load_von, limited);
      load_vds = load_vgs-vgd;
      if (!oldlimit) begin
        load_vds = -DEVlimvds(-load_vds, -MOS6vds, limited);
      end
      load_vgs = vgd+load_vds;
    end
    if (load_vds>=0) begin
      load_vbs = DEVpnjlim(load_vbs, MOS6vbs, load_vt, MOS6sourceVcrit, limited);
      load_vbd = load_vbs-load_vds;
    end else begin
      load_vbd = DEVpnjlim(load_vbd, MOS6vbd, load_vt, MOS6drainVcrit, limited);
      load_vbs = load_vbd+load_vds;
    end
    if (initialize_limiting()) begin
        load_vbs = -1;
        load_vgs = MOS6type * MOS6tVto;
        load_vds = 0;
        load_vbd = load_vbs - load_vds;
    end
    
    load_vgs = MOS6type * $limit(V(g, s_int), DEVlimitNewSet, MOS6type * load_vgs, limited);
    load_vds = MOS6type * $limit(V(d_int, s_int), DEVlimitNewSet, MOS6type * load_vds, limited);
    load_vbs = MOS6type * $limit(V(b, s_int), DEVlimitNewSet, MOS6type * load_vbs, limited);
    load_vbd = MOS6type * $limit(V(b, d_int), DEVlimitNewSet, MOS6type * load_vbd, limited);
    load_vbd = load_vbs-load_vds;
    vgd = load_vgs-load_vds;
    vgb = load_vgs-load_vbs;
    if (load_vbs<=-3*load_vt) begin
      MOS6gbs = lc_gmin;
      MOS6cbs = MOS6gbs*load_vbs-SourceSatCur;
    end else begin
      evbs = exp(((709.0<load_vbs/load_vt) ? (709.0) : (load_vbs/load_vt)));
      MOS6gbs = SourceSatCur*evbs/load_vt+lc_gmin;
      MOS6cbs = SourceSatCur*(evbs-1)+lc_gmin*load_vbs;
    end
    if (load_vbd<=-3*load_vt) begin
      MOS6gbd = lc_gmin;
      MOS6cbd = MOS6gbd*load_vbd-DrainSatCur;
    end else begin
      evbd = exp(((709.0<load_vbd/load_vt) ? (709.0) : (load_vbd/load_vt)));
      MOS6gbd = DrainSatCur*evbd/load_vt+lc_gmin;
      MOS6cbd = DrainSatCur*(evbd-1)+lc_gmin*load_vbd;
    end
    if (load_vds>=0) begin
      MOS6mode = 1;
    end else begin
      MOS6mode = -1;
    end
    vonbm = 0.0;
    vbsvbd = ((MOS6mode==1) ? (load_vbs) : (load_vbd));
    if (vbsvbd<=0) begin
      sarg1 = sqrt(MOS6tPhi-vbsvbd);
    end else begin
      sarg1 = sqrt(MOS6tPhi);
      sarg1 = sarg1-vbsvbd/(sarg1+sarg1);
      sarg1 = ((0>sarg1) ? (0) : (sarg1));
    end
    vdshere = load_vds*MOS6mode;
    load_von = MOS6tVbi*MOS6type+MOS6gamma*sarg1-MOS6gamma1*vbsvbd-sigma*vdshere;
    vgon = ((MOS6mode==1) ? (load_vgs) : (vgd))-load_von;
    if (vgon<=0) begin
      load_vdsat = 0;
      cdrain = 0;
      MOS6gm = 0;
      MOS6gds = 0;
      MOS6gmbs = 0;
    end else begin
      if (sarg1<=0) begin
        load_arg1 = 0;
      end else begin
        if (((MOS6mode==1) ? (load_vbs) : (load_vbd))<=0) begin
          vonbm = MOS6gamma1+MOS6gamma/(sarg1+sarg1);
        end else begin
          vonbm = MOS6gamma1+MOS6gamma/2/sqrt(MOS6tPhi);
        end
      end
      sarg1 = ln(vgon);
      load_vdsat = kv*exp(sarg1*nv);
      idsat = betac*exp(sarg1*nc);
      load_lambda = MOS6lamda0-lambda1*vbsvbd;
      cdrain = idsat*(1+load_lambda*vdshere);
      MOS6gm = cdrain*nc/vgon;
      MOS6gds = MOS6gm*sigma+idsat*load_lambda;
      MOS6gmbs = MOS6gm*vonbm-idsat*lambda1*vdshere;
      if (load_vdsat>vdshere) begin
        vdst = vdshere/load_vdsat;
        vdst2 = (2-vdst)*vdst;
        vdstg = -vdst*nv/vgon;
        ivdst1 = cdrain*(2-vdst-vdst);
        cdrain = cdrain*vdst2;
        MOS6gm = MOS6gm*vdst2+ivdst1*vdstg;
        MOS6gds = MOS6gds*vdst2+ivdst1*(1/load_vdsat+vdstg*sigma);
        MOS6gmbs = MOS6gmbs*vdst2+ivdst1*vdstg*vonbm;
      end
    end
    MOS6von = MOS6type*load_von;
    MOS6vdsat = MOS6type*load_vdsat;
    MOS6cd = MOS6mode*cdrain-MOS6cbd;
    if (OxideCap==0) begin
        meyer_scale = 0;
        meyer_unscale = 1;
    end else begin
        meyer_scale = OxideCap;
        meyer_unscale = OxideCap;
    end
    if (MOS6Cbs!=0||MOS6Cbssw!=0) begin
      if (load_vbs<MOS6tDepCap) begin
        load_arg = 1-load_vbs/MOS6tBulkPot;
        if (mj==mjsw) begin
          if (mj==0.5) begin
            load_sargsw = 1/sqrt(load_arg);
            load_sarg = load_sargsw;
          end else begin
            load_sargsw = exp(-mj*ln(load_arg));
            load_sarg = load_sargsw;
          end
        end else begin
          if (mj==0.5) begin
            load_sarg = 1/sqrt(load_arg);
          end else begin
            load_sarg = exp(-mj*ln(load_arg));
          end
          if (mjsw==0.5) begin
            load_sargsw = 1/sqrt(load_arg);
          end else begin
            load_sargsw = exp(-mjsw*ln(load_arg));
          end
        end
        MOS6qbs = MOS6tBulkPot*(MOS6Cbs*(1-load_arg*load_sarg)/(1-mj)+MOS6Cbssw*(1-load_arg*load_sargsw)/(1-mjsw));
        MOS6capbs = MOS6Cbs*load_sarg+MOS6Cbssw*load_sargsw;
      end else begin
        MOS6qbs = MOS6f4s+load_vbs*(MOS6f2s+load_vbs*(MOS6f3s/2));
        MOS6capbs = MOS6f2s+MOS6f3s*load_vbs;
      end
    end else begin
      MOS6qbs = 0;
      MOS6capbs = 0;
    end
    if (MOS6Cbd!=0||MOS6Cbdsw!=0) begin
      if (load_vbd<MOS6tDepCap) begin
        load_arg = 1-load_vbd/MOS6tBulkPot;
        if (mj==0.5&&mjsw==0.5) begin
          load_sargsw = 1/sqrt(load_arg);
          load_sarg = load_sargsw;
        end else begin
          if (mj==0.5) begin
            load_sarg = 1/sqrt(load_arg);
          end else begin
            load_sarg = exp(-mj*ln(load_arg));
          end
          if (mjsw==0.5) begin
            load_sargsw = 1/sqrt(load_arg);
          end else begin
            load_sargsw = exp(-mjsw*ln(load_arg));
          end
        end
        MOS6qbd = MOS6tBulkPot*(MOS6Cbd*(1-load_arg*load_sarg)/(1-mj)+MOS6Cbdsw*(1-load_arg*load_sargsw)/(1-mjsw));
        MOS6capbd = MOS6Cbd*load_sarg+MOS6Cbdsw*load_sargsw;
      end else begin
        MOS6qbd = MOS6f4d+load_vbd*(MOS6f2d+load_vbd*MOS6f3d/2);
        MOS6capbd = MOS6f2d+load_vbd*MOS6f3d;
      end
    end else begin
      MOS6qbd = 0;
      MOS6capbd = 0;
    end
    geq = 0;
    MOS6cqbd = ddt(MOS6qbd);
    ceq = MOS6cqbd;
    MOS6gbd = MOS6gbd + (geq);
    MOS6cbd = MOS6cbd + (MOS6cqbd);
    MOS6cd = MOS6cd - (MOS6cqbd);
    geq = 0;
    MOS6cqbs = ddt(MOS6qbs);
    ceq = MOS6cqbs;
    MOS6gbs = MOS6gbs + (geq);
    MOS6cbs = MOS6cbs + (MOS6cqbs);
    MOS6vbs = load_vbs;
    MOS6vbd = load_vbd;
    MOS6vgs = load_vgs;
    MOS6vds = load_vds;
    if (MOS6mode>0) begin
      DEVqmeyer(load_vgs, vgd, vgb, load_von, load_vdsat, MOS6capgs, MOS6capgd, MOS6capgb, MOS6tPhi, OxideCap);
    end else begin
      DEVqmeyer(vgd, load_vgs, vgb, load_von, load_vdsat, MOS6capgd, MOS6capgs, MOS6capgb, MOS6tPhi, OxideCap);
    end
    capgs = MOS6capgs+MOS6capgs+GateSourceOverlapCap;
    capgd = MOS6capgd+MOS6capgd+GateDrainOverlapCap;
    capgb = MOS6capgb+MOS6capgb+GateBulkOverlapCap;
    if (capgs==0) begin
      MOS6cqgs = 0;
    end
    if (capgd==0) begin
      MOS6cqgd = 0;
    end
    if (capgb==0) begin
      MOS6cqgb = 0;
    end
    gcgs = 0;
    ceqgs = capgs*(ddt(meyer_scale*load_vgs)/meyer_unscale);
    gcgd = 0;
    ceqgd = capgd*(ddt(meyer_scale*vgd)/meyer_unscale);
    gcgb = 0;
    ceqgb = capgb*(ddt(meyer_scale*vgb)/meyer_unscale);
    m = 1;
    ceqbs = MOS6type*(MOS6cbs-MOS6gbs*load_vbs);
    ceqbd = MOS6type*(MOS6cbd-MOS6gbd*load_vbd);
    if (MOS6mode>=0) begin
      xnrm = 1;
      xrev = 0;
      cdreq = MOS6type*cdrain;
    end else begin
      xnrm = 0;
      xrev = 1;
      cdreq = -MOS6type*cdrain;
    end
    
    // Residuals
    I(d) <+ MOS6drainConductance*V(d, d_int);
    I(g) <+ gcgb*V(g, b)+gcgd*V(g, d_int)+gcgs*V(g, s_int)+MOS6type*(ceqgs+ceqgb+ceqgd);
    I(s) <+ MOS6sourceConductance*V(s, s_int);
    I(b) <+ MOS6gbd*V(b, d_int)+MOS6gbs*V(b, s_int)+gcgb*V(b, g)+(ceqbs+ceqbd-MOS6type*ceqgb);
    I(d_int) <+ MOS6drainConductance*V(d_int, d)+MOS6gbd*V(d_int, b)+gcgd*V(d_int, g)+-(ceqbd-cdreq+MOS6type*ceqgd);
    I(s_int) <+ MOS6gbs*V(s_int, b)+MOS6sourceConductance*V(s_int, s)+gcgs*V(s_int, g)+-(cdreq+ceqbs+MOS6type*ceqgs);

    // Instance opvar computation
    ibs = MOS6cbs;
    ibd = MOS6cbd;
    vgs = MOS6vgs;
    vds = MOS6vds;
    vbs = MOS6vbs;
    vbd = MOS6vbd;
    sourceconductance = MOS6sourceConductance;
    drainconductance = MOS6drainConductance;
    von = MOS6von;
    vdsat = MOS6vdsat;
    sourcevcrit = MOS6sourceVcrit;
    drainvcrit = MOS6drainVcrit;
    gmbs = MOS6gmbs;
    gm = MOS6gm;
    gds = MOS6gds;
    gbd = MOS6gbd;
    gbs = MOS6gbs;
    cgs = 2*MOS6capgs;
    cgs = cgs + (cgso*MOS6w);
    cgd = 2*MOS6capgd;
    cgd = cgd + (cgso*MOS6w);
    cgb = 2*MOS6capgb;
    cgb = cgb + (cgbo*(MOS6l-2*ld));
    c_bd = MOS6capbd;
    c_bs = MOS6capbs;
    cbd0 = MOS6Cbd;
    cbdsw0 = MOS6Cbdsw;
    cbs0 = MOS6Cbs;
    cbssw0 = MOS6Cbssw;
    cqgs = MOS6cqgs;
    cqgd = MOS6cqgd;
    cqgb = MOS6cqgb;
    cqbd = MOS6cqbd;
    cqbs = MOS6cqbs;
    qbd = MOS6qbd;
    qbs = MOS6qbs;

    // Model opvar computation

  end
endmodule
