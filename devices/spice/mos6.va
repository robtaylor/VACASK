// Model generated by Verilog-A Distiller.
// (c)2025 Arpad Buermen. All rights reserved.
// SPDX-License-Identifier: AGPL-3.0-or-later
// 
// SPICE flavour: ngspice
// Version      : ngspice-45-84-g7f75f09ec
// Origin       : https://sourceforge.net/u/arpadbuermen/ngspice/ci/vadng-pre-46/tree/
// Date         : 2025-11-21 10:57:18 UTC
// Module name  : sp_mos6
// Model variant: default
// 
// Notes:
//   Parameter m was replaced with builtin Verilog-A parameter $mfactor.
//
//   All parameters and output variables refer to a single parallel instance,
//   even if $mfactor>1.
//
//   Parameter off was removed. Bypassing is not available in Verilog-A. 
//   
//   Device type is set by the type parameter to NMOS (1) or PMOS (-1). 
//   
//   Output variables rs and rd were removed due to a conflict with model 
//   parameters. Their inverses are available as sourceconductance and 
//   drainconductance output variables. 
//   
//   Output variables cbd, cbs, ig, id, is, and ib were renamed to c_bd, 
//   c_bs, i_g, i_d, i_s, i_b due to conflicts with model parameters. 
//   
//   Meyer charge is not computed and therefore not available. 
//   Output variables qgs, qgd, and qgb were removed. 
//   
//   Parameters ic, icvds, icvgs, and icvbs were removed. Initial conditions 
//   should be set via the simulator's initial conditions mechanism. 
//   
//   A noise model was grafted into this device (SPICE3 source code lacks 
//   a noise model). Noise model level (nlev) above 2 is not supported. 
//   
//   The noise model excludes Meyer capacitance currents from the drain 
//   current that is used for computing noise. This is a SPICE3 feature. 
//   Simplified noise model also excludes the capacitive current of the 
//   B-D diode. Due to the way OpenVAF handles c(v)*ddt(v) the implicit 
//   equations do not go away even if simplified noise model is used.
//
// CKTcircuit member mapping
//   CKTdefaultMosAD -> ('defad', '$simparam("defad", 0)', 'const')
//   CKTdefaultMosAS -> ('defas', '$simparam("defas", 0)', 'const')
//    CKTdefaultMosL -> ('defl', '$simparam("defl", 1e-4)', 'const')
//    CKTdefaultMosW -> ('defw', '$simparam("defw", 1e-4)', 'const')
//       CKTfixLimit -> ('oldlimit', '$simparam("oldlimit", 0)', 'const')
//           CKTgmin -> ('gmin', '$simparam("gmin", 1e-12)')
//        CKTnomTemp -> ('tnom', '($simparam("tnom", 27)+273.15)')
//           CKTtemp -> (None, '$temperature')
//
// Source files and copyright information:
//   devsup.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//   mos6/mos6defs.h
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//   mos6/mos6.c
//   mos6/mos6par.c
//   mos6/mos6mpar.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//   mos6/mos6ask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//     Modified: 2000 AlansFixes
//   mos6/mos6mask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//   mos6/mos6set.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//     Modified: 2000 AlansFixes
//   mos6/mos6temp.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//   mos6/mos6load.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1989 Takayasu Sakurai
//     Modified: 2000 AlansFixes

`include "constants.vams"
`include "disciplines.vams"

module sp_mos6(d, g, s, b);
  inout d, g, s, b;
  electrical d, g, s, b, d_int, s_int;

  // Instance parameters
  (* desc = "Length", type = "instance" *) parameter real l = 0;
  (* desc = "Width", type = "instance" *) parameter real w = 0;
  (* desc = "Drain area", type = "instance" *) parameter real ad = 0;
  (* desc = "Source area", type = "instance" *) parameter real as = 0;
  (* desc = "Drain perimeter", type = "instance" *) parameter real pd = 0;
  (* desc = "Source perimeter", type = "instance" *) parameter real ps = 0;
  (* desc = "Drain squares", type = "instance" *) parameter real nrd = 0;
  (* desc = "Source squares", type = "instance" *) parameter real nrs = 0;
  (* desc = "Instance temperature", type = "instance" *) parameter real temp = 0;
  (* desc = "Instance temperature difference", type = "instance" *) parameter real dtemp = 0.0;

  // Model parameters
  (* desc = "NMOS (1) or PMOS (-1)" *) parameter integer type = 1;
  (* desc = "Threshold voltage" *) parameter real vto = 0;
  aliasparam vt0 = vto;
  (* desc = "Saturation voltage factor" *) parameter real kv = 2;
  (* desc = "Saturation voltage coeff." *) parameter real nv = 0.5;
  (* desc = "Saturation current factor" *) parameter real kc = 5e-05;
  (* desc = "Saturation current coeff." *) parameter real nc = 1;
  (* desc = "Threshold voltage coeff." *) parameter real nvth = 0.5;
  (* desc = "Sat. current modification  par." *) parameter real ps_mod = 0;
  (* desc = "Bulk threshold parameter" *) parameter real gamma = 0;
  (* desc = "Bulk threshold parameter 1" *) parameter real gamma1 = 0;
  (* desc = "Static feedback effect par." *) parameter real sigma = 0;
  (* desc = "Surface potential" *) parameter real phi = 0.6;
  (* desc = "Channel length modulation param." *) parameter real lambda = 0;
  (* desc = "Channel length modulation param. 0" *) parameter real lambda0 = 0;
  (* desc = "Channel length modulation param. 1" *) parameter real lambda1 = 0;
  (* desc = "Drain ohmic resistance" *) parameter real rd = 0;
  (* desc = "Source ohmic resistance" *) parameter real rs = 0;
  (* desc = "B-D junction capacitance" *) parameter real cbd = 0;
  (* desc = "B-S junction capacitance" *) parameter real cbs = 0;
  (* desc = "Bulk junction sat. current" *) parameter real is = 1e-14;
  (* desc = "Bulk junction potential" *) parameter real pb = 0.8;
  (* desc = "Gate-source overlap cap." *) parameter real cgso = 0;
  (* desc = "Gate-drain overlap cap." *) parameter real cgdo = 0;
  (* desc = "Gate-bulk overlap cap." *) parameter real cgbo = 0;
  (* desc = "Sheet resistance" *) parameter real rsh = 0;
  (* desc = "Bottom junction cap per area" *) parameter real cj = 0;
  (* desc = "Bottom grading coefficient" *) parameter real mj = 0.5;
  (* desc = "Side junction cap per area" *) parameter real cjsw = 0;
  (* desc = "Side grading coefficient" *) parameter real mjsw = 0.5;
  (* desc = "Bulk jct. sat. current density" *) parameter real js = 0;
  (* desc = "Lateral diffusion" *) parameter real ld = 0;
  (* desc = "Oxide thickness" *) parameter real tox = 0;
  (* desc = "Surface mobility" *) parameter real u0 = 600;
  aliasparam uo = u0;
  (* desc = "Forward bias jct. fit parm." *) parameter real fc = 0.5;
  (* desc = "Gate type" *) parameter integer tpg = 1;
  (* desc = "Substrate doping" *) parameter real nsub = 0;
  (* desc = "Surface state density" *) parameter real nss = 0;
  (* desc = "Parameter measurement temperature" *) parameter real tnom = 0;
  (* desc = "Noise model selection" *) parameter integer nlev = 2;
  (* desc = "Flicker noise coefficient" *) parameter real kf = 0;
  (* desc = "Flicker noise exponent" *) parameter real af = 1;

  // Instance output variables
  (* desc = "Drain current" *) real i_d;
  (* desc = "Source current" *) real i_s;
  (* desc = "Gate current " *) real i_g;
  (* desc = "Bulk current " *) real i_b;
  (* desc = "B-S junction capacitance" *) real ibs;
  (* desc = "B-D junction capacitance" *) real ibd;
  (* desc = "Gate-Source voltage" *) real vgs;
  (* desc = "Drain-Source voltage" *) real vds;
  (* desc = "Bulk-Source voltage" *) real vbs;
  (* desc = "Bulk-Drain voltage" *) real vbd;
  (* desc = "Source conductance" *) real sourceconductance;
  (* desc = "Drain conductance" *) real drainconductance;
  (* desc = "Turn-on voltage" *) real von;
  (* desc = "Saturation drain voltage" *) real vdsat;
  (* desc = "Critical source voltage" *) real sourcevcrit;
  (* desc = "Critical drain voltage" *) real drainvcrit;
  (* desc = "Bulk-Source transconductance" *) real gmbs;
  (* desc = "Transconductance" *) real gm;
  (* desc = "Drain-Source conductance" *) real gds;
  (* desc = "Bulk-Drain conductance" *) real gbd;
  (* desc = "Bulk-Source conductance" *) real gbs;
  (* desc = "Gate-Source capacitance" *) real cgs;
  (* desc = "Gate-Drain capacitance" *) real cgd;
  (* desc = "Gate-Bulk capacitance" *) real cgb;
  (* desc = "Bulk-Drain capacitance" *) real c_bd;
  (* desc = "Bulk-Source capacitance" *) real c_bs;
  (* desc = "Zero-Bias B-D junction capacitance" *) real cbd0;
  (* desc = " " *) real cbdsw0;
  (* desc = "Zero-Bias B-S junction capacitance" *) real cbs0;
  (* desc = " " *) real cbssw0;
  (* desc = "Capacitance due to gate-source charge storage" *) real cqgs;
  (* desc = "Capacitance due to gate-drain charge storage" *) real cqgd;
  (* desc = "Capacitance due to gate-bulk charge storage" *) real cqgb;
  (* desc = "Capacitance due to bulk-drain charge storage" *) real cqbd;
  (* desc = "Capacitance due to bulk-source charge storage" *) real cqbs;
  (* desc = "Bulk-Drain charge storage" *) real qbd;
  (* desc = "Bulk-Source charge storage" *) real qbs;

  // Model output variables

  // Instance fields
  real MOS6l = 0;
  real MOS6w = 0;
  real MOS6drainArea = 0;
  real MOS6sourceArea = 0;
  real MOS6drainSquares = 0;
  real MOS6sourceSquares = 0;
  real MOS6sourceConductance = 0;
  real MOS6drainConductance = 0;
  real MOS6temp = 0;
  real MOS6tKv = 0;
  real MOS6tKc = 0;
  real MOS6tSurfMob = 0;
  real MOS6tPhi = 0;
  real MOS6tVto = 0;
  real MOS6tSatCur = 0;
  real MOS6tSatCurDens = 0;
  real MOS6tCbd = 0;
  real MOS6tCbs = 0;
  real MOS6tCj = 0;
  real MOS6tCjsw = 0;
  real MOS6tBulkPot = 0;
  real MOS6tDepCap = 0;
  real MOS6tVbi = 0;
  real MOS6von = 0;
  real MOS6vdsat = 0;
  real MOS6sourceVcrit = 0;
  real MOS6drainVcrit = 0;
  real MOS6cd = 0;
  real MOS6cbs = 0;
  real MOS6cbd = 0;
  real MOS6gmbs = 0;
  real MOS6gm = 0;
  real MOS6gds = 0;
  real MOS6gbd = 0;
  real MOS6gbs = 0;
  real MOS6capbd = 0;
  real MOS6capbs = 0;
  real MOS6Cbd = 0;
  real MOS6Cbdsw = 0;
  real MOS6Cbs = 0;
  real MOS6Cbssw = 0;
  real MOS6f2d = 0;
  real MOS6f3d = 0;
  real MOS6f4d = 0;
  real MOS6f2s = 0;
  real MOS6f3s = 0;
  real MOS6f4s = 0;
  integer MOS6mode = 0;
  real MOS6cgs = 0;
  real MOS6cgd = 0;
  real MOS6cgb = 0;
  real meyer_scale = 0;
  real meyer_unscale = 0;
  real MOS6dcCurrent = 0;
  real noise_vgs = 0;
  real noise_vds = 0;
  real noise_vgd = 0;
  real noise_vgst = 0;
  real alpha = 0;
  real beta = 0;
  real Sid = 0;
  real noise_dtemp = 0;
  real flicker_psd = 0;
  real flicker_exp = 0;
  integer MOS6tempGiven = 0;

  // Model fields
  real MOS6tnom = 0;
  real MOS6kc = 0;
  real MOS6oxideCapFactor = 0;
  real MOS6vt0 = 0;
  real MOS6phi = 0;
  real MOS6gamma = 0;
  real MOS6gamma1 = 0;
  real MOS6lamda0 = 0;
  real MOS6substrateDoping = 0;
  integer MOS6type = 0;
  integer MOS6tnomGiven = 0;

  // States
  real MOS6vbd = 0;
  real MOS6vbs = 0;
  real MOS6vgs = 0;
  real MOS6vds = 0;
  real MOS6capgs = 0;
  real MOS6qgs = 0;
  real MOS6cqgs = 0;
  real MOS6capgd = 0;
  real MOS6qgd = 0;
  real MOS6cqgd = 0;
  real MOS6capgb = 0;
  real MOS6qgb = 0;
  real MOS6cqgb = 0;
  real MOS6qbd = 0;
  real MOS6cqbd = 0;
  real MOS6qbs = 0;
  real MOS6cqbs = 0;

  // Model parameter access locals

  // Instance parameter access locals

  // Device setup locals

  // Device temperature dependence locals
  real egfet = 0;
  real egfet1 = 0;
  real fact1 = 0;
  real fact2 = 0;
  real kt = 0;
  real kt1 = 0;
  real arg1 = 0;
  real ratio = 0;
  real ratio4 = 0;
  real phio = 0;
  real pbo = 0;
  real gmanew = 0;
  real gmaold = 0;
  real capfact = 0;
  real pbfact1 = 0;
  real pbfact = 0;
  real vt = 0;
  real vtnom = 0;
  real wkfngs = 0;
  real wkfng = 0;
  real fermig = 0;
  real fermis = 0;
  real vfb = 0;
  real czbd = 0;
  real czbdsw = 0;
  real czbs = 0;
  real czbssw = 0;
  real arg = 0;
  real sarg = 0;
  real sargsw = 0;

  // Device load locals
  integer limited = 0;
  real betac = 0;
  real DrainSatCur = 0;
  real EffectiveLength = 0;
  real GateBulkOverlapCap = 0;
  real GateDrainOverlapCap = 0;
  real GateSourceOverlapCap = 0;
  real OxideCap = 0;
  real SourceSatCur = 0;
  real load_arg = 0;
  real cdrain = 0;
  real cdreq = 0;
  real ceq = 0;
  real ceqbd = 0;
  real ceqbs = 0;
  real ceqgb = 0;
  real ceqgd = 0;
  real ceqgs = 0;
  real evbd = 0;
  real evbs = 0;
  real gcgb = 0;
  real gcgd = 0;
  real gcgs = 0;
  real geq = 0;
  real load_sarg = 0;
  real load_sargsw = 0;
  real load_vbd = 0;
  real load_vbs = 0;
  real load_vds = 0;
  real load_vdsat = 0;
  real vgb = 0;
  real vgd = 0;
  real vgdo = 0;
  real load_vgs = 0;
  real load_von = 0;
  real load_vt = 0;
  real xfact = 0;
  integer xnrm = 0;
  integer xrev = 0;
  real capgs = 0;
  real capgd = 0;
  real capgb = 0;
  real m = 0;
  real load_arg1 = 0;
  real sarg1 = 0;
  real vgon = 0;
  real vdshere = 0;
  real vbsvbd = 0;
  real idsat = 0;
  real load_lambda = 0;
  real vonbm = 0;
  real vdst = 0;
  real vdst2 = 0;
  real ivdst1 = 0;
  real vdstg = 0;

  // Device noise locals

  // Global constants
  real CONSTroot2 = sqrt(2.0);
  real CONSTvt0 = 1.38064852e-23*(27+273.15)/1.6021766208e-19;
  real CONSTKoverQ = 1.38064852e-23/1.6021766208e-19;
  real CONSTe = exp(1.0);
  real VACONSTcharge = 1.6021766208e-19;
  real VACONSTboltz = 1.38064852e-23;
  real defad = $simparam("defad", 0);
  real defas = $simparam("defas", 0);
  real defl = $simparam("defl", 1e-4);
  real defw = $simparam("defw", 1e-4);
  real oldlimit = $simparam("oldlimit", 0);
  real VACONST_tnom = ($simparam("tnom", 27)+273.15);

  // Evaluation constants
  real lc_gmin = 0;

  // Translated function definitions
  analog function real DEVqmeyer;
    input vgs, vgd, vgb, von, _vdsat;
    inout capgs, capgd, capgb;
    input phi, cox;
    real vgs;
    real vgd;
    real vgb;
    real von;
    real _vdsat;
    real capgs;
    real capgd;
    real capgb;
    real phi;
    real cox;
    real vdsat;
    real vds;
    real vddif;
    real vddif1;
    real vddif2;
    real vgst;
    begin
      DEVqmeyer = 0;
      vdsat = _vdsat;
      vgst = vgs-von;
      vdsat = ((vdsat>0.025) ? (vdsat) : (0.025));
      if (vgst<=-phi) begin
        capgb = cox/2;
        capgs = 0;
        capgd = 0;
      end else if (vgst<=-phi/2) begin
        capgb = -vgst*cox/(2*phi);
        capgs = 0;
        capgd = 0;
      end else if (vgst<=0) begin
        capgb = -vgst*cox/(2*phi);
        capgs = vgst*cox/(1.5*phi)+cox/3;
        vds = vgs-vgd;
        if (vds>=vdsat) begin
          capgd = 0;
        end else begin
          vddif = 2.0*vdsat-vds;
          vddif1 = vdsat-vds;
          vddif2 = vddif*vddif;
          capgd = capgs*(1.0-vdsat*vdsat/vddif2);
          capgs = capgs*(1.0-vddif1*vddif1/vddif2);
        end
      end else begin
        vds = vgs-vgd;
        vdsat = ((vdsat>0.025) ? (vdsat) : (0.025));
        if (vdsat<=vds) begin
          capgs = cox/3;
          capgd = 0;
          capgb = 0;
        end else begin
          vddif = 2.0*vdsat-vds;
          vddif1 = vdsat-vds;
          vddif2 = vddif*vddif;
          capgd = cox*(1.0-vdsat*vdsat/vddif2)/3;
          capgs = cox*(1.0-vddif1*vddif1/vddif2)/3;
          capgb = 0;
        end
      end
    end
  endfunction

  // Verbatim analog functions
  analog function integer initialize_limiting;
    integer il;
    begin
      il = $simparam("iniLim", -1);
      if (il<0) begin
        // iniLim not available, use heuristics
        initialize_limiting = 
          $simparam("iteration", 10)==1 && 
          (analysis("dc") || analysis("static")) && 
          analysis("nodeset");
      end else begin
        initialize_limiting = il;
      end
    end
  endfunction

  analog function real DEVlimitOldGet;
    input vnew, vold;
    real vnew, vold, result;
    begin
      DEVlimitOldGet = vold;
    end
  endfunction

  analog function real DEVlimitNewSet;
    input vnew, vold, new_value, limited;
    real vnew, vold, new_value;
    integer limited;
    begin
      DEVlimitNewSet = new_value;
      if (limited) begin
        $discontinuity(-1);
      end
    end
  endfunction

  analog function real DEVpnjlim;
    input vnew, vold, vt, vcrit;
    inout limiting_applied;
    real vnew, vold, vt, vcrit, limited, arg;
    integer limiting_applied;
    
    begin
      limited = vnew;
      if ((vnew > vcrit) && (abs(vnew - vold) > (vt + vt))) begin
        // Positive vnew above vcrit, change greater than 2*vt
        if(vold > 0) begin
          arg = (vnew - vold) / vt;
          if(arg > 0) begin
            limited = vold + vt * ln(1+arg);
            limiting_applied = 1;
          end else begin
            limited = vold - vt * ln(1-arg);
            limiting_applied = 1;
          end
        end else begin
          limited = vt *ln(vnew/vt);
          limiting_applied = 1;
        end
      end else if (vnew<0) begin
        // Negative vnew, use ngspice limiting
        if (vold > 0) begin
          arg = -1*vold-1; 
        end else begin
          arg = 2*vold-1;
        end
        if (vnew<arg) begin
          limited = arg;
          limiting_applied = 1;
        end
      end 
      DEVpnjlim = limited;
    end
  endfunction

  analog function real DEVfetlim;
    input vnew, vold, vto;
    inout limiting_applied;
    real vnew, vold, vto, vlimited;
    real vtsthi, vtstlo, vtox, delv, vtemp;
    integer limiting_applied;  
    begin
      vlimited = vnew;
      vtsthi = abs(2*(vold-vto))+2;
      // vtstlo = vtsthi/2 +2;
      vtstlo = abs(vold-vto)+1;
      vtox = vto + 3.5;
      delv = vnew-vold;
      
      if (vold >= vto) begin
        if(vold >= vtox) begin
          if(delv <= 0) begin
            /* going off */
            if(vlimited >= vtox) begin
                if(-delv > vtstlo) begin
                vlimited =  vold - vtstlo;
                end
            end else begin
              vlimited = max(vnew,vto+2);
            end
          end else begin
            /* staying on */
            if(delv >= vtsthi) begin
              vlimited = vold + vtsthi;
            end
          end
        end else begin
          /* middle region */
          if(delv <= 0) begin
            /* decreasing */
            vlimited = max(vnew,vto-0.5);
          end else begin
            /* increasing */
            vlimited = min(vnew,vto+4);
          end
        end
      end else begin
        /* off */
        if(delv <= 0) begin
          if(-delv >vtsthi) begin
            vlimited = vold - vtsthi;
          end
        end else begin
          vtemp = vto + 0.5;
          if(vnew <= vtemp) begin
            if(delv > vtstlo) begin
              vlimited = vold + vtstlo;
            end
          end else begin
            vlimited = vtemp;
          end
        end
      end
      if (vlimited!=vnew) begin
        limiting_applied = 1;
      end
      DEVfetlim = vlimited;
    end
  endfunction

  analog function real DEVlimvds;
    input vnew, vold;
    inout limiting_applied;
    real vnew, vold, vlimited;
    integer limiting_applied;
    begin
      if (vold >= 3.5) begin
        if(vnew > vold) begin
          vlimited = min(vnew, (3 * vold) + 2);
        end else begin
          if (vnew < 3.5) begin
            vlimited = max(vnew, 2);
          end else begin
            vlimited = vnew;
          end
        end
      end else begin
        if(vnew > vold) begin
          vlimited = min(vnew, 4);
        end else begin
          vlimited = max(vnew, -0.5);
        end
      end
      DEVlimvds = vlimited;
      if (vlimited!=vnew) begin
        limiting_applied = 1;
      end
    end
  endfunction

  // Analog block
  analog begin

    // Instance field assignments
    if ($param_given(l)) begin
      MOS6l = l;
    end
    if ($param_given(w)) begin
      MOS6w = w;
    end
    if ($param_given(ad)) begin
      MOS6drainArea = ad;
    end
    if ($param_given(as)) begin
      MOS6sourceArea = as;
    end
    if ($param_given(nrd)) begin
      MOS6drainSquares = nrd;
    end
    if ($param_given(nrs)) begin
      MOS6sourceSquares = nrs;
    end
    if ($param_given(temp)) begin
      MOS6temp = temp+273.15;
      MOS6tempGiven = 1;
    end

    // Model field assignments
    MOS6type = type;
    if ($param_given(vto)) begin
      MOS6vt0 = vto;
    end
    if ($param_given(kc)) begin
      MOS6kc = kc;
    end
    if ($param_given(gamma)) begin
      MOS6gamma = gamma;
    end
    if ($param_given(gamma1)) begin
      MOS6gamma1 = gamma1;
    end
    if ($param_given(phi)) begin
      MOS6phi = phi;
    end
    if ($param_given(lambda0)) begin
      MOS6lamda0 = lambda0;
    end
    if ($param_given(nsub)) begin
      MOS6substrateDoping = nsub;
    end
    if ($param_given(tnom)) begin
      MOS6tnom = tnom+273.15;
      MOS6tnomGiven = 1;
    end

    // Evaluation constants
    lc_gmin = $simparam("gmin", 1e-12);

    // Tag: setup, function: MOS6setup
    if (!$param_given(kc)) begin
      MOS6kc = 5e-5;
    end
    if (!$param_given(vto)) begin
      MOS6vt0 = 0;
    end
    if (!$param_given(phi)) begin
      MOS6phi = 0.6;
    end
    if (!$param_given(lambda0)) begin
      MOS6lamda0 = 0;
      if ($param_given(lambda)) begin
        MOS6lamda0 = lambda;
      end
    end
    if (!$param_given(gamma)) begin
      MOS6gamma = 0;
    end
    if (!$param_given(gamma1)) begin
      MOS6gamma1 = 0;
    end
    MOS6vdsat = 0;
    MOS6von = 0;
    if (!(rd!=0||rsh!=0&&MOS6drainSquares!=0)) begin
      V(d_int, d) <+ 0;
    end
    if (!(rs!=0||rsh!=0&&MOS6sourceSquares!=0)) begin
      V(s_int, s) <+ 0;
    end

    // Tag: temp, function: MOS6temp
    if (!MOS6tnomGiven) begin
      MOS6tnom = VACONST_tnom;
    end
    fact1 = MOS6tnom/(27.0+273.15);
    vtnom = MOS6tnom*CONSTKoverQ;
    kt1 = 1.38064852e-23*MOS6tnom;
    egfet1 = 1.16-7.02e-4*MOS6tnom*MOS6tnom/(MOS6tnom+1108);
    arg1 = -egfet1/(kt1+kt1)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact1 = -2*vtnom*(1.5*ln(fact1)+1.6021766208e-19*arg1);
    if (MOS6phi<=0.0) begin
      $fatal(0, "Phi is not positive.");
    end
    if (!$param_given(tox)||tox==0) begin
      MOS6oxideCapFactor = 0;
    end else begin
      MOS6oxideCapFactor = 3.9*8.854214871e-12/tox;
      if (!$param_given(kc)) begin
        MOS6kc = 0.5*u0*MOS6oxideCapFactor*1e-4;
      end
      if ($param_given(nsub)) begin
        if (MOS6substrateDoping*1e6>1.45e16) begin
          if (!$param_given(phi)) begin
            MOS6phi = 2*vtnom*ln(MOS6substrateDoping*1e6/1.45e16);
            MOS6phi = ((0.1>MOS6phi) ? (0.1) : (MOS6phi));
          end
          fermis = MOS6type*0.5*MOS6phi;
          wkfng = 3.2;
          if (tpg!=0) begin
            fermig = MOS6type*tpg*0.5*egfet1;
            wkfng = 3.25+0.5*egfet1-fermig;
          end
          wkfngs = wkfng-(3.25+0.5*egfet1+fermis);
          if (!$param_given(gamma)) begin
            MOS6gamma = sqrt(2*11.70*8.854214871e-12*1.6021766208e-19*MOS6substrateDoping*1e6)/MOS6oxideCapFactor;
          end
          if (!$param_given(gamma1)) begin
            MOS6gamma1 = 0.0;
          end
          if (!$param_given(vto)) begin
            vfb = wkfngs-nss*1e4*1.6021766208e-19/MOS6oxideCapFactor;
            MOS6vt0 = vfb+MOS6type*(MOS6gamma*sqrt(MOS6phi)+MOS6phi);
          end
        end else begin
          MOS6substrateDoping = 0;
          $fatal(0, "Nsub < Ni");
        end
      end
    end
    if (!MOS6tempGiven) begin
      MOS6temp = $temperature+dtemp;
    end
    vt = MOS6temp*CONSTKoverQ;
    ratio = MOS6temp/MOS6tnom;
    fact2 = MOS6temp/(27.0+273.15);
    kt = MOS6temp*1.38064852e-23;
    egfet = 1.16-7.02e-4*MOS6temp*MOS6temp/(MOS6temp+1108);
    arg = -egfet/(kt+kt)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact = -2*vt*(1.5*ln(fact2)+1.6021766208e-19*arg);
    if (!$param_given(ad)) begin
      MOS6drainArea = defad;
    end
    if (!$param_given(l)) begin
      MOS6l = defl;
    end
    if (!$param_given(as)) begin
      MOS6sourceArea = defas;
    end
    if (!$param_given(w)) begin
      MOS6w = defw;
    end
    if (MOS6l-2*ld<=0) begin
      $warning("effective channel length less than zero");
    end
    ratio4 = ratio*sqrt(ratio);
    MOS6tKv = kv;
    MOS6tKc = MOS6kc/ratio4;
    MOS6tSurfMob = u0/ratio4;
    phio = (MOS6phi-pbfact1)/fact1;
    MOS6tPhi = fact2*phio+pbfact;
    MOS6tVbi = MOS6vt0-MOS6type*(MOS6gamma*sqrt(MOS6phi))+0.5*(egfet1-egfet)+MOS6type*0.5*(MOS6tPhi-MOS6phi);
    MOS6tVto = MOS6tVbi+MOS6type*MOS6gamma*sqrt(MOS6tPhi);
    MOS6tSatCur = is*exp(-egfet/vt+egfet1/vtnom);
    MOS6tSatCurDens = js*exp(-egfet/vt+egfet1/vtnom);
    pbo = (pb-pbfact1)/fact1;
    gmaold = (pb-pbo)/pbo;
    capfact = 1/(1+mj*(4e-4*(MOS6tnom-(27.0+273.15))-gmaold));
    MOS6tCbd = cbd*capfact;
    MOS6tCbs = cbs*capfact;
    MOS6tCj = cj*capfact;
    capfact = 1/(1+mjsw*(4e-4*(MOS6tnom-(27.0+273.15))-gmaold));
    MOS6tCjsw = cjsw*capfact;
    MOS6tBulkPot = fact2*pbo+pbfact;
    gmanew = (MOS6tBulkPot-pbo)/pbo;
    capfact = 1+mj*(4e-4*(MOS6temp-(27.0+273.15))-gmanew);
    MOS6tCbd = MOS6tCbd * (capfact);
    MOS6tCbs = MOS6tCbs * (capfact);
    MOS6tCj = MOS6tCj * (capfact);
    capfact = 1+mjsw*(4e-4*(MOS6temp-(27.0+273.15))-gmanew);
    MOS6tCjsw = MOS6tCjsw * (capfact);
    MOS6tDepCap = fc*MOS6tBulkPot;
    if (MOS6tSatCurDens==0||MOS6drainArea==0||MOS6sourceArea==0) begin
      MOS6drainVcrit = vt*ln(vt/(CONSTroot2*MOS6tSatCur));
      MOS6sourceVcrit = MOS6drainVcrit;
    end else begin
      MOS6drainVcrit = vt*ln(vt/(CONSTroot2*MOS6tSatCurDens*MOS6drainArea));
      MOS6sourceVcrit = vt*ln(vt/(CONSTroot2*MOS6tSatCurDens*MOS6sourceArea));
    end
    if ($param_given(cbd)) begin
      czbd = MOS6tCbd;
    end else if ($param_given(cj)) begin
      czbd = MOS6tCj*MOS6drainArea;
    end else begin
      czbd = 0;
    end
    if ($param_given(cjsw)) begin
      czbdsw = MOS6tCjsw*pd;
    end else begin
      czbdsw = 0;
    end
    arg = 1-fc;
    sarg = exp(-mj*ln(arg));
    sargsw = exp(-mjsw*ln(arg));
    MOS6Cbd = czbd;
    MOS6Cbdsw = czbdsw;
    MOS6f2d = czbd*(1-fc*(1+mj))*sarg/arg+czbdsw*(1-fc*(1+mjsw))*sargsw/arg;
    MOS6f3d = czbd*mj*sarg/arg/MOS6tBulkPot+czbdsw*mjsw*sargsw/arg/MOS6tBulkPot;
    MOS6f4d = czbd*MOS6tBulkPot*(1-arg*sarg)/(1-mj)+czbdsw*MOS6tBulkPot*(1-arg*sargsw)/(1-mjsw)-MOS6f3d/2*(MOS6tDepCap*MOS6tDepCap)-MOS6tDepCap*MOS6f2d;
    if ($param_given(cbs)) begin
      czbs = MOS6tCbs;
    end else if ($param_given(cj)) begin
      czbs = MOS6tCj*MOS6sourceArea;
    end else begin
      czbs = 0;
    end
    if ($param_given(cjsw)) begin
      czbssw = MOS6tCjsw*ps;
    end else begin
      czbssw = 0;
    end
    arg = 1-fc;
    sarg = exp(-mj*ln(arg));
    sargsw = exp(-mjsw*ln(arg));
    MOS6Cbs = czbs;
    MOS6Cbssw = czbssw;
    MOS6f2s = czbs*(1-fc*(1+mj))*sarg/arg+czbssw*(1-fc*(1+mjsw))*sargsw/arg;
    MOS6f3s = czbs*mj*sarg/arg/MOS6tBulkPot+czbssw*mjsw*sargsw/arg/MOS6tBulkPot;
    MOS6f4s = czbs*MOS6tBulkPot*(1-arg*sarg)/(1-mj)+czbssw*MOS6tBulkPot*(1-arg*sargsw)/(1-mjsw)-MOS6f3s/2*(MOS6tDepCap*MOS6tDepCap)-MOS6tDepCap*MOS6f2s;
    if ($param_given(rd)) begin
      if (rd!=0) begin
        MOS6drainConductance = 1/rd;
      end else begin
        MOS6drainConductance = 0;
      end
    end else if ($param_given(rsh)) begin
      if (!$param_given(nrd)||MOS6drainSquares==0) begin
        MOS6drainSquares = 1;
      end
      if (rsh!=0) begin
        MOS6drainConductance = 1/(rsh*MOS6drainSquares);
      end else begin
        MOS6drainConductance = 0;
      end
    end else begin
      MOS6drainConductance = 0;
    end
    if ($param_given(rs)) begin
      if (rs!=0) begin
        MOS6sourceConductance = 1/rs;
      end else begin
        MOS6sourceConductance = 0;
      end
    end else if ($param_given(rsh)) begin
      if (!$param_given(nrs)||MOS6sourceSquares==0) begin
        MOS6sourceSquares = 1;
      end
      if (rsh!=0) begin
        MOS6sourceConductance = 1/(rsh*MOS6sourceSquares);
      end else begin
        MOS6sourceConductance = 0;
      end
    end else begin
      MOS6sourceConductance = 0;
    end

    // Tag: load, function: MOS6load
    xfact = 0.0;
    capgs = 0.0;
    capgd = 0.0;
    capgb = 0.0;
    load_vt = CONSTKoverQ*MOS6temp;
    EffectiveLength = MOS6l-2*ld;
    if (MOS6tSatCurDens==0||MOS6drainArea==0||MOS6sourceArea==0) begin
      DrainSatCur = MOS6tSatCur;
      SourceSatCur = MOS6tSatCur;
    end else begin
      DrainSatCur = MOS6tSatCurDens*MOS6drainArea;
      SourceSatCur = MOS6tSatCurDens*MOS6sourceArea;
    end
    GateSourceOverlapCap = cgso*MOS6w;
    GateDrainOverlapCap = cgdo*MOS6w;
    GateBulkOverlapCap = cgbo*EffectiveLength;
    betac = MOS6tKc*MOS6w/EffectiveLength;
    OxideCap = MOS6oxideCapFactor*EffectiveLength*MOS6w;
    limited = 0;
    /* Previous vgs, vds, vbs, and vbd */
    MOS6vgs = MOS6type * $limit(V(g, s_int), DEVlimitOldGet);
    MOS6vds = MOS6type * $limit(V(d_int, s_int), DEVlimitOldGet);
    MOS6vbs = MOS6type * $limit(V(b, s_int), DEVlimitOldGet);
    MOS6vbd = MOS6type * $limit(V(b, d_int), DEVlimitOldGet);
    
    /* Simplified von value used in limiting, does not require introduction of a hidden state */
    load_von = MOS6type*MOS6tVbi;
    MOS6von = MOS6type*load_von;
    load_vbs = MOS6type*V(b, s_int);
    load_vgs = MOS6type*V(g, s_int);
    load_vds = MOS6type*V(d_int, s_int);
    load_vbd = load_vbs-load_vds;
    vgd = load_vgs-load_vds;
    vgdo = MOS6vgs-MOS6vds;
    load_von = MOS6type*MOS6von;
    if (MOS6vds>=0) begin
      load_vgs = DEVfetlim(load_vgs, MOS6vgs, load_von, limited);
      load_vds = load_vgs-vgd;
      load_vds = DEVlimvds(load_vds, MOS6vds, limited);
      vgd = load_vgs-load_vds;
    end else begin
      vgd = DEVfetlim(vgd, vgdo, load_von, limited);
      load_vds = load_vgs-vgd;
      if (!oldlimit) begin
        load_vds = -DEVlimvds(-load_vds, -MOS6vds, limited);
      end
      load_vgs = vgd+load_vds;
    end
    if (load_vds>=0) begin
      load_vbs = DEVpnjlim(load_vbs, MOS6vbs, load_vt, MOS6sourceVcrit, limited);
      load_vbd = load_vbs-load_vds;
    end else begin
      load_vbd = DEVpnjlim(load_vbd, MOS6vbd, load_vt, MOS6drainVcrit, limited);
      load_vbs = load_vbd+load_vds;
    end
    if (initialize_limiting()) begin
        load_vbs = -1;
        load_vgs = MOS6type * MOS6tVto;
        load_vds = 0;
        load_vbd = load_vbs - load_vds;
    end
    
    load_vgs = MOS6type * $limit(V(g, s_int), DEVlimitNewSet, MOS6type * load_vgs, limited);
    load_vds = MOS6type * $limit(V(d_int, s_int), DEVlimitNewSet, MOS6type * load_vds, limited);
    load_vbs = MOS6type * $limit(V(b, s_int), DEVlimitNewSet, MOS6type * load_vbs, limited);
    load_vbd = MOS6type * $limit(V(b, d_int), DEVlimitNewSet, MOS6type * load_vbd, limited);
    load_vbd = load_vbs-load_vds;
    vgd = load_vgs-load_vds;
    vgb = load_vgs-load_vbs;
    if (load_vbs<=-3*load_vt) begin
      MOS6gbs = lc_gmin;
      MOS6cbs = lc_gmin*load_vbs-SourceSatCur;
    end else begin
      evbs = exp(((709.0<load_vbs/load_vt) ? (709.0) : (load_vbs/load_vt)));
      MOS6gbs = SourceSatCur*evbs/load_vt+lc_gmin;
      MOS6cbs = SourceSatCur*(evbs-1)+lc_gmin*load_vbs;
    end
    if (load_vbd<=-3*load_vt) begin
      MOS6gbd = lc_gmin;
      MOS6cbd = lc_gmin*load_vbd-DrainSatCur;
    end else begin
      evbd = exp(((709.0<load_vbd/load_vt) ? (709.0) : (load_vbd/load_vt)));
      MOS6gbd = DrainSatCur*evbd/load_vt+lc_gmin;
      MOS6cbd = DrainSatCur*(evbd-1)+lc_gmin*load_vbd;
    end
    if (load_vds>=0) begin
      MOS6mode = 1;
    end else begin
      MOS6mode = -1;
    end
    vonbm = 0.0;
    vbsvbd = ((MOS6mode==1) ? (load_vbs) : (load_vbd));
    if (vbsvbd<=0) begin
      sarg1 = sqrt(MOS6tPhi-vbsvbd);
    end else begin
      sarg1 = sqrt(MOS6tPhi);
      sarg1 = sarg1-vbsvbd/(sarg1+sarg1);
      sarg1 = ((0>sarg1) ? (0) : (sarg1));
    end
    vdshere = load_vds*MOS6mode;
    load_von = MOS6tVbi*MOS6type+MOS6gamma*sarg1-MOS6gamma1*vbsvbd-sigma*vdshere;
    vgon = ((MOS6mode==1) ? (load_vgs) : (vgd))-load_von;
    if (vgon<=0) begin
      load_vdsat = 0;
      cdrain = 0;
      MOS6gm = 0;
      MOS6gds = 0;
      MOS6gmbs = 0;
    end else begin
      if (sarg1<=0) begin
        load_arg1 = 0;
      end else if (((MOS6mode==1) ? (load_vbs) : (load_vbd))<=0) begin
        vonbm = MOS6gamma1+MOS6gamma/(sarg1+sarg1);
      end else begin
        vonbm = MOS6gamma1+MOS6gamma/2/sqrt(MOS6tPhi);
      end
      sarg1 = ln(vgon);
      load_vdsat = kv*exp(sarg1*nv);
      idsat = betac*exp(sarg1*nc);
      load_lambda = MOS6lamda0-lambda1*vbsvbd;
      cdrain = idsat*(1+load_lambda*vdshere);
      MOS6gm = cdrain*nc/vgon;
      MOS6gds = MOS6gm*sigma+idsat*load_lambda;
      MOS6gmbs = MOS6gm*vonbm-idsat*lambda1*vdshere;
      if (load_vdsat>vdshere) begin
        vdst = vdshere/load_vdsat;
        vdst2 = (2-vdst)*vdst;
        vdstg = -vdst*nv/vgon;
        ivdst1 = cdrain*(2-vdst-vdst);
        cdrain = cdrain*vdst2;
        MOS6gm = MOS6gm*vdst2+ivdst1*vdstg;
        MOS6gds = MOS6gds*vdst2+ivdst1*(1/load_vdsat+vdstg*sigma);
        MOS6gmbs = MOS6gmbs*vdst2+ivdst1*vdstg*vonbm;
      end
    end
    MOS6von = MOS6type*load_von;
    MOS6vdsat = MOS6type*load_vdsat;
    MOS6dcCurrent = MOS6mode*cdrain-MOS6cbd;
    MOS6cd = MOS6dcCurrent;
    if (OxideCap==0) begin
        meyer_scale = 0;
        meyer_unscale = 1;
    end else begin
        meyer_scale = OxideCap;
        meyer_unscale = OxideCap;
    end
    if (MOS6Cbs!=0||MOS6Cbssw!=0) begin
      if (load_vbs<MOS6tDepCap) begin
        load_arg = 1-load_vbs/MOS6tBulkPot;
        if (mj==mjsw) begin
          if (mj==0.5) begin
            load_sargsw = 1/sqrt(load_arg);
            load_sarg = load_sargsw;
          end else begin
            load_sargsw = exp(-mj*ln(load_arg));
            load_sarg = load_sargsw;
          end
        end else begin
          if (mj==0.5) begin
            load_sarg = 1/sqrt(load_arg);
          end else begin
            load_sarg = exp(-mj*ln(load_arg));
          end
          if (mjsw==0.5) begin
            load_sargsw = 1/sqrt(load_arg);
          end else begin
            load_sargsw = exp(-mjsw*ln(load_arg));
          end
        end
        MOS6qbs = MOS6tBulkPot*(MOS6Cbs*(1-load_arg*load_sarg)/(1-mj)+MOS6Cbssw*(1-load_arg*load_sargsw)/(1-mjsw));
        MOS6capbs = MOS6Cbs*load_sarg+MOS6Cbssw*load_sargsw;
      end else begin
        MOS6qbs = MOS6f4s+load_vbs*(MOS6f2s+load_vbs*(MOS6f3s/2));
        MOS6capbs = MOS6f2s+MOS6f3s*load_vbs;
      end
    end else begin
      MOS6qbs = 0;
      MOS6capbs = 0;
    end
    if (MOS6Cbd!=0||MOS6Cbdsw!=0) begin
      if (load_vbd<MOS6tDepCap) begin
        load_arg = 1-load_vbd/MOS6tBulkPot;
        if (mj==0.5&&mjsw==0.5) begin
          load_sargsw = 1/sqrt(load_arg);
          load_sarg = load_sargsw;
        end else begin
          if (mj==0.5) begin
            load_sarg = 1/sqrt(load_arg);
          end else begin
            load_sarg = exp(-mj*ln(load_arg));
          end
          if (mjsw==0.5) begin
            load_sargsw = 1/sqrt(load_arg);
          end else begin
            load_sargsw = exp(-mjsw*ln(load_arg));
          end
        end
        MOS6qbd = MOS6tBulkPot*(MOS6Cbd*(1-load_arg*load_sarg)/(1-mj)+MOS6Cbdsw*(1-load_arg*load_sargsw)/(1-mjsw));
        MOS6capbd = MOS6Cbd*load_sarg+MOS6Cbdsw*load_sargsw;
      end else begin
        MOS6qbd = MOS6f4d+load_vbd*(MOS6f2d+load_vbd*MOS6f3d/2);
        MOS6capbd = MOS6f2d+load_vbd*MOS6f3d;
      end
    end else begin
      MOS6qbd = 0;
      MOS6capbd = 0;
    end
    geq = 0;
    MOS6cqbd = ddt(MOS6qbd);
    ceq = MOS6cqbd;
    MOS6gbd = MOS6gbd + (geq);
    MOS6cbd = MOS6cbd + (MOS6cqbd);
    MOS6cd = MOS6cd - (MOS6cqbd);
    geq = 0;
    MOS6cqbs = ddt(MOS6qbs);
    ceq = MOS6cqbs;
    MOS6gbs = MOS6gbs + (geq);
    MOS6cbs = MOS6cbs + (MOS6cqbs);
    MOS6vbs = load_vbs;
    MOS6vbd = load_vbd;
    MOS6vgs = load_vgs;
    MOS6vds = load_vds;
    if (MOS6mode>0) begin
      DEVqmeyer(load_vgs, vgd, vgb, load_von, load_vdsat, MOS6capgs, MOS6capgd, MOS6capgb, MOS6tPhi, OxideCap);
    end else begin
      DEVqmeyer(vgd, load_vgs, vgb, load_von, load_vdsat, MOS6capgd, MOS6capgs, MOS6capgb, MOS6tPhi, OxideCap);
    end
    capgs = MOS6capgs+MOS6capgs+GateSourceOverlapCap;
    capgd = MOS6capgd+MOS6capgd+GateDrainOverlapCap;
    capgb = MOS6capgb+MOS6capgb+GateBulkOverlapCap;
    if (capgs==0) begin
      MOS6cqgs = 0;
    end
    if (capgd==0) begin
      MOS6cqgd = 0;
    end
    if (capgb==0) begin
      MOS6cqgb = 0;
    end
    gcgs = 0;
    ceqgs = capgs*(ddt(meyer_scale*load_vgs)/meyer_unscale);
    MOS6cqgs = ceqgs;
    gcgd = 0;
    ceqgd = capgd*(ddt(meyer_scale*vgd)/meyer_unscale);
    MOS6cqgd = ceqgd;
    gcgb = 0;
    ceqgb = capgb*(ddt(meyer_scale*vgb)/meyer_unscale);
    MOS6cqgb = ceqgb;
    m = 1;
    ceqbs = MOS6type*MOS6cbs;
    ceqbd = MOS6type*MOS6cbd;
    if (MOS6mode>=0) begin
      xnrm = 1;
      xrev = 0;
      cdreq = MOS6type*cdrain;
    end else begin
      xnrm = 0;
      xrev = 1;
      cdreq = -MOS6type*cdrain;
    end
    
    // Residuals
    I(d) <+ MOS6drainConductance*V(d, d_int);
    I(g) <+ gcgb*V(g, b)+gcgd*V(g, d_int)+gcgs*V(g, s_int)+MOS6type*(ceqgs+ceqgb+ceqgd);
    I(s) <+ MOS6sourceConductance*V(s, s_int);
    I(b) <+ gcgb*V(b, g)+(ceqbs+ceqbd-MOS6type*ceqgb);
    I(d_int) <+ MOS6drainConductance*V(d_int, d)+gcgd*V(d_int, g)+-(ceqbd-cdreq+MOS6type*ceqgd);
    I(s_int) <+ MOS6sourceConductance*V(s_int, s)+gcgs*V(s_int, g)+-(cdreq+ceqbs+MOS6type*ceqgs);
    // Grafted noise model
    if (MOS6tempGiven) begin
        noise_dtemp = MOS6temp-$temperature+(MOS6tnom-273.15);
    end else begin
        noise_dtemp = dtemp;
    end
    I(d_int, d) <+ white_noise(4*(VACONSTboltz*(($temperature+noise_dtemp)*MOS6drainConductance)), "rd");
    I(s_int, s) <+ white_noise(4*(VACONSTboltz*(($temperature+noise_dtemp)*MOS6sourceConductance)), "rs");
    if (nlev<3) begin
        Sid = 2.0/3.0*abs(MOS6gm);
    end else begin
        $fatal(0, "nlev>2 is not supported.");
    end
    I(d_int, s_int) <+ white_noise(4*(VACONSTboltz*(($temperature+noise_dtemp)*Sid)), "id");
    case (nlev)
      0: begin
        flicker_psd = kf*exp(af*ln(((abs(MOS6cd)>1E-38) ? (abs(MOS6cd)) : (1E-38))))/((MOS6l-2*ld)*(MOS6l-2*ld)*MOS6oxideCapFactor);
        flicker_exp = 1;
      end
      1: begin
        flicker_psd = kf*exp(af*ln(((abs(MOS6cd)>1E-38) ? (abs(MOS6cd)) : (1E-38))))/(MOS6w*(MOS6l-2*ld)*MOS6oxideCapFactor);
        flicker_exp = 1;
      end
      2: begin
        flicker_psd = kf*MOS6gm*MOS6gm/(MOS6w*(MOS6l-2*ld)*MOS6oxideCapFactor);
        flicker_exp = af;
      end
    endcase
    I(d_int, s_int) <+ flicker_noise(flicker_psd, flicker_exp, "flicker");

    // Instance output variable computation
    i_d = MOS6cd;
    i_s = -MOS6cd;
    i_s = i_s - (MOS6cbd+MOS6cbs-MOS6cqgb);
    i_s = i_s - (MOS6cqgb+MOS6cqgd+MOS6cqgs);
    i_g = MOS6cqgb+MOS6cqgd+MOS6cqgs;
    i_b = MOS6cbd+MOS6cbs-MOS6cqgb;
    ibs = MOS6cbs;
    ibd = MOS6cbd;
    vgs = MOS6vgs;
    vds = MOS6vds;
    vbs = MOS6vbs;
    vbd = MOS6vbd;
    sourceconductance = MOS6sourceConductance;
    drainconductance = MOS6drainConductance;
    von = MOS6von;
    vdsat = MOS6vdsat;
    sourcevcrit = MOS6sourceVcrit;
    drainvcrit = MOS6drainVcrit;
    gmbs = MOS6gmbs;
    gm = MOS6gm;
    gds = MOS6gds;
    gbd = MOS6gbd;
    gbs = MOS6gbs;
    cgs = 2*MOS6capgs;
    cgs = cgs + (cgso*MOS6w);
    cgd = 2*MOS6capgd;
    cgd = cgd + (cgso*MOS6w);
    cgb = 2*MOS6capgb;
    cgb = cgb + (cgbo*(MOS6l-2*ld));
    c_bd = MOS6capbd;
    c_bs = MOS6capbs;
    cbd0 = MOS6Cbd;
    cbdsw0 = MOS6Cbdsw;
    cbs0 = MOS6Cbs;
    cbssw0 = MOS6Cbssw;
    cqgs = MOS6cqgs;
    cqgd = MOS6cqgd;
    cqgb = MOS6cqgb;
    cqbd = MOS6cqbd;
    cqbs = MOS6cqbs;
    qbd = MOS6qbd;
    qbs = MOS6qbs;

    // Model output variable computation

  end
endmodule
