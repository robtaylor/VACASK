// Model generated by Verilog-A Distiller.
// (c)2025 Arpad Buermen. All rights reserved.
// SPDX-License-Identifier: AGPL-3.0-or-later
// 
// SPICE flavour: ngspice
// Version      : ngspice-45-84-g7f75f09ec
// Origin       : https://sourceforge.net/u/arpadbuermen/ngspice/ci/vadng-pre-46/tree/
// Date         : 2025-11-21 10:56:47 UTC
// Module name  : sp_jfet2
// Model variant: default
// 
// Notes:
//   Parameter m was replaced with builtin Verilog-A parameter $mfactor.
//
//   All parameters and output variables refer to a single parallel instance,
//   even if $mfactor>1.
//
//   Parameter off was removed. Bypassing is not available in Verilog-A. 
//   
//   Device type is set by the type parameter to NJF (1) or PJF (-1). 
//   
//   Output variables id, is, ig, and igd were renamed to i_d, i_s, i_g, 
//   and i_gd due to a conflict between is and model parameter is. To keep 
//   names consistent all current output variables were renamed. 
//   
//   Output variable p was renamed to pwr due to a conflict with a model 
//   parameter. Output variables vtrap and vpave were removed. 
//   
//   Parameters ic, ic-vds, and ic-vgs were removed. Initial conditions 
//   should be set via the simulator's initial conditions mechanism. 
//   
//   Averaging of vgs, vgd, and power dissipation is implemented via 
//   internal nodes vgs_avg, vgd_avg, and p_avg. Setting model parameter 
//   taug to 0 collapses vgs_avg and vgd_avg to ground. Setting model 
//   parameter taud collapses p_avg to ground. 
//   
//   When computing output variables gm and gds the effects of average 
//   vgs, vgs, and power are not taken into account. 
//   
//   G-D and G-S charge is not computed. Output variables qgs and qgd 
//   were removed.
//
//   Full noise model used (appropriate for all noise analyses).
//   OpenVAF may create implicit equations.
//
// CKTcircuit member mapping
//      CKTgmin -> ('gmin', '$simparam("gmin", 1e-12)')
//   CKTnomTemp -> ('tnom', '($simparam("tnom", 27)+273.15)')
//      CKTtemp -> (None, '$temperature')
//
// Source files and copyright information:
//   jfet2/psmodel.c
//      	Parker-Skellern MESFET model
//      	
//     	Copyright (C) 1994, 1995, 1996  Macquarie University                    
//     	All Rights Reserved 
//     	Author: Anthony Parker
//     	Date:	2  Feb 1994  created
//     	        9  Feb 1994  correct NaN problem in strong cut-off region
//     	        20 MAR 1994  corrected capacitance initialization  
//     	        24 MAR 1994  added parameter MVST  
//     	        28 MAR 1994  reorganized declaration scopes 
//                 19 APR 1994  added new parameters: PS_HFETA, PS_HFE1, PS_HFE2,
//                                  PS_HFG1, and PS_HFG2
//                 18 May 1994  corrected 1/0 error when PS_VSUB=0
//                 15 Jul 1994  corrected errors in acload routine
//                 10 Aug 1995  added PS_VSUB to gds += gm*PS_VSUB*mvst*(vgt-vgst*(a..
//     			12 Sep 1995  changed _XXX to PS_XXX to aid portability
//                 13 Sep 1995  change to give arg=1-1/subfac; 
//     			                           if(vst!=0) gds+=gm*PS_VSUB..;
//                                             gm *= arg;
//     			10 Feb 1996  change to names to match MicroSim code.
//     			5  Jul 1996  corrected diode eq (change Gmin*vgs to Gmin*vgd).
//      
//   jfet2/jfet2defs.h
//     Based on jfetdefs.h
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     
//     Modified to add PS model and new parameter definitions ( Anthony E. Parker )
//        Copyright 1994  Macquarie University, Sydney Australia.
//        10 Feb 1994: Added xiwoo, d3 and alpha to JFET2instance
//                     JFET2pave, JFET2vtrap ad JFET2_STATE_COUNT
//                     Changed model to call jfetparm.h, added JFET2za to model struct
//                     Defined JFET2_VTRAP and JFET2_PAVE
//   jfet2/jfet2.c
//     Based on jfet.c 
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     
//     Modified to add PS model and new parameter definitions ( Anthony E. Parker )
//        Copyright 1994  Macquarie University, Sydney Australia.
//        10 Feb 1994:  Parameter definitions called from jfetparm.h
//                      Extra state vectors added to JFET2pTable
//   jfet2/jfet2par.c
//     based on jfetpar.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     
//     Modified to jfet2 for PS model definition ( Anthony E. Parker )
//        Copyright 1994  Macquarie University, Sydney Australia.
//   jfet2/jfet2mpar.c
//     Based on jfetmpar.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     
//     Modified to add PS model and new parameter definitions ( Anthony E. Parker )
//        Copyright 1994  Macquarie University, Sydney Australia.
//        10 Feb 1994: Added call to jfetparm.h
//   jfet2/jfet2ask.c
//     Based on jfetask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Mathew Lew and Thomas L. Quarles
//     
//     Modified to add PS model and new parameter definitions ( Anthony E. Parker )
//        Copyright 1994  Macquarie University, Sydney Australia.
//        10 Feb 1994:   JFET2vtrap and JFET2pave added
//   jfet2/jfet2mask.c
//     Based on jfetmask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Mathew Lew and Thomas L. Quarles
//     
//     Modified to add PS model and new parameter definitions ( Anthony E. Parker )
//        Copyright 1994  Macquarie University, Sydney Australia.
//        10 Feb 1994: Added call to jfetparm.h
//   jfet2/jfet2set.c
//     Based on jfetset.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     
//     Modified to add PS model and new parameter definitions ( Anthony E. Parker )
//        Copyright 1994  Macquarie University, Sydney Australia.
//        10 Feb 1994: Added call to jfetparm.h, used JFET_STATE_COUNT
//   jfet2/jfet2temp.c
//     Base on jfettemp.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     
//     Modified to add PS model and new parameter definitions ( Anthony E. Parker ).
//     See https://ngspice.sourceforge.io/external-documents/models/psfet.pdf
//        Copyright 1994  Macquarie University, Sydney Australia.
//        10 Feb 1994: Call to PSinstanceinit() added
//                     Change gatePotential to phi and used rs and rd for 
//                     sourceResist and drainResist, and fc for depletionCapCoef
//   jfet2/jfet2load.c
//     Based on jfetload.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     
//     Modified to add PS model and new parameter definitions ( Anthony E. Parker )
//        Copyright 1994  Macquarie University, Sydney Australia.
//        10 Feb 1994:  New code added to call psmodel.c routines
//   jfet2/jfet2noi.c
//     based on jfetnoi.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Gary W. Ng
//     
//     Modified to jfet2 for PS model definition ( Anthony E. Parker )
//        Copyright 1994  Macquarie University, Sydney Australia.

`include "constants.vams"
`include "disciplines.vams"

module sp_jfet2(d, g, s);
  inout d, g, s;
  electrical d, g, s, d_int, s_int, vgs_avg, vgd_avg, p_avg;

  // Instance parameters
  (* desc = "Area factor", type = "instance" *) parameter real area = 1;
  (* desc = "Instance temperature", type = "instance" *) parameter real temp = 0;
  (* desc = "Instance temperature difference", type = "instance" *) parameter real dtemp = 0.0;

  // Model parameters
  (* desc = "N-type (1) or P-type (-1)" *) parameter integer type = 1;
  (* desc = "" *) parameter real acgam = 0;
  (* desc = "Flicker Noise Exponent" *) parameter real af = 1;
  (* desc = "Transconductance parameter" *) parameter real beta = 0.0001;
  (* desc = "D-S junction capacitance" *) parameter real cds = 0;
  (* desc = "G-D junction capacitance" *) parameter real cgd = 0;
  (* desc = "G-S junction capacitance" *) parameter real cgs = 0;
  (* desc = "coef of thermal current reduction" *) parameter real delta = 0;
  (* desc = "drain feedback modulation" *) parameter real hfeta = 0;
  (* desc = "" *) parameter real hfe1 = 0;
  (* desc = "" *) parameter real hfe2 = 0;
  (* desc = "" *) parameter real hfg1 = 0;
  (* desc = "" *) parameter real hfg2 = 0;
  (* desc = "modulation index for subtreshold current" *) parameter real mvst = 0;
  (* desc = "saturation potential modulation parameter" *) parameter real mxi = 0;
  (* desc = "Forward bias junction fit parm." *) parameter real fc = 0.5;
  (* desc = "Breakdown current of diode jnc" *) parameter real ibd = 0;
  (* desc = "Gate junction saturation current" *) parameter real is = 1e-14;
  (* desc = "Flicker Noise Coefficient" *) parameter real kf = 0;
  (* desc = "Channel length modulation param." *) parameter real lambda = 0;
  (* desc = "drain feedback parameter" *) parameter real lfgam = 0;
  (* desc = "" *) parameter real lfg1 = 0;
  (* desc = "" *) parameter real lfg2 = 0;
  (* desc = "gate junction ideality factor" *) parameter real n = 1;
  (* desc = "Power law (triode region)" *) parameter real p = 2;
  (* desc = "Gate junction potential" *) parameter real vbi = 1;
  aliasparam pb = vbi;
  (* desc = "Power Law (Saturated region)" *) parameter real q = 2;
  (* desc = "Drain ohmic resistance" *) parameter real rd = 0;
  (* desc = "Source ohmic resistance" *) parameter real rs = 0;
  (* desc = "Thermal relaxation time" *) parameter real taud = 0;
  (* desc = "Drain feedback relaxation time" *) parameter real taug = 0;
  (* desc = "Breakdown potential of diode jnc" *) parameter real vbd = 1;
  (* desc = "version number of PS model" *) parameter real ver = 0;
  (* desc = "Crit Poten subthreshold conductn" *) parameter real vst = 0;
  (* desc = "Threshold voltage" *) parameter real vt0 = 0;
  aliasparam vto = vt0;
  (* desc = "amount of cap. red at pinch-off" *) parameter real xc = 0;
  (* desc = "velocity saturation index" *) parameter real xi = 1000;
  (* desc = "rate of velocity saturation" *) parameter real z = 1;
  (* desc = "high freq drain feedback parm" *) parameter real hfgam = 0;
  (* desc = "parameter measurement temperature" *) parameter real tnom = 0;

  // Instance output variables
  (* desc = "Voltage G-S" *) real vgs;
  (* desc = "Voltage G-D" *) real vgd;
  (* desc = "Transconductance" *) real gm;
  (* desc = "Conductance D-S" *) real gds;
  (* desc = "Conductance G-S" *) real ggs;
  (* desc = "Conductance G-D" *) real ggd;
  (* desc = "Capacitance due to charge storage G-S junction" *) real cqgs;
  (* desc = "Capacitance due to charge storage G-D junction" *) real cqgd;

  // Model output variables
  (* desc = "Drain conductance" *) real gd;
  (* desc = "Source conductance" *) real gs;

  // Instance fields
  integer JFET2mode = 0;
  real JFET2temp = 0;
  real JFET2tSatCur = 0;
  real JFET2tGatePot = 0;
  real JFET2tCGS = 0;
  real JFET2tCGD = 0;
  real JFET2corDepCap = 0;
  real JFET2vcrit = 0;
  real JFET2f1 = 0;
  real JFET2xiwoo = 0;
  real JFET2d3 = 0;
  real JFET2alpha = 0;
  real JFET2dcCurrent = 0;
  integer JFET2tempGiven = 0;

  // Model fields
  real JFET2fc = 0;
  real JFET2vto = 0;
  real JFET2hfgam = 0;
  real JFET2drainConduct = 0;
  real JFET2sourceConduct = 0;
  real JFET2f2 = 0;
  real JFET2f3 = 0;
  real JFET2za = 0;
  real JFET2tnom = 0;
  integer JFET2type = 0;
  integer JFET2tnomGiven = 0;

  // States
  real JFET2vgs = 0;
  real JFET2vgd = 0;
  real JFET2cg = 0;
  real JFET2cd = 0;
  real JFET2cgd = 0;
  real JFET2gm = 0;
  real JFET2gds = 0;
  real JFET2ggs = 0;
  real JFET2ggd = 0;
  real JFET2qgs = 0;
  real JFET2cqgs = 0;
  real JFET2qgd = 0;
  real JFET2cqgd = 0;
  real JFET2qds = 0;
  real JFET2cqds = 0;
  real JFET2unknown = 0;

  // Model parameter access locals

  // Instance parameter access locals

  // Device setup locals

  // Device temperature dependence locals
  real xfc = 0;
  real vt = 0;
  real vtnom = 0;
  real kt = 0;
  real kt1 = 0;
  real arg = 0;
  real arg1 = 0;
  real fact1 = 0;
  real fact2 = 0;
  real egfet = 0;
  real egfet1 = 0;
  real pbfact = 0;
  real pbfact1 = 0;
  real gmanew = 0;
  real gmaold = 0;
  real ratio1 = 0;
  real pbo = 0;
  real cjfact = 0;
  real cjfact1 = 0;
  real woo = 0;

  // Device load locals
  integer limited = 0;
  real capgd = 0;
  real capgs = 0;
  real cd = 0;
  real cdreq = 0;
  real ceq = 0;
  real ceqgd = 0;
  real ceqgs = 0;
  real cg = 0;
  real load_cgd = 0;
  real gdpr = 0;
  real load_gds = 0;
  real geq = 0;
  real load_ggd = 0;
  real load_ggs = 0;
  real load_gm = 0;
  real gspr = 0;
  real vds = 0;
  real load_vgd = 0;
  real load_vgs = 0;
  real idrain = 0;
  real load_arg = 0;
  real load_area = 0;
  real zz = 0;
  real Gmin = 0;
  real Vt = 0;
  real isat = 0;
  real Vbd = 0;
  real load_ibd = 0;
  real inlined_gm = 0;
  real inlined_gds = 0;
  real vdst = 0;
  real vgst = 0;
  real dvgd = 0;
  real dvgs = 0;
  real vgdtrap = 0;
  real vgstrap = 0;
  real eta = 0;
  real gam = 0;
  real load_vto = 0;
  real LFg = 0;
  real LFg1 = 0;
  real LFg2 = 0;
  real HFg = 0;
  real HFg1 = 0;
  real HFg2 = 0;
  real HFe = 0;
  real HFe1 = 0;
  real HFe2 = 0;
  real vgt = 0;
  real subfac = 0;
  real load_mvst = 0;
  real load_vst = 0;
  real mQ = 0;
  real PmQ = 0;
  real dvpd_dvdst = 0;
  real vdp = 0;
  real za = 0;
  real load_mxi = 0;
  real vsatFac = 0;
  real vsat = 0;
  real aa = 0;
  real a_aa = 0;
  real rpt = 0;
  real a_rpt = 0;
  real vdt = 0;
  real dvdt_dvdp = 0;
  real dvdt_dvgt = 0;
  real load_lambda = 0;
  real load_beta = 0;
  real pfac = 0;
  real pAverage = 0;
  real load_delta = 0;
  real capds = 0;
  real czgs = 0;
  real czgd = 0;
  real load1_vto = 0;
  real alpha = 0;
  real load_xc = 0;
  real vmax = 0;
  real phib = 0;
  real gac = 0;
  real cgsna = 0;
  real cgdna = 0;
  real vgsin = 0;
  real vgdin = 0;
  real idrain_unscaled = 0;
  real vcnorm = 0;
  real psids_retval = 0;

  // Device noise locals

  // Global constants
  real CONSTroot2 = sqrt(2.0);
  real CONSTvt0 = 1.38064852e-23*(27+273.15)/1.6021766208e-19;
  real CONSTKoverQ = 1.38064852e-23/1.6021766208e-19;
  real CONSTe = exp(1.0);
  real VACONSTcharge = 1.6021766208e-19;
  real VACONSTboltz = 1.38064852e-23;
  real VACONST_tnom = ($simparam("tnom", 27)+273.15);

  // Evaluation constants
  real lc_gmin = 0;

  // Translated function definitions
  analog function real qgg;
    input vgs, vgd, gamma, pb, alpha, vto, vmax, xc, cgso, cgdo;
    inout cgs, cgd;
    real vgs;
    real vgd;
    real gamma;
    real pb;
    real alpha;
    real vto;
    real vmax;
    real xc;
    real cgso;
    real cgdo;
    real cgs;
    real cgd;
    real qrt;
    real ext;
    real Cgso;
    real cpm;
    real cplus;
    real cminus;
    real vds;
    real d1_xc;
    real vert;
    real veff;
    real vnr;
    real vnrt;
    real vnew;
    real vx;
    real par;
    begin
      vds = vgs-vgd;
      d1_xc = 1-xc;
      vert = sqrt(vds*vds+alpha);
      veff = 0.5*(vgs+vgd+vert)+gamma*vds;
      vnr = d1_xc*(veff-vto);
      vnrt = sqrt(vnr*vnr+0.04);
      vnew = veff+0.5*(vnrt-vnr);
      if (vnew<vmax) begin
        ext = 0;
        qrt = sqrt(1-vnew/pb);
        Cgso = 0.5*cgso/qrt*(1+xc+d1_xc*vnr/vnrt);
      end else begin
        vx = 0.5*(vnew-vmax);
        par = 1+vx/(pb-vmax);
        qrt = sqrt(1-vmax/pb);
        ext = vx*(1+par)/qrt;
        Cgso = 0.5*cgso/qrt*(1+xc+d1_xc*vnr/vnrt)*par;
      end
      cpm = vds/vert;
      cplus = 0.5*(1+cpm);
      cminus = cplus-cpm;
      cgs = Cgso*(cplus+gamma)+cgdo*(cminus+gamma);
      cgd = Cgso*(cminus-gamma)+cgdo*(cplus-gamma);
      qgg = cgso*((pb+pb)*(1-qrt)+ext)+cgdo*(veff-vert);
    end
  endfunction

  // Verbatim analog functions
  analog function integer initialize_limiting;
    integer il;
    begin
      il = $simparam("iniLim", -1);
      if (il<0) begin
        // iniLim not available, use heuristics
        initialize_limiting = 
          $simparam("iteration", 10)==1 && 
          (analysis("dc") || analysis("static")) && 
          analysis("nodeset");
      end else begin
        initialize_limiting = il;
      end
    end
  endfunction

  analog function real DEVlimitOldGet;
    input vnew, vold;
    real vnew, vold, result;
    begin
      DEVlimitOldGet = vold;
    end
  endfunction

  analog function real DEVlimitNewSet;
    input vnew, vold, new_value, limited;
    real vnew, vold, new_value;
    integer limited;
    begin
      DEVlimitNewSet = new_value;
      if (limited) begin
        $discontinuity(-1);
      end
    end
  endfunction

  analog function real DEVpnjlim;
    input vnew, vold, vt, vcrit;
    inout limiting_applied;
    real vnew, vold, vt, vcrit, limited, arg;
    integer limiting_applied;
    
    begin
      limited = vnew;
      if ((vnew > vcrit) && (abs(vnew - vold) > (vt + vt))) begin
        // Positive vnew above vcrit, change greater than 2*vt
        if(vold > 0) begin
          arg = (vnew - vold) / vt;
          if(arg > 0) begin
            limited = vold + vt * ln(1+arg);
            limiting_applied = 1;
          end else begin
            limited = vold - vt * ln(1-arg);
            limiting_applied = 1;
          end
        end else begin
          limited = vt *ln(vnew/vt);
          limiting_applied = 1;
        end
      end else if (vnew<0) begin
        // Negative vnew, use ngspice limiting
        if (vold > 0) begin
          arg = -1*vold-1; 
        end else begin
          arg = 2*vold-1;
        end
        if (vnew<arg) begin
          limited = arg;
          limiting_applied = 1;
        end
      end 
      DEVpnjlim = limited;
    end
  endfunction

  analog function real DEVfetlim;
    input vnew, vold, vto;
    inout limiting_applied;
    real vnew, vold, vto, vlimited;
    real vtsthi, vtstlo, vtox, delv, vtemp;
    integer limiting_applied;  
    begin
      vlimited = vnew;
      vtsthi = abs(2*(vold-vto))+2;
      // vtstlo = vtsthi/2 +2;
      vtstlo = abs(vold-vto)+1;
      vtox = vto + 3.5;
      delv = vnew-vold;
      
      if (vold >= vto) begin
        if(vold >= vtox) begin
          if(delv <= 0) begin
            /* going off */
            if(vlimited >= vtox) begin
                if(-delv > vtstlo) begin
                vlimited =  vold - vtstlo;
                end
            end else begin
              vlimited = max(vnew,vto+2);
            end
          end else begin
            /* staying on */
            if(delv >= vtsthi) begin
              vlimited = vold + vtsthi;
            end
          end
        end else begin
          /* middle region */
          if(delv <= 0) begin
            /* decreasing */
            vlimited = max(vnew,vto-0.5);
          end else begin
            /* increasing */
            vlimited = min(vnew,vto+4);
          end
        end
      end else begin
        /* off */
        if(delv <= 0) begin
          if(-delv >vtsthi) begin
            vlimited = vold - vtsthi;
          end
        end else begin
          vtemp = vto + 0.5;
          if(vnew <= vtemp) begin
            if(delv > vtstlo) begin
              vlimited = vold + vtstlo;
            end
          end else begin
            vlimited = vtemp;
          end
        end
      end
      if (vlimited!=vnew) begin
        limiting_applied = 1;
      end
      DEVfetlim = vlimited;
    end
  endfunction

  // Analog block
  analog begin

    // Instance field assignments
    if ($param_given(temp)) begin
      JFET2temp = temp+273.15;
      JFET2tempGiven = 1;
    end

    // Model field assignments
    JFET2type = type;
    if ($param_given(fc)) begin
      JFET2fc = fc;
    end
    if ($param_given(vt0)) begin
      JFET2vto = vt0;
    end
    if ($param_given(hfgam)) begin
      JFET2hfgam = hfgam;
    end
    if ($param_given(tnom)) begin
      JFET2tnomGiven = 1;
      JFET2tnom = tnom+273.15;
    end

    // Evaluation constants
    lc_gmin = $simparam("gmin", 1e-12);

    // Tag: setup, function: JFET2setup
    if (JFET2type!=1&&JFET2type!=-1) begin
      JFET2type = 1;
    end
    if (!$param_given(fc)) begin
      JFET2fc = 0.5;
    end
    if (!$param_given(vt0)) begin
      JFET2vto = -2;
    end
    if (!$param_given(hfgam)) begin
      JFET2hfgam = lfgam;
    end
    if (!(rs!=0)) begin
      V(s_int, s) <+ 0;
    end
    if (!(rd!=0)) begin
      V(d_int, d) <+ 0;
    end
    if (taug==0) begin
      V(vgs_avg) <+ 0;
      V(vgd_avg) <+ 0;
    end
    if (taud==0) begin
      V(p_avg) <+ 0;
    end

    // Tag: temp, function: JFET2temp
    if (!JFET2tnomGiven) begin
      JFET2tnom = VACONST_tnom;
    end
    vtnom = CONSTKoverQ*JFET2tnom;
    fact1 = JFET2tnom/(27.0+273.15);
    kt1 = 1.38064852e-23*JFET2tnom;
    egfet1 = 1.16-7.02e-4*JFET2tnom*JFET2tnom/(JFET2tnom+1108);
    arg1 = -egfet1/(kt1+kt1)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact1 = -2*vtnom*(1.5*ln(fact1)+1.6021766208e-19*arg1);
    pbo = (vbi-pbfact1)/fact1;
    gmaold = (vbi-pbo)/pbo;
    cjfact = 1/(1+0.5*(4e-4*(JFET2tnom-(27.0+273.15))-gmaold));
    if (rd!=0) begin
      JFET2drainConduct = 1/rd;
    end else begin
      JFET2drainConduct = 0;
    end
    if (rs!=0) begin
      JFET2sourceConduct = 1/rs;
    end else begin
      JFET2sourceConduct = 0;
    end
    if (JFET2fc>0.95) begin
      $warning("Depletion cap. coefficient too large, limited to .95");
      JFET2fc = 0.95;
    end
    xfc = ln(1-JFET2fc);
    JFET2f2 = exp((1+0.5)*xfc);
    JFET2f3 = 1-JFET2fc*(1+0.5);
    if (!JFET2tempGiven) begin
      JFET2temp = $temperature+dtemp;
    end
    vt = JFET2temp*CONSTKoverQ;
    fact2 = JFET2temp/(27.0+273.15);
    ratio1 = JFET2temp/JFET2tnom-1;
    JFET2tSatCur = is*exp(ratio1*1.11/vt);
    JFET2tCGS = cgs*cjfact;
    JFET2tCGD = cgd*cjfact;
    kt = 1.38064852e-23*JFET2temp;
    egfet = 1.16-7.02e-4*JFET2temp*JFET2temp/(JFET2temp+1108);
    arg = -egfet/(kt+kt)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact = -2*vt*(1.5*ln(fact2)+1.6021766208e-19*arg);
    JFET2tGatePot = fact2*pbo+pbfact;
    gmanew = (JFET2tGatePot-pbo)/pbo;
    cjfact1 = 1+0.5*(4e-4*(JFET2temp-(27.0+273.15))-gmanew);
    JFET2tCGS = JFET2tCGS * (cjfact1);
    JFET2tCGD = JFET2tCGD * (cjfact1);
    JFET2corDepCap = JFET2fc*JFET2tGatePot;
    JFET2f1 = JFET2tGatePot*(1-exp((1-0.5)*xfc))/(1-0.5);
    JFET2vcrit = vt*ln(vt/(CONSTroot2*JFET2tSatCur));
    // inlined: PSinstanceinit(model, here)
    woo = JFET2tGatePot-JFET2vto;
    JFET2xiwoo = xi*woo;
    JFET2za = sqrt(1+z)/2;
    JFET2alpha = JFET2xiwoo*JFET2xiwoo/(xi+1)/(xi+1)/4;
    JFET2d3 = p/q/pow(woo, p-q);
    // end of inlined: PSinstanceinit(model, here)

    // Tag: load, function: JFET2load
    gdpr = JFET2drainConduct*area;
    gspr = JFET2sourceConduct*area;
    limited = 0;
    JFET2vgs = JFET2type * $limit(V(g, s_int), DEVlimitOldGet);
    JFET2vgd = JFET2type * $limit(V(g, d_int), DEVlimitOldGet);
    load_vgs = JFET2type*V(g, s_int);
    load_vgd = JFET2type*V(g, d_int);
    load_vgs = DEVpnjlim(load_vgs, JFET2vgs, JFET2temp*CONSTKoverQ, JFET2vcrit, limited);
    load_vgd = DEVpnjlim(load_vgd, JFET2vgd, JFET2temp*CONSTKoverQ, JFET2vcrit, limited);
    load_vgs = DEVfetlim(load_vgs, JFET2vgs, JFET2vto, limited);
    load_vgd = DEVfetlim(load_vgd, JFET2vgd, JFET2vto, limited);
    if (initialize_limiting()) begin
        load_vgs = -1;
        load_vgd = -1;
    end
    load_vgs = JFET2type * $limit(V(g, s_int), DEVlimitNewSet, JFET2type * load_vgs, limited);
    load_vgd = JFET2type * $limit(V(g, d_int), DEVlimitNewSet, JFET2type * load_vgd, limited);
    vds = load_vgs-load_vgd;
    if (vds<0) begin
      vgsin = load_vgd;
      vgdin = load_vgs;
    end else begin
      vgsin = load_vgs;
      vgdin = load_vgd;
    end
    // inlined: PSids(ckt, model, here, vgsin, vgdin, cg, cgd, ggs, ggd, gm, gds) -> psids_retval
    load_area = area;
    Gmin = lc_gmin;
    Vt = JFET2temp*CONSTKoverQ*n;
    isat = JFET2tSatCur*load_area;
    load_arg = vgsin/Vt;
    if (load_arg>-10.0) begin
      if (load_arg<40.0) begin
        zz = isat*exp(load_arg);
        load_ggs = zz/Vt+Gmin;
        cg = zz-isat+Gmin*vgsin;
      end else begin
        zz = isat*2.353852668370199842e17;
        load_ggs = zz/Vt+Gmin;
        cg = zz*(load_arg-40.0+1)-isat+Gmin*vgsin;
      end
    end else begin
      load_ggs = Gmin;
      cg = -isat+Gmin*vgsin;
    end
    load_arg = vgdin/Vt;
    if (load_arg>-10.0) begin
      if (load_arg<40.0) begin
        zz = isat*exp(load_arg);
        load_ggd = zz/Vt+Gmin;
        load_cgd = zz-isat+Gmin*vgdin;
      end else begin
        zz = isat*2.353852668370199842e17;
        load_ggd = zz/Vt+Gmin;
        load_cgd = zz*(load_arg-40.0+1)-isat+Gmin*vgdin;
      end
    end else begin
      load_ggd = Gmin;
      load_cgd = -isat+Gmin*vgdin;
    end
    Vbd = vbd;
    load_ibd = ibd*load_area;
    load_arg = -vgsin/Vbd;
    if (load_arg>-10.0) begin
      if (load_arg<40.0) begin
        zz = load_ibd*exp(load_arg);
        load_ggs = load_ggs + (zz/Vbd);
        cg = cg - (zz-load_ibd);
      end else begin
        zz = load_ibd*2.353852668370199842e17;
        load_ggs = load_ggs + (zz/Vbd);
        cg = cg - (zz*(load_arg-40.0+1)-load_ibd);
      end
    end else begin
      cg = cg + (load_ibd);
    end
    load_arg = -vgdin/Vbd;
    if (load_arg>-10.0) begin
      if (load_arg<40.0) begin
        zz = load_ibd*exp(load_arg);
        load_ggd = load_ggd + (zz/Vbd);
        load_cgd = load_cgd - (zz-load_ibd);
      end else begin
        zz = load_ibd*2.353852668370199842e17;
        load_ggd = load_ggd + (zz/Vbd);
        load_cgd = load_cgd - (zz*(load_arg-40.0+1)-load_ibd);
      end
    end else begin
      load_cgd = load_cgd + (load_ibd);
    end
    vdst = vgsin-vgdin;
    load_vto = JFET2vto;
    LFg = lfgam;
    LFg1 = lfg1;
    LFg2 = lfg2;
    HFg = JFET2hfgam;
    HFg1 = hfg1;
    HFg2 = hfg2;
    HFe = hfeta;
    HFe1 = hfe1;
    HFe2 = hfe2;
    if (taug==0) begin
      vgdtrap = vgdin;
      vgstrap = vgsin;
    end else begin
      vgdtrap = V(vgd_avg);
      vgstrap = V(vgs_avg);
    end
    vgst = vgsin-load_vto;
    vgst = vgst - ((LFg-LFg1*vgstrap+LFg2*vgdtrap)*vgdtrap);
    eta = HFe-HFe1*vgdtrap+HFe2*vgstrap;
    dvgs = vgstrap-vgsin;
    vgst = vgst + (eta*dvgs);
    gam = HFg-HFg1*vgstrap+HFg2*vgdtrap;
    dvgd = vgdtrap-vgdin;
    vgst = vgst + (gam*dvgd);
    load_mvst = mvst;
    load_vst = vst*(1+load_mvst*vdst);
    if (vgst>-10.0*load_vst) begin
      load_arg = 40.0*load_vst;
      if (vgst>load_arg) begin
        subfac = 2.353852668370199842e17+1;
        vgt = 2.353852668370199842e17/subfac*(vgst-load_arg)+load_arg;
      end else begin
        subfac = 1+exp(vgst/load_vst);
        vgt = load_vst*ln(subfac);
      end
      mQ = q;
      PmQ = p-mQ;
      dvpd_dvdst = JFET2d3*pow(vgt, PmQ);
      vdp = vdst*dvpd_dvdst;
      za = JFET2za;
      load_mxi = mxi;
      vsatFac = vgt/(load_mxi*vgt+JFET2xiwoo);
      vsat = vgt/(1+vsatFac);
      aa = za*vdp+vsat/2.0;
      a_aa = aa-vsat;
      load_arg = vsat*vsat*z/4.0;
      rpt = sqrt(aa*aa+load_arg);
      a_rpt = sqrt(a_aa*a_aa+load_arg);
      vdt = rpt-a_rpt;
      dvdt_dvdp = za*(aa/rpt-a_aa/a_rpt);
      dvdt_dvgt = (vdt-vdp*dvdt_dvdp)*(1+load_mxi*vsatFac*vsatFac)/(1+vsatFac)/vgt;
      inlined_gds = pow(vgt-vdt, mQ-1);
      inlined_gm = pow(vgt, mQ-1)-inlined_gds;
      idrain = vdt*inlined_gds+vgt*inlined_gm;
      inlined_gds = inlined_gds * (mQ);
      inlined_gm = inlined_gm * (mQ);
      inlined_gm = inlined_gm + (inlined_gds*dvdt_dvgt);
      inlined_gds = inlined_gds * (dvdt_dvdp);
      inlined_gm = inlined_gm + (inlined_gds*PmQ*vdp/vgt);
      inlined_gds = inlined_gds * (dvpd_dvdst);
      load_arg = 1-1/subfac;
      if (load_vst!=0) begin
        inlined_gds = inlined_gds + (inlined_gm*vst*load_mvst*(vgt-vgst*load_arg)/load_vst);
      end
      inlined_gm = inlined_gm * (load_arg);
    end else begin
      inlined_gds = 0.0e0;
      inlined_gm = inlined_gds;
      idrain = inlined_gm;
    end
    load_arg = HFe1*dvgs-HFg2*dvgd+2*LFg2*vgdtrap-LFg1*vgstrap+LFg;
    inlined_gds = inlined_gds + (inlined_gm*load_arg);
    inlined_gm = inlined_gm * (1+(HFe2*dvgs-HFg1*dvgd+LFg1*vgdtrap)-load_arg);
    load_lambda = lambda;
    load_beta = beta*load_area;
    load_arg = load_beta*(1+load_lambda*vdst);
    inlined_gm = inlined_gm * (load_arg);
    inlined_gds = load_beta*load_lambda*idrain+inlined_gds*load_arg;
    idrain = idrain * (load_arg);
    load_delta = delta/load_area;
    idrain_unscaled = idrain;
    if (taud==0) begin
      pAverage = vdst*idrain_unscaled;
    end else begin
      pAverage = V(p_avg);
    end
    pfac = 1+pAverage*load_delta;
    idrain = idrain / (pfac);
    load_arg = 1/pfac/pfac;
    load_gm = inlined_gm*load_arg;
    load_gds = inlined_gds*load_arg-load_delta*idrain*idrain;
    psids_retval = idrain;
    // end of inlined: PSids(ckt, model, here, vgsin, vgdin, cg, cgd, ggs, ggd, gm, gds) -> psids_retval
    cd = psids_retval;
    if (vds<0.0) begin
      cd = -cd;
      load_gds = load_gds + (load_gm);
      load_gm = -load_gm;
    end
    cg = cg+load_cgd;
    cd = cd-load_cgd;
    vcnorm = cgs;
    if (vcnorm<=0) begin
        vcnorm = cgd;
    end
    if (vcnorm<=0) begin
        vcnorm = 1;
    end
    capds = cds*area;
    // inlined: PScharge(ckt, model, here, vgs, vgd, capgs, capgd)
    czgs = JFET2tCGS*area;
    czgd = JFET2tCGD*area;
    load1_vto = JFET2vto;
    alpha = JFET2alpha;
    load_xc = xc;
    vmax = JFET2corDepCap;
    phib = JFET2tGatePot;
    gac = acgam;
    qgg(load_vgs, load_vgd, gac, phib, alpha, load1_vto, vmax, load_xc, czgs, czgd, cgsna, cgdna);
    capgs = cgsna;
    capgd = cgdna;
    // end of inlined: PScharge(ckt, model, here, vgs, vgd, capgs, capgd)
    JFET2qds = capds*vds;
    geq = 0;
    ceq = capgs*(ddt(vcnorm*load_vgs)/vcnorm);
    JFET2cqgs = ceq;
    load_ggs = load_ggs+geq;
    cg = cg+JFET2cqgs;
    geq = 0;
    ceq = capgd*(ddt(vcnorm*load_vgd)/vcnorm);
    JFET2cqgd = ceq;
    load_ggd = load_ggd+geq;
    cg = cg+JFET2cqgd;
    JFET2dcCurrent = cd;
    cd = cd-JFET2cqgd;
    load_cgd = load_cgd+JFET2cqgd;
    geq = 0;
    JFET2cqds = ddt(JFET2qds);
    ceq = JFET2cqds;
    cd = cd+JFET2cqds;
    JFET2vgs = load_vgs;
    JFET2vgd = load_vgd;
    JFET2cg = cg;
    JFET2cd = cd;
    JFET2cgd = load_cgd;
    JFET2gm = load_gm;
    JFET2gds = load_gds;
    JFET2ggs = load_ggs;
    JFET2ggd = load_ggd;
    ceqgd = JFET2type*load_cgd;
    ceqgs = JFET2type*(cg-load_cgd);
    cdreq = JFET2type*(cd+load_cgd);
    
    // Residuals
    I(d) <+ gdpr*V(d, d_int);
    I(g) <+ -(-ceqgs-ceqgd);
    I(s) <+ gspr*V(s, s_int);
    I(s_int) <+ gspr*V(s_int, s)+-(cdreq+ceqgs);
    I(d_int) <+ gdpr*V(d_int, d)+-(-cdreq+ceqgd);
    //
    // Averaging of vgs, vds, and power
    //
    // vgsin and vgdin account for vds polarity, computed before PSids() is called
    I(vgs_avg) <+ V(vgs_avg) + taug * ddt(V(vgs_avg)) - vgsin;
    I(vgd_avg) <+ V(vgd_avg) + taug * ddt(V(vgd_avg)) - vgdin;
    // Use idrain_unscaled (before idrain is scaled with average power)
    I(p_avg) <+ V(p_avg) + taud * ddt(V(p_avg)) - vdst*idrain_unscaled;
    //
    // End of averaging
    //

    // Tag: noise, function: JFET2noise
    I(d_int, d) <+ white_noise(4*(VACONSTboltz*($temperature*(JFET2drainConduct*area))), "rd");
    I(s_int, s) <+ white_noise(4*(VACONSTboltz*($temperature*(JFET2sourceConduct*area))), "rs");
    I(d_int, s_int) <+ white_noise(4*(VACONSTboltz*($temperature*(2.0/3.0*abs(JFET2gm)))), "id");
    I(d_int, s_int) <+ flicker_noise(kf*exp(af*ln(((abs(JFET2cd)>1E-38) ? (abs(JFET2cd)) : (1E-38)))), 1, "flicker");

    // Instance output variable computation
    vgs = JFET2vgs;
    vgd = JFET2vgd;
    gm = JFET2gm;
    gds = JFET2gds;
    ggs = JFET2ggs;
    ggd = JFET2ggd;
    cqgs = capgs;
    cqgd = capgd;

    // Model output variable computation

  end
endmodule
