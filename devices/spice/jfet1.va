// Model generated by Verilog-A Distiller.
// (c)2025 Arpad Buermen. All rights reserved.
// SPDX-License-Identifier: AGPL-3.0-or-later
// 
// SPICE flavour: ngspice
// Version      : ngspice-45-84-g7f75f09ec
// Origin       : https://sourceforge.net/u/arpadbuermen/ngspice/ci/vadng-pre-46/tree/
// Date         : 2025-11-21 10:56:42 UTC
// Module name  : sp_jfet1
// Model variant: default
// 
// Notes:
//   Parameter m was replaced with builtin Verilog-A parameter $mfactor.
//
//   All parameters and output variables refer to a single parallel instance,
//   even if $mfactor>1.
//
//   Parameter off was removed. Bypassing is not available in Verilog-A. 
//   
//   Device type is set by the type parameter to NJF (1) or PJF (-1). 
//   
//   Output variables id, is, ig, and igd were renamed to i_d, i_s, i_g, 
//   and i_gd due to a conflict between is and model parameter is. To keep 
//   names consistent all current output variables were renamed. 
//   
//   Parameters ic, ic-vds, and ic-vgs were removed. Initial conditions 
//   should be set via the simulator's initial conditions mechanism.
//
//   Full noise model used (appropriate for all noise analyses).
//   OpenVAF may create implicit equations.
//
// CKTcircuit member mapping
//      CKTgmin -> ('gmin', '$simparam("gmin", 1e-12)')
//   CKTnomTemp -> ('tnom', '($simparam("tnom", 27)+273.15)')
//      CKTtemp -> (None, '$temperature')
//
// Source files and copyright information:
//   jfet/jfetdefs.h
//   jfet/jfet.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Sydney University mods Copyright(c) 1989 Anthony E. Parker, David J. Skellern
//     	Laboratory for Communication Science Engineering
//     	Sydney University Department of Electrical Engineering, Australia
//   jfet/jfetpar.c
//   jfet/jfetmpar.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//   jfet/jfetask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Mathew Lew and Thomas L. Quarles
//   jfet/jfetmask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Mathew Lew and Thomas L. Quarles
//     Sydney University mods Copyright(c) 1989 Anthony E. Parker, David J. Skellern
//             Laboratory for Communication Science Engineering
//             Sydney University Department of Electrical Engineering, Australia
//   jfet/jfetset.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//     Sydney University mods Copyright(c) 1989 Anthony E. Parker, David J. Skellern
//             Laboratory for Communication Science Engineering
//             Sydney University Department of Electrical Engineering, Australia
//   jfet/jfettemp.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Sydney University mods Copyright(c) 1989 Anthony E. Parker, David J. Skellern
//             Laboratory for Communication Science Engineering
//             Sydney University Department of Electrical Engineering, Australia
//   jfet/jfetload.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//     Sydney University mods Copyright(c) 1989 Anthony E. Parker, David J. Skellern
//             Laboratory for Communication Science Engineering
//             Sydney University Department of Electrical Engineering, Australia
//   jfet/jfetnoi.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Gary W. Ng

`include "constants.vams"
`include "disciplines.vams"

module sp_jfet1(d, g, s);
  inout d, g, s;
  electrical d, g, s, d_int, s_int;

  // Instance parameters
  (* desc = "Area factor", type = "instance" *) parameter real area = 1;
  (* desc = "Instance temperature", type = "instance" *) parameter real temp = 0;
  (* desc = "Instance temperature difference", type = "instance" *) parameter real dtemp = 0.0;

  // Model parameters
  (* desc = "N-type (1) or P-type (-1)" *) parameter integer type = 1;
  (* desc = "Threshold voltage" *) parameter real vt0 = 0;
  aliasparam vto = vt0;
  (* desc = "Transconductance parameter" *) parameter real beta = 0.0001;
  (* desc = "Channel length modulation param." *) parameter real lambda = 0;
  (* desc = "Drain ohmic resistance" *) parameter real rd = 0;
  (* desc = "Source ohmic resistance" *) parameter real rs = 0;
  (* desc = "G-S junction capactance" *) parameter real cgs = 0;
  (* desc = "G-D junction cap" *) parameter real cgd = 0;
  (* desc = "Gate junction potential" *) parameter real pb = 1;
  (* desc = "Gate junction saturation current" *) parameter real is = 1e-14;
  (* desc = "Emission Coefficient for gate-drain and gate-source diodes" *) parameter real n = 1;
  (* desc = "Forward bias junction fit parm." *) parameter real fc = 0.5;
  (* desc = "Doping tail parameter" *) parameter real b = 1.0;
  (* desc = "parameter measurement temperature" *) parameter real tnom = 0;
  (* desc = "Threshold voltage temperature coefficient" *) parameter real tcv = 0.0;
  (* desc = "Threshold voltage temperature coefficient alternative" *) parameter real vtotc = 0.0;
  (* desc = "Mobility temperature exponent" *) parameter real bex = 0.0;
  (* desc = "Mobility temperature exponent alternative" *) parameter real betatce = 0.0;
  (* desc = "Gate junction saturation current temperature exponent" *) parameter real xti = 3.0;
  (* desc = "Bandgap voltage" *) parameter real eg = 1.11;
  (* desc = "Flicker Noise Coefficient" *) parameter real kf = 0;
  (* desc = "Flicker Noise Exponent" *) parameter real af = 1;
  (* desc = "Noise equation selector" *) parameter integer nlev = 2;
  (* desc = "Channel noise coefficient" *) parameter real gdsnoi = 1.0;

  // Instance output variables
  (* desc = "Voltage G-S" *) real vgs;
  (* desc = "Voltage G-D" *) real vgd;
  (* desc = "Transconductance" *) real gm;
  (* desc = "Conductance D-S" *) real gds;
  (* desc = "Conductance G-S" *) real ggs;
  (* desc = "Conductance G-D" *) real ggd;
  (* desc = "Charge storage G-S junction" *) real qgs;
  (* desc = "Charge storage G-D junction" *) real qgd;
  (* desc = "Capacitance due to charge storage G-S junction" *) real cqgs;
  (* desc = "Capacitance due to charge storage G-D junction" *) real cqgd;

  // Model output variables
  (* desc = "Drain conductance" *) real gd;
  (* desc = "Source conductance" *) real gs;

  // Instance fields
  integer JFETmode = 0;
  real JFETtemp = 0;
  real JFETtSatCur = 0;
  real JFETtGatePot = 0;
  real JFETtCGS = 0;
  real JFETtCGD = 0;
  real JFETcorDepCap = 0;
  real JFETvcrit = 0;
  real JFETf1 = 0;
  real JFETtThreshold = 0;
  real JFETtBeta = 0;
  real JFETdcCurrent = 0;
  integer JFETtempGiven = 0;

  // Model fields
  real JFETthreshold = 0;
  real JFETdepletionCapCoeff = 0;
  real JFETdrainConduct = 0;
  real JFETsourceConduct = 0;
  real JFETf2 = 0;
  real JFETf3 = 0;
  real JFETbFac = 0;
  real JFETtnom = 0;
  integer JFETtype = 0;
  integer JFETtnomGiven = 0;

  // States
  real JFETvgs = 0;
  real JFETvgd = 0;
  real JFETcg = 0;
  real JFETcd = 0;
  real JFETcgd = 0;
  real JFETgm = 0;
  real JFETgds = 0;
  real JFETggs = 0;
  real JFETggd = 0;
  real JFETqgs = 0;
  real JFETcqgs = 0;
  real JFETqgd = 0;
  real JFETcqgd = 0;

  // Model parameter access locals

  // Instance parameter access locals

  // Device setup locals

  // Device temperature dependence locals
  real xfc = 0;
  real vt = 0;
  real vtn = 0;
  real vtnom = 0;
  real kt = 0;
  real kt1 = 0;
  real arg = 0;
  real arg1 = 0;
  real fact1 = 0;
  real fact2 = 0;
  real egfet = 0;
  real egfet1 = 0;
  real pbfact = 0;
  real pbfact1 = 0;
  real gmanew = 0;
  real gmaold = 0;
  real ratio1 = 0;
  real pbo = 0;
  real cjfact = 0;
  real cjfact1 = 0;

  // Device load locals
  integer limited = 0;
  real load_beta = 0;
  real betap = 0;
  real capgd = 0;
  real capgs = 0;
  real cd = 0;
  real cdrain = 0;
  real cdreq = 0;
  real ceq = 0;
  real ceqgd = 0;
  real ceqgs = 0;
  real cg = 0;
  real load_cgd = 0;
  real csat = 0;
  real czgd = 0;
  real czgdf2 = 0;
  real czgs = 0;
  real czgsf2 = 0;
  real evgd = 0;
  real evgs = 0;
  real fcpb2 = 0;
  real gdpr = 0;
  real load_gds = 0;
  real geq = 0;
  real load_ggd = 0;
  real load_ggs = 0;
  real load_gm = 0;
  real gspr = 0;
  real sarg = 0;
  real twop = 0;
  real vds = 0;
  real load_vgd = 0;
  real vgdt = 0;
  real load_vgs = 0;
  real vgst = 0;
  real load_vto = 0;
  real apart = 0;
  real cpart = 0;
  real Bfac = 0;
  real load_arg = 0;
  real vt_temp = 0;

  // Device noise locals
  real noise_vgs = 0;
  real noise_vds = 0;
  real noise_vgst = 0;
  real alpha = 0;
  real noise_beta = 0;
  real noise_dtemp = 0;
  real id_psd = 0;

  // Global constants
  real CONSTroot2 = sqrt(2.0);
  real CONSTvt0 = 1.38064852e-23*(27+273.15)/1.6021766208e-19;
  real CONSTKoverQ = 1.38064852e-23/1.6021766208e-19;
  real CONSTe = exp(1.0);
  real VACONSTcharge = 1.6021766208e-19;
  real VACONSTboltz = 1.38064852e-23;
  real VACONST_tnom = ($simparam("tnom", 27)+273.15);

  // Evaluation constants
  real lc_gmin = 0;

  // Translated function definitions

  // Verbatim analog functions
  analog function integer initialize_limiting;
    integer il;
    begin
      il = $simparam("iniLim", -1);
      if (il<0) begin
        // iniLim not available, use heuristics
        initialize_limiting = 
          $simparam("iteration", 10)==1 && 
          (analysis("dc") || analysis("static")) && 
          analysis("nodeset");
      end else begin
        initialize_limiting = il;
      end
    end
  endfunction

  analog function real DEVlimitOldGet;
    input vnew, vold;
    real vnew, vold, result;
    begin
      DEVlimitOldGet = vold;
    end
  endfunction

  analog function real DEVlimitNewSet;
    input vnew, vold, new_value, limited;
    real vnew, vold, new_value;
    integer limited;
    begin
      DEVlimitNewSet = new_value;
      if (limited) begin
        $discontinuity(-1);
      end
    end
  endfunction

  analog function real DEVpnjlim;
    input vnew, vold, vt, vcrit;
    inout limiting_applied;
    real vnew, vold, vt, vcrit, limited, arg;
    integer limiting_applied;
    
    begin
      limited = vnew;
      if ((vnew > vcrit) && (abs(vnew - vold) > (vt + vt))) begin
        // Positive vnew above vcrit, change greater than 2*vt
        if(vold > 0) begin
          arg = (vnew - vold) / vt;
          if(arg > 0) begin
            limited = vold + vt * ln(1+arg);
            limiting_applied = 1;
          end else begin
            limited = vold - vt * ln(1-arg);
            limiting_applied = 1;
          end
        end else begin
          limited = vt *ln(vnew/vt);
          limiting_applied = 1;
        end
      end else if (vnew<0) begin
        // Negative vnew, use ngspice limiting
        if (vold > 0) begin
          arg = -1*vold-1; 
        end else begin
          arg = 2*vold-1;
        end
        if (vnew<arg) begin
          limited = arg;
          limiting_applied = 1;
        end
      end 
      DEVpnjlim = limited;
    end
  endfunction

  analog function real DEVfetlim;
    input vnew, vold, vto;
    inout limiting_applied;
    real vnew, vold, vto, vlimited;
    real vtsthi, vtstlo, vtox, delv, vtemp;
    integer limiting_applied;  
    begin
      vlimited = vnew;
      vtsthi = abs(2*(vold-vto))+2;
      // vtstlo = vtsthi/2 +2;
      vtstlo = abs(vold-vto)+1;
      vtox = vto + 3.5;
      delv = vnew-vold;
      
      if (vold >= vto) begin
        if(vold >= vtox) begin
          if(delv <= 0) begin
            /* going off */
            if(vlimited >= vtox) begin
                if(-delv > vtstlo) begin
                vlimited =  vold - vtstlo;
                end
            end else begin
              vlimited = max(vnew,vto+2);
            end
          end else begin
            /* staying on */
            if(delv >= vtsthi) begin
              vlimited = vold + vtsthi;
            end
          end
        end else begin
          /* middle region */
          if(delv <= 0) begin
            /* decreasing */
            vlimited = max(vnew,vto-0.5);
          end else begin
            /* increasing */
            vlimited = min(vnew,vto+4);
          end
        end
      end else begin
        /* off */
        if(delv <= 0) begin
          if(-delv >vtsthi) begin
            vlimited = vold - vtsthi;
          end
        end else begin
          vtemp = vto + 0.5;
          if(vnew <= vtemp) begin
            if(delv > vtstlo) begin
              vlimited = vold + vtstlo;
            end
          end else begin
            vlimited = vtemp;
          end
        end
      end
      if (vlimited!=vnew) begin
        limiting_applied = 1;
      end
      DEVfetlim = vlimited;
    end
  endfunction

  // Analog block
  analog begin

    // Instance field assignments
    if ($param_given(temp)) begin
      JFETtemp = temp+273.15;
      JFETtempGiven = 1;
    end

    // Model field assignments
    JFETtype = type;
    if ($param_given(vt0)) begin
      JFETthreshold = vt0;
    end
    if ($param_given(fc)) begin
      JFETdepletionCapCoeff = fc;
    end
    if ($param_given(tnom)) begin
      JFETtnomGiven = 1;
      JFETtnom = tnom+273.15;
    end

    // Evaluation constants
    lc_gmin = $simparam("gmin", 1e-12);

    // Tag: setup, function: JFETsetup
    if (JFETtype!=1&&JFETtype!=-1) begin
      JFETtype = 1;
    end
    if (!$param_given(vt0)) begin
      JFETthreshold = -2;
    end
    if (!$param_given(fc)) begin
      JFETdepletionCapCoeff = 0.5;
    end
    if (rd!=0) begin
      JFETdrainConduct = 1/rd;
    end else begin
      JFETdrainConduct = 0;
    end
    if (rs!=0) begin
      JFETsourceConduct = 1/rs;
    end else begin
      JFETsourceConduct = 0;
    end
    if (!(rs!=0)) begin
      V(s_int, s) <+ 0;
    end
    if (!(rd!=0)) begin
      V(d_int, d) <+ 0;
    end

    // Tag: temp, function: JFETtemp
    if (!JFETtnomGiven) begin
      JFETtnom = VACONST_tnom;
    end
    vtnom = CONSTKoverQ*JFETtnom;
    fact1 = JFETtnom/(27.0+273.15);
    kt1 = 1.38064852e-23*JFETtnom;
    egfet1 = 1.16-7.02e-4*JFETtnom*JFETtnom/(JFETtnom+1108);
    arg1 = -egfet1/(kt1+kt1)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact1 = -2*vtnom*(1.5*ln(fact1)+1.6021766208e-19*arg1);
    pbo = (pb-pbfact1)/fact1;
    gmaold = (pb-pbo)/pbo;
    cjfact = 1/(1+0.5*(4e-4*(JFETtnom-(27.0+273.15))-gmaold));
    if (rd!=0) begin
      JFETdrainConduct = 1/rd;
    end else begin
      JFETdrainConduct = 0;
    end
    if (rs!=0) begin
      JFETsourceConduct = 1/rs;
    end else begin
      JFETsourceConduct = 0;
    end
    if (JFETdepletionCapCoeff>0.95) begin
      $warning("Depletion cap. coefficient too large, limited to .95");
      JFETdepletionCapCoeff = 0.95;
    end
    xfc = ln(1-JFETdepletionCapCoeff);
    JFETf2 = exp((1+0.5)*xfc);
    JFETf3 = 1-JFETdepletionCapCoeff*(1+0.5);
    JFETbFac = (1-b)/(pb-JFETthreshold);
    if (!JFETtempGiven) begin
      JFETtemp = $temperature+dtemp;
    end
    vt = JFETtemp*CONSTKoverQ;
    vtn = vt*n;
    fact2 = JFETtemp/(27.0+273.15);
    ratio1 = JFETtemp/JFETtnom-1;
    if ($param_given(xti)) begin
      JFETtSatCur = is*exp(ratio1*eg/vtn)*pow(ratio1+1, xti);
    end else begin
      JFETtSatCur = is*exp(ratio1*eg/vtn);
    end
    JFETtCGS = cgs*cjfact;
    JFETtCGD = cgd*cjfact;
    kt = 1.38064852e-23*JFETtemp;
    egfet = 1.16-7.02e-4*JFETtemp*JFETtemp/(JFETtemp+1108);
    arg = -egfet/(kt+kt)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact = -2*vt*(1.5*ln(fact2)+1.6021766208e-19*arg);
    JFETtGatePot = fact2*pbo+pbfact;
    gmanew = (JFETtGatePot-pbo)/pbo;
    cjfact1 = 1+0.5*(4e-4*(JFETtemp-(27.0+273.15))-gmanew);
    JFETtCGS = JFETtCGS * (cjfact1);
    JFETtCGD = JFETtCGD * (cjfact1);
    JFETcorDepCap = JFETdepletionCapCoeff*JFETtGatePot;
    JFETf1 = JFETtGatePot*(1-exp((1-0.5)*xfc))/(1-0.5);
    JFETvcrit = vt*ln(vt/(CONSTroot2*JFETtSatCur));
    if ($param_given(vtotc)) begin
      JFETtThreshold = JFETthreshold+vtotc*(JFETtemp-JFETtnom);
    end else begin
      JFETtThreshold = JFETthreshold-tcv*(JFETtemp-JFETtnom);
    end
    if ($param_given(betatce)) begin
      JFETtBeta = beta*pow(1.01, betatce*(JFETtemp-JFETtnom));
    end else begin
      JFETtBeta = beta*pow(JFETtemp/JFETtnom, bex);
    end

    // Tag: load, function: JFETload
    load_beta = JFETtBeta*area;
    gdpr = JFETdrainConduct*area;
    gspr = JFETsourceConduct*area;
    csat = JFETtSatCur*area;
    limited = 0;
    JFETvgs = JFETtype * $limit(V(g, s_int), DEVlimitOldGet);
    JFETvgd = JFETtype * $limit(V(g, d_int), DEVlimitOldGet);
    load_vgs = JFETtype*V(g, s_int);
    load_vgd = JFETtype*V(g, d_int);
    load_vgs = DEVpnjlim(load_vgs, JFETvgs, JFETtemp*CONSTKoverQ, JFETvcrit, limited);
    load_vgd = DEVpnjlim(load_vgd, JFETvgd, JFETtemp*CONSTKoverQ, JFETvcrit, limited);
    load_vgs = DEVfetlim(load_vgs, JFETvgs, JFETtThreshold, limited);
    load_vgd = DEVfetlim(load_vgd, JFETvgd, JFETtThreshold, limited);
    if (initialize_limiting()) begin
        load_vgs = -1;
        load_vgd = -1;
    end
    load_vgs = JFETtype * $limit(V(g, s_int), DEVlimitNewSet, JFETtype * load_vgs, limited);
    load_vgd = JFETtype * $limit(V(g, d_int), DEVlimitNewSet, JFETtype * load_vgd, limited);
    vds = load_vgs-load_vgd;
    vt_temp = JFETtemp*CONSTKoverQ*n;
    if (load_vgs<-3*vt_temp) begin
      load_arg = 3*vt_temp/(load_vgs*CONSTe);
      load_arg = load_arg*load_arg*load_arg;
      cg = -csat*(1+load_arg)+lc_gmin*load_vgs;
      load_ggs = csat*3*load_arg/load_vgs+lc_gmin;
    end else begin
      evgs = exp(load_vgs/vt_temp);
      load_ggs = csat*evgs/vt_temp+lc_gmin;
      cg = csat*(evgs-1)+lc_gmin*load_vgs;
    end
    if (load_vgd<-3*vt_temp) begin
      load_arg = 3*vt_temp/(load_vgd*CONSTe);
      load_arg = load_arg*load_arg*load_arg;
      load_cgd = -csat*(1+load_arg)+lc_gmin*load_vgd;
      load_ggd = csat*3*load_arg/load_vgd+lc_gmin;
    end else begin
      evgd = exp(load_vgd/vt_temp);
      load_ggd = csat*evgd/vt_temp+lc_gmin;
      load_cgd = csat*(evgd-1)+lc_gmin*load_vgd;
    end
    cg = cg+load_cgd;
    load_vto = JFETtThreshold;
    if (vds>=0) begin
      vgst = load_vgs-load_vto;
      if (vgst<=0) begin
        cdrain = 0;
        load_gm = 0;
        load_gds = 0;
      end else begin
        betap = load_beta*(1+lambda*vds);
        Bfac = JFETbFac;
        if (vgst>=vds) begin
          apart = 2*b+3*Bfac*(vgst-vds);
          cpart = vds*(vds*(Bfac*vds-b)+vgst*apart);
          cdrain = betap*cpart;
          load_gm = betap*vds*(apart+3*Bfac*vgst);
          load_gds = betap*(vgst-vds)*apart+load_beta*lambda*cpart;
        end else begin
          Bfac = vgst*Bfac;
          load_gm = betap*vgst*(2*b+3*Bfac);
          cpart = vgst*vgst*(b+Bfac);
          cdrain = betap*cpart;
          load_gds = lambda*load_beta*cpart;
        end
      end
    end else begin
      vgdt = load_vgd-load_vto;
      if (vgdt<=0) begin
        cdrain = 0;
        load_gm = 0;
        load_gds = 0;
      end else begin
        betap = load_beta*(1-lambda*vds);
        Bfac = JFETbFac;
        if (vgdt+vds>=0) begin
          apart = 2*b+3*Bfac*(vgdt+vds);
          cpart = vds*(-vds*(-Bfac*vds-b)+vgdt*apart);
          cdrain = betap*cpart;
          load_gm = betap*vds*(apart+3*Bfac*vgdt);
          load_gds = betap*(vgdt+vds)*apart-load_beta*lambda*cpart-load_gm;
        end else begin
          Bfac = vgdt*Bfac;
          load_gm = -betap*vgdt*(2*b+3*Bfac);
          cpart = vgdt*vgdt*(b+Bfac);
          cdrain = -betap*cpart;
          load_gds = lambda*load_beta*cpart-load_gm;
        end
      end
    end
    cd = cdrain-load_cgd;
    czgs = JFETtCGS*area;
    czgd = JFETtCGD*area;
    twop = JFETtGatePot+JFETtGatePot;
    fcpb2 = JFETcorDepCap*JFETcorDepCap;
    czgsf2 = czgs/JFETf2;
    czgdf2 = czgd/JFETf2;
    if (load_vgs<JFETcorDepCap) begin
      sarg = sqrt(1-load_vgs/JFETtGatePot);
      JFETqgs = twop*czgs*(1-sarg);
      capgs = czgs/sarg;
    end else begin
      JFETqgs = czgs*JFETf1+czgsf2*(JFETf3*(load_vgs-JFETcorDepCap)+(load_vgs*load_vgs-fcpb2)/(twop+twop));
      capgs = czgsf2*(JFETf3+load_vgs/twop);
    end
    if (load_vgd<JFETcorDepCap) begin
      sarg = sqrt(1-load_vgd/JFETtGatePot);
      JFETqgd = twop*czgd*(1-sarg);
      capgd = czgd/sarg;
    end else begin
      JFETqgd = czgd*JFETf1+czgdf2*(JFETf3*(load_vgd-JFETcorDepCap)+(load_vgd*load_vgd-fcpb2)/(twop+twop));
      capgd = czgdf2*(JFETf3+load_vgd/twop);
    end
    geq = 0;
    JFETcqgs = ddt(JFETqgs);
    ceq = JFETcqgs;
    load_ggs = load_ggs+geq;
    cg = cg+JFETcqgs;
    geq = 0;
    JFETcqgd = ddt(JFETqgd);
    ceq = JFETcqgd;
    load_ggd = load_ggd+geq;
    cg = cg+JFETcqgd;
    JFETdcCurrent = cd;
    cd = cd-JFETcqgd;
    load_cgd = load_cgd+JFETcqgd;
    JFETvgs = load_vgs;
    JFETvgd = load_vgd;
    JFETcg = cg;
    JFETcd = cd;
    JFETcgd = load_cgd;
    JFETgm = load_gm;
    JFETgds = load_gds;
    JFETggs = load_ggs;
    JFETggd = load_ggd;
    ceqgd = JFETtype*load_cgd;
    ceqgs = JFETtype*(cg-load_cgd);
    cdreq = JFETtype*(cd+load_cgd);
    
    // Residuals
    I(d) <+ gdpr*V(d, d_int);
    I(g) <+ -(-ceqgs-ceqgd);
    I(s) <+ gspr*V(s, s_int);
    I(s_int) <+ gspr*V(s_int, s)+-(cdreq+ceqgs);
    I(d_int) <+ gdpr*V(d_int, d)+-(-cdreq+ceqgd);

    // Tag: noise, function: JFETnoise
    if (JFETtempGiven) begin
      noise_dtemp = JFETtemp-$temperature+(JFETtnom-273.15);
    end else begin
      noise_dtemp = dtemp;
    end
    I(d_int, d) <+ white_noise(4*(VACONSTboltz*(($temperature+noise_dtemp)*(JFETdrainConduct*area))), "rd");
    I(s_int, s) <+ white_noise(4*(VACONSTboltz*(($temperature+noise_dtemp)*(JFETsourceConduct*area))), "rs");
    if (nlev<3) begin
      id_psd = 4*(VACONSTboltz*(($temperature+noise_dtemp)*(2.0/3.0*abs(JFETgm))));
    end else begin
      noise_vgs = JFETvgs;
      noise_vds = noise_vgs-JFETvgd;
      noise_vgst = noise_vgs-JFETtThreshold;
      if (noise_vgst>=noise_vds) begin
        alpha = 1-noise_vds/noise_vgst;
      end else begin
        alpha = 0;
      end
      noise_beta = JFETtBeta*area;
      id_psd = 4*(VACONSTboltz*(($temperature+noise_dtemp)*(2.0/3.0*noise_beta*noise_vgst*(1+alpha+alpha*alpha)/(1+alpha)*gdsnoi)));
    end
    I(d_int, s_int) <+ flicker_noise(kf*exp(af*ln(((abs(JFETcd)>1E-38) ? (abs(JFETcd)) : (1E-38)))), 1, "flicker");
    I(d_int, s_int) <+ white_noise(id_psd, "id");

    // Instance output variable computation
    vgs = JFETvgs;
    vgd = JFETvgd;
    gm = JFETgm;
    gds = JFETgds;
    ggs = JFETggs;
    ggd = JFETggd;
    qgs = JFETqgs;
    qgd = JFETqgd;
    cqgs = capgs;
    cqgd = capgd;

    // Model output variable computation

  end
endmodule
