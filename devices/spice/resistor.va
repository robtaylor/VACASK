// Model generated by Verilog-A Distiller.
// (c)2025 Arpad Buermen. All rights reserved.
// SPDX-License-Identifier: AGPL-3.0-or-later
// 
// SPICE flavour: ngspice
// Version      : ngspice-45-84-g7f75f09ec
// Origin       : https://sourceforge.net/u/arpadbuermen/ngspice/ci/vadng-pre-46/tree/
// Date         : 2025-11-21 10:56:21 UTC
// Module name  : sp_resistor
// Model variant: default
// 
// Notes:
//   Parameter m was replaced with builtin Verilog-A parameter $mfactor.
//
//   All parameters and output variables refer to a single parallel instance,
//   even if $mfactor>1.
//
//   Model parameters tc1, tc2, tce, w, l, bv_max, and r were renamed to 
//   model_tc1, model_tc2, model_tce, model_w, model_l, model_bv_max, and model_r 
//   due to name conflicts with instance parameters.
//
//   Full noise model used (appropriate for all noise analyses).
//
// SPICE variable mapping
//   scale -> $simparam("scale", 1)
//
// CKTcircuit member mapping
//   CKTnomTemp -> ('tnom', '($simparam("tnom", 27)+273.15)')
//      CKTtemp -> (None, '$temperature')
//
// Source files and copyright information:
//   res/resdefs.h
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//   res/res.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: Apr 2000 - Paolo Nenzi
//     Modified: 2000 AlansFixes
//   res/resparam.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: Apr 2000 - Paolo Nenzi
//   res/resmpar.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: Apr 2000 - Paolo Nenzi
//     Modified: 2000 AlansFixes
//   res/resask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: Apr 2000 - Paolo Nenzi
//   res/resmask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: Apr 2000 - Paolo Nenzi
//     Modified: 2000 AlansFixes
//   res/ressetup.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: Apr 2000 Paolo Nenzi
//   res/restemp.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified Apr 2000 - Paolo Nenzi
//     Modified: 2000 AlanSfixes
//   res/resload.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: Apr 2000 - Paolo Nenzi
//   res/resnoise.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Gary W. Ng
//     Modified: Apr 2000 - Paolo Nenzi

`include "constants.vams"
`include "disciplines.vams"

module sp_resistor(pos, neg);
  inout pos, neg;
  electrical pos, neg;

  // Instance parameters
  (* desc = "Resistance", type = "instance" *) parameter real resistance = 0;
  aliasparam r = resistance;
  (* desc = "Instance operating temperature", type = "instance" *) parameter real temp = 0;
  (* desc = "Instance temperature difference with the rest of the circuit", type = "instance" *) parameter real dtemp = 0.0;
  (* desc = "Length", type = "instance" *) parameter real l = 0;
  (* desc = "Width", type = "instance" *) parameter real w = 0;
  (* desc = "First order temp. coefficient", type = "instance" *) parameter real tc = 0;
  aliasparam tc1 = tc;
  (* desc = "Second order temp. coefficient", type = "instance" *) parameter real tc2 = 0;
  (* desc = "exponential temp. coefficient", type = "instance" *) parameter real tce = 0;
  (* desc = "maximum voltage over resistor", type = "instance" *) parameter real bv_max = 0;
  (* desc = "Scale factor", type = "instance" *) parameter real scale = 1.0;
  (* desc = "Resistor generate noise", type = "instance" *) parameter integer noisy = 1;
  aliasparam noise = noisy;

  // Model parameters
  (* desc = "Sheet resistance" *) parameter real rsh = 0.0;
  (* desc = "Narrowing of resistor" *) parameter real narrow = 0.0;
  aliasparam dw = narrow;
  (* desc = "Shortening of resistor" *) parameter real short = 0.0;
  aliasparam dlr = short;
  (* desc = "First order temp. coefficient" *) parameter real model_tc1 = 0.0;
  aliasparam tc1r = model_tc1;
  (* desc = "Second order temp. coefficient" *) parameter real model_tc2 = 0.0;
  aliasparam tc2r = model_tc2;
  (* desc = "exponential temp. coefficient" *) parameter real model_tce = 0.0;
  (* desc = "Default device width" *) parameter real defw = 1e-05;
  aliasparam model_w = defw;
  (* desc = "Default device length" *) parameter real model_l = 1e-05;
  (* desc = "Flicker noise coefficient" *) parameter real kf = 0.0;
  (* desc = "Flicker noise exponent" *) parameter real af = 1.0;
  (* desc = "Parameter measurement temperature" *) parameter real tnom = 0;
  (* desc = "Resistor model default value" *) parameter real model_r = 0;
  aliasparam res = model_r;
  (* desc = "maximum voltage over resistor" *) parameter real model_bv_max = 1e+99;
  (* desc = "noise area length exponent" *) parameter real lf = 1.0;
  (* desc = "noise area width exponent" *) parameter real wf = 1.0;
  (* desc = "noise frequency exponent" *) parameter real ef = 1.0;

  // Instance output variables
  (* desc = "Current" *) real i;
  (* desc = "Power" *) real p;

  // Model output variables

  // Instance fields
  real REStemp = 0;
  real RESdtemp = 0;
  real RESconduct = 0;
  real RESresist = 0;
  real REScurrent = 0;
  real RESwidth = 0;
  real RESlength = 0;
  real i_RESbv_max = 0;
  real RESeffNoiseArea = 0;
  integer i_RESresGiven = 0;
  integer REStempGiven = 0;
  integer RESlengthGiven = 0;
  integer RESwidthGiven = 0;

  // Model fields
  real REStnom = 0;
  real RESres = 0;
  integer REStnomGiven = 0;
  integer RESresGiven = 0;

  // States

  // Model parameter access locals

  // Instance parameter access locals

  // Device setup locals

  // Device temperature dependence locals
  real factor = 0;
  real difference = 0;
  real temp_tc1 = 0;
  real temp_tc2 = 0;
  real temp_tce = 0;

  // Device load locals

  // Device noise locals
  real noise_dtemp = 0;

  // Global constants
  real CONSTroot2 = sqrt(2.0);
  real CONSTvt0 = 1.38064852e-23*(27+273.15)/1.6021766208e-19;
  real CONSTKoverQ = 1.38064852e-23/1.6021766208e-19;
  real CONSTe = exp(1.0);
  real VACONSTcharge = 1.6021766208e-19;
  real VACONSTboltz = 1.38064852e-23;
  real VACONST_tnom = ($simparam("tnom", 27)+273.15);
  real cpscale = $simparam("scale", 1);

  // Evaluation constants

  // Translated function definitions

  // Analog block
  analog begin

    // Instance field assignments
    if ($param_given(resistance)) begin
      RESresist = resistance;
      if (RESresist>=0&&RESresist<1e-12) begin
        $warning("Value is too small, set to %e", 1e-12);
        RESresist = 1e-12;
      end else if (RESresist<0&&RESresist>-1e-12) begin
        $warning("Value is too small, set to %e", -1e-12);
        RESresist = -1e-12;
      end
      i_RESresGiven = 1;
    end
    if ($param_given(temp)) begin
      REStemp = temp+273.15;
      if (REStemp<1e-6) begin
        REStemp = 0;
      end
      REStempGiven = 1;
    end
    if ($param_given(dtemp)) begin
      RESdtemp = dtemp;
    end
    if ($param_given(l)) begin
      RESlength = l*cpscale;
      RESlengthGiven = 1;
    end
    if ($param_given(w)) begin
      RESwidth = w*cpscale;
      RESwidthGiven = 1;
    end
    if ($param_given(bv_max)) begin
      i_RESbv_max = bv_max;
    end

    // Model field assignments
    if ($param_given(tnom)) begin
      REStnom = tnom+273.15;
      REStnomGiven = 1;
    end
    if ($param_given(model_r)) begin
      if (model_r>0) begin
        RESres = model_r;
        RESresGiven = 1;
      end
    end

    // Evaluation constants

    // Tag: setup, function: RESsetup
    if (!REStnomGiven) begin
      REStnom = VACONST_tnom;
    end
    if (!RESwidthGiven) begin
      RESwidth = defw;
    end
    if (!RESlengthGiven) begin
      RESlength = model_l;
    end
    if (!$param_given(bv_max)) begin
      i_RESbv_max = model_bv_max;
    end
    if (RESwidthGiven||RESlengthGiven) begin
      RESeffNoiseArea = pow(RESlength-2*short, lf)*pow(RESwidth-2*narrow, wf);
    end else begin
      RESeffNoiseArea = 1.0;
    end

    // Tag: temp, function: REStemp
    if (!REStempGiven) begin
      REStemp = $temperature;
      if (!$param_given(dtemp)) begin
        RESdtemp = 0.0;
      end
    end else begin
      RESdtemp = 0.0;
      if ($param_given(dtemp)) begin
        $warning("Instance temperature specified, dtemp ignored");
      end
    end
    // inlined: RESupdate_conduct(here, 1)
    if (!i_RESresGiven) begin
      if (RESlength*RESwidth*rsh>0.0) begin
        RESresist = (RESlength-2*short)/(RESwidth-2*narrow)*rsh;
      end else if (RESresGiven) begin
        RESresist = RESres;
      end else begin
        $warning("resistance too low or not given, set to 1 mOhm");
        RESresist = 1e-03;
      end
    end
    difference = REStemp+RESdtemp-REStnom;
    if ($param_given(tc)) begin
      temp_tc1 = tc;
    end else begin
      temp_tc1 = model_tc1;
    end
    if ($param_given(tc2)) begin
      temp_tc2 = tc2;
    end else begin
      temp_tc2 = model_tc2;
    end
    if ($param_given(tce)) begin
      temp_tce = tce;
    end else begin
      temp_tce = model_tce;
    end
    if ($param_given(tce)||$param_given(model_tce)) begin
      factor = pow(1.01, temp_tce*difference);
    end else begin
      factor = (temp_tc2*difference+temp_tc1)*difference+1.0;
    end
    RESconduct = 1.0/(RESresist*factor*scale);
    // end of inlined: RESupdate_conduct(here, 1)

    // Tag: load, function: RESload
    REScurrent = V(pos, neg)*RESconduct;
    
    // Residuals
    I(pos) <+ RESconduct*V(pos, neg);
    I(neg) <+ RESconduct*V(neg, pos);

    // Tag: noise, function: RESnoise
    if (noisy) begin
      if (REStempGiven) begin
        noise_dtemp = REStemp-$temperature+(REStnom-273.15);
      end else begin
        noise_dtemp = RESdtemp;
      end
      I(pos, neg) <+ white_noise(4*(VACONSTboltz*(($temperature+noise_dtemp)*RESconduct)), "thermal");
      I(pos, neg) <+ flicker_noise(kf*pow(abs(REScurrent), af)/RESeffNoiseArea, ef, "flicker");
    end

    // Instance output variable computation
    i = V(pos, neg);
    i = i * (RESconduct);
    p = V(pos, neg)*V(pos, neg);
    p = p * (RESconduct);

    // Model output variable computation

  end
endmodule
