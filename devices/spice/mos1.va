// Model generated by Verilog-A Distiller.
// (c)2025 Arpad Buermen. All rights reserved.
// SPDX-License-Identifier: AGPL-3.0-or-later
// 
// SPICE flavour: ngspice
// Version      : ngspice-45-84-g7f75f09ec
// Origin       : https://sourceforge.net/u/arpadbuermen/ngspice/ci/vadng-pre-46/tree/
// Date         : 2025-11-21 10:56:58 UTC
// Module name  : sp_mos1
// Model variant: default
// 
// Notes:
//   Parameter m was replaced with builtin Verilog-A parameter $mfactor.
//
//   All parameters and output variables refer to a single parallel instance,
//   even if $mfactor>1.
//
//   Parameter off was removed. Bypassing is not available in Verilog-A. 
//   
//   Device type is set by the type parameter to NMOS (1) or PMOS (-1). 
//   
//   Output variables rs and rd were removed due to a conflict with model 
//   parameters. Their inverses are available as sourceconductance and 
//   drainconductance output variables. 
//   
//   Output variables cbd, cbs, ig, id, is, and ib were renamed to c_bd, 
//   c_bs, i_g, i_d, i_s, i_b due to conflicts with model parameters. 
//   
//   Meyer charge is not computed and therefore not available. 
//   Output variables qgs, qgd, and qgb were removed. 
//   
//   Parameters ic, icvds, icvgs, and icvbs were removed. Initial conditions 
//   should be set via the simulator's initial conditions mechanism. 
//   
//   Noise model excludes Meyer capacitance currents from the drain 
//   current that is used for computing noise. This is a SPICE3 feature. 
//   Simplified noise model also excludes the capacitive current of the 
//   B-D diode. Due to the way OpenVAF handles c(v)*ddt(v) the implicit 
//   equations do not go away even if simplified noise model is used.
//
//   Full noise model used (appropriate for all noise analyses).
//   OpenVAF may create implicit equations.
//
// SPICE variable mapping
//   scale -> $simparam("scale", 1)
//
// CKTcircuit member mapping
//   CKTdefaultMosAD -> ('defad', '$simparam("defad", 0)', 'const')
//   CKTdefaultMosAS -> ('defas', '$simparam("defas", 0)', 'const')
//    CKTdefaultMosL -> ('defl', '$simparam("defl", 1e-4)', 'const')
//    CKTdefaultMosW -> ('defw', '$simparam("defw", 1e-4)', 'const')
//       CKTfixLimit -> ('oldlimit', '$simparam("oldlimit", 0)', 'const')
//           CKTgmin -> ('gmin', '$simparam("gmin", 1e-12)')
//        CKTnomTemp -> ('tnom', '($simparam("tnom", 27)+273.15)')
//           CKTtemp -> (None, '$temperature')
//
// Source files and copyright information:
//   devsup.c
//   mos1/mos1defs.h
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//   mos1/mos1.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//   mos1/mos1par.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//   mos1/mos1mpar.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//   mos1/mos1ask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//   mos1/mos1mask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Thomas L. Quarles
//   mos1/mos1set.c
//   mos1/mos1temp.c
//   mos1/mos1load.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//   mos1/mos1noi.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Gary W. Ng
//     Modified: 2000 AlansFixes

`include "constants.vams"
`include "disciplines.vams"

module sp_mos1(d, g, s, b);
  inout d, g, s, b;
  electrical d, g, s, b, d_int, s_int;

  // Instance parameters
  (* desc = "Length", type = "instance" *) parameter real l = 0;
  (* desc = "Width", type = "instance" *) parameter real w = 0;
  (* desc = "Drain area", type = "instance" *) parameter real ad = 0;
  (* desc = "Source area", type = "instance" *) parameter real as = 0;
  (* desc = "Drain perimeter", type = "instance" *) parameter real pd = 0;
  (* desc = "Source perimeter", type = "instance" *) parameter real ps = 0;
  (* desc = "Drain squares", type = "instance" *) parameter real nrd = 1;
  (* desc = "Source squares", type = "instance" *) parameter real nrs = 1;
  (* desc = "Instance temperature", type = "instance" *) parameter real temp = 0;
  (* desc = "Instance temperature difference", type = "instance" *) parameter real dtemp = 0.0;

  // Model parameters
  (* desc = "NMOS (1) or PMOS (-1)" *) parameter integer type = 1;
  (* desc = "Threshold voltage" *) parameter real vto = 0;
  aliasparam vt0 = vto;
  (* desc = "Transconductance parameter" *) parameter real kp = 2e-05;
  (* desc = "Bulk threshold parameter" *) parameter real gamma = 0;
  (* desc = "Surface potential" *) parameter real phi = 0.6;
  (* desc = "Channel length modulation" *) parameter real lambda = 0;
  (* desc = "Drain ohmic resistance" *) parameter real rd = 0;
  (* desc = "Source ohmic resistance" *) parameter real rs = 0;
  (* desc = "B-D junction capacitance" *) parameter real cbd = 0;
  (* desc = "B-S junction capacitance" *) parameter real cbs = 0;
  (* desc = "Bulk junction sat. current" *) parameter real is = 1e-14;
  (* desc = "Bulk junction potential" *) parameter real pb = 0.8;
  (* desc = "Gate-source overlap cap." *) parameter real cgso = 0;
  (* desc = "Gate-drain overlap cap." *) parameter real cgdo = 0;
  (* desc = "Gate-bulk overlap cap." *) parameter real cgbo = 0;
  (* desc = "Sheet resistance" *) parameter real rsh = 0;
  (* desc = "Bottom junction cap per area" *) parameter real cj = 0;
  (* desc = "Bottom grading coefficient" *) parameter real mj = 0.5;
  (* desc = "Side junction cap per area" *) parameter real cjsw = 0;
  (* desc = "Side grading coefficient" *) parameter real mjsw = 0.5;
  (* desc = "Bulk jct. sat. current density" *) parameter real js = 0;
  (* desc = "Oxide thickness" *) parameter real tox = 0;
  (* desc = "Lateral diffusion" *) parameter real ld = 0;
  (* desc = "Surface mobility" *) parameter real u0 = 600;
  aliasparam uo = u0;
  (* desc = "Forward bias jct. fit parm." *) parameter real fc = 0.5;
  (* desc = "Substrate doping" *) parameter real nsub = 0;
  (* desc = "Gate type" *) parameter integer tpg = 1;
  (* desc = "Surface state density" *) parameter real nss = 0;
  (* desc = "Parameter measurement temperature" *) parameter real tnom = 0;
  (* desc = "Flicker noise coefficient" *) parameter real kf = 0;
  (* desc = "Flicker noise exponent" *) parameter real af = 1;
  (* desc = "Noise model selection" *) parameter integer nlev = 2;
  (* desc = "Channel shot noise coefficient" *) parameter real gdsnoi = 1;

  // Instance output variables
  (* desc = "Drain current" *) real i_d;
  (* desc = "Source current" *) real i_s;
  (* desc = "Gate current " *) real i_g;
  (* desc = "Bulk current " *) real i_b;
  (* desc = "B-D junction current" *) real ibd;
  (* desc = "B-S junction current" *) real ibs;
  (* desc = "Gate-Source voltage" *) real vgs;
  (* desc = "Drain-Source voltage" *) real vds;
  (* desc = "Bulk-Source voltage" *) real vbs;
  (* desc = "Bulk-Drain voltage" *) real vbd;
  (* desc = " " *) real von;
  (* desc = "Saturation drain voltage" *) real vdsat;
  (* desc = "Critical source voltage" *) real sourcevcrit;
  (* desc = "Critical drain voltage" *) real drainvcrit;
  (* desc = "Conductance of source" *) real sourceconductance;
  (* desc = "Conductance of drain" *) real drainconductance;
  (* desc = "Transconductance" *) real gm;
  (* desc = "Drain-Source conductance" *) real gds;
  (* desc = "Bulk-Source transconductance" *) real gmb;
  (* desc = "Bulk-Drain conductance" *) real gbd;
  (* desc = "Bulk-Source conductance" *) real gbs;
  (* desc = "Bulk-Drain capacitance" *) real c_bd;
  (* desc = "Bulk-Source capacitance" *) real c_bs;
  (* desc = "Gate-Source capacitance" *) real cgs;
  (* desc = "Gate-Drain capacitance" *) real cgd;
  (* desc = "Gate-Bulk capacitance" *) real cgb;
  (* desc = "Capacitance due to gate-source charge storage" *) real cqgs;
  (* desc = "Capacitance due to gate-drain charge storage" *) real cqgd;
  (* desc = "Capacitance due to gate-bulk charge storage" *) real cqgb;
  (* desc = "Capacitance due to bulk-drain charge storage" *) real cqbd;
  (* desc = "Capacitance due to bulk-source charge storage" *) real cqbs;
  (* desc = "Zero-Bias B-D junction capacitance" *) real cbd0;
  (* desc = " " *) real cbdsw0;
  (* desc = "Zero-Bias B-S junction capacitance" *) real cbs0;
  (* desc = " " *) real cbssw0;
  (* desc = "Bulk-Drain charge storage" *) real qbd;
  (* desc = "Bulk-Source charge storage" *) real qbs;

  // Model output variables

  // Instance fields
  real MOS1l = 0;
  real MOS1w = 0;
  real MOS1drainArea = 0;
  real MOS1sourceArea = 0;
  real MOS1drainPerimiter = 0;
  real MOS1sourcePerimiter = 0;
  real MOS1sourceConductance = 0;
  real MOS1drainConductance = 0;
  real MOS1temp = 0;
  real MOS1tTransconductance = 0;
  real MOS1tSurfMob = 0;
  real MOS1tPhi = 0;
  real MOS1tVto = 0;
  real MOS1tSatCur = 0;
  real MOS1tSatCurDens = 0;
  real MOS1tCbd = 0;
  real MOS1tCbs = 0;
  real MOS1tCj = 0;
  real MOS1tCjsw = 0;
  real MOS1tBulkPot = 0;
  real MOS1tDepCap = 0;
  real MOS1tVbi = 0;
  real MOS1von = 0;
  real MOS1vdsat = 0;
  real MOS1sourceVcrit = 0;
  real MOS1drainVcrit = 0;
  real MOS1cd = 0;
  real MOS1cbs = 0;
  real MOS1cbd = 0;
  real MOS1gmbs = 0;
  real MOS1gm = 0;
  real MOS1gds = 0;
  real MOS1gbd = 0;
  real MOS1gbs = 0;
  real MOS1capbd = 0;
  real MOS1capbs = 0;
  real MOS1Cbd = 0;
  real MOS1Cbdsw = 0;
  real MOS1Cbs = 0;
  real MOS1Cbssw = 0;
  real MOS1f2d = 0;
  real MOS1f3d = 0;
  real MOS1f4d = 0;
  real MOS1f2s = 0;
  real MOS1f3s = 0;
  real MOS1f4s = 0;
  integer MOS1mode = 0;
  real MOS1cgs = 0;
  real MOS1cgd = 0;
  real MOS1cgb = 0;
  real MOS1dcCurrent = 0;
  real meyer_scale = 0;
  real meyer_unscale = 0;
  integer MOS1lGiven = 0;
  integer MOS1wGiven = 0;
  integer MOS1drainAreaGiven = 0;
  integer MOS1sourceAreaGiven = 0;
  integer MOS1drainPerimiterGiven = 0;
  integer MOS1sourcePerimiterGiven = 0;
  integer MOS1tempGiven = 0;

  // Model fields
  real MOS1tnom = 0;
  real MOS1transconductance = 0;
  real MOS1oxideCapFactor = 0;
  real MOS1vt0 = 0;
  real MOS1phi = 0;
  real MOS1gamma = 0;
  real MOS1substrateDoping = 0;
  integer MOS1type = 0;
  integer MOS1tnomGiven = 0;

  // States
  real MOS1vbd = 0;
  real MOS1vbs = 0;
  real MOS1vgs = 0;
  real MOS1vds = 0;
  real MOS1capgs = 0;
  real MOS1qgs = 0;
  real MOS1cqgs = 0;
  real MOS1capgd = 0;
  real MOS1qgd = 0;
  real MOS1cqgd = 0;
  real MOS1capgb = 0;
  real MOS1qgb = 0;
  real MOS1cqgb = 0;
  real MOS1qbd = 0;
  real MOS1cqbd = 0;
  real MOS1qbs = 0;
  real MOS1cqbs = 0;

  // Model parameter access locals

  // Instance parameter access locals

  // Device setup locals

  // Device temperature dependence locals
  real egfet = 0;
  real egfet1 = 0;
  real fact1 = 0;
  real fact2 = 0;
  real kt = 0;
  real kt1 = 0;
  real arg1 = 0;
  real ratio = 0;
  real ratio4 = 0;
  real phio = 0;
  real pbo = 0;
  real gmanew = 0;
  real gmaold = 0;
  real capfact = 0;
  real pbfact1 = 0;
  real pbfact = 0;
  real vt = 0;
  real vtnom = 0;
  real wkfngs = 0;
  real wkfng = 0;
  real fermig = 0;
  real fermis = 0;
  real vfb = 0;
  real czbd = 0;
  real czbdsw = 0;
  real czbs = 0;
  real czbssw = 0;
  real arg = 0;
  real sarg = 0;
  real sargsw = 0;

  // Device load locals
  integer limited = 0;
  real Beta = 0;
  real DrainSatCur = 0;
  real EffectiveLength = 0;
  real GateBulkOverlapCap = 0;
  real GateDrainOverlapCap = 0;
  real GateSourceOverlapCap = 0;
  real OxideCap = 0;
  real SourceSatCur = 0;
  real cdrain = 0;
  real cdreq = 0;
  real ceq = 0;
  real ceqbd = 0;
  real ceqbs = 0;
  real ceqgb = 0;
  real ceqgd = 0;
  real ceqgs = 0;
  real evbd = 0;
  real evbs = 0;
  real gcgb = 0;
  real gcgd = 0;
  real gcgs = 0;
  real geq = 0;
  real load_sargsw = 0;
  real load_vbd = 0;
  real load_vbs = 0;
  real load_vds = 0;
  real load_vdsat = 0;
  real vgb = 0;
  real vgd = 0;
  real vgdo = 0;
  real load_vgs = 0;
  real load_von = 0;
  real load_vt = 0;
  real xfact = 0;
  integer xnrm = 0;
  integer xrev = 0;
  real capgs = 0;
  real capgd = 0;
  real capgb = 0;
  real load_arg = 0;
  real betap = 0;
  real load_sarg = 0;
  real vgst = 0;
  real load1_arg = 0;
  real load1_sarg = 0;
  real load2_arg = 0;
  real load2_sarg = 0;

  // Device noise locals
  real coxSquared = 0;
  real noise_vgs = 0;
  real noise_vds = 0;
  real noise_vgd = 0;
  real noise_vgst = 0;
  real alpha = 0;
  real beta = 0;
  real Sid = 0;
  real noise_dtemp = 0;
  real flicker_psd = 0;
  real flicker_exp = 1;

  // Global constants
  real CONSTroot2 = sqrt(2.0);
  real CONSTvt0 = 1.38064852e-23*(27+273.15)/1.6021766208e-19;
  real CONSTKoverQ = 1.38064852e-23/1.6021766208e-19;
  real CONSTe = exp(1.0);
  real VACONSTcharge = 1.6021766208e-19;
  real VACONSTboltz = 1.38064852e-23;
  real defad = $simparam("defad", 0);
  real defas = $simparam("defas", 0);
  real defl = $simparam("defl", 1e-4);
  real defw = $simparam("defw", 1e-4);
  real oldlimit = $simparam("oldlimit", 0);
  real VACONST_tnom = ($simparam("tnom", 27)+273.15);
  real cpscale = $simparam("scale", 1);

  // Evaluation constants
  real lc_gmin = 0;

  // Translated function definitions
  analog function real DEVqmeyer;
    input vgs, vgd, vgb, von, _vdsat;
    inout capgs, capgd, capgb;
    input phi, cox;
    real vgs;
    real vgd;
    real vgb;
    real von;
    real _vdsat;
    real capgs;
    real capgd;
    real capgb;
    real phi;
    real cox;
    real vdsat;
    real vds;
    real vddif;
    real vddif1;
    real vddif2;
    real vgst;
    begin
      DEVqmeyer = 0;
      vdsat = _vdsat;
      vgst = vgs-von;
      vdsat = ((vdsat>0.025) ? (vdsat) : (0.025));
      if (vgst<=-phi) begin
        capgb = cox/2;
        capgs = 0;
        capgd = 0;
      end else if (vgst<=-phi/2) begin
        capgb = -vgst*cox/(2*phi);
        capgs = 0;
        capgd = 0;
      end else if (vgst<=0) begin
        capgb = -vgst*cox/(2*phi);
        capgs = vgst*cox/(1.5*phi)+cox/3;
        vds = vgs-vgd;
        if (vds>=vdsat) begin
          capgd = 0;
        end else begin
          vddif = 2.0*vdsat-vds;
          vddif1 = vdsat-vds;
          vddif2 = vddif*vddif;
          capgd = capgs*(1.0-vdsat*vdsat/vddif2);
          capgs = capgs*(1.0-vddif1*vddif1/vddif2);
        end
      end else begin
        vds = vgs-vgd;
        vdsat = ((vdsat>0.025) ? (vdsat) : (0.025));
        if (vdsat<=vds) begin
          capgs = cox/3;
          capgd = 0;
          capgb = 0;
        end else begin
          vddif = 2.0*vdsat-vds;
          vddif1 = vdsat-vds;
          vddif2 = vddif*vddif;
          capgd = cox*(1.0-vdsat*vdsat/vddif2)/3;
          capgs = cox*(1.0-vddif1*vddif1/vddif2)/3;
          capgb = 0;
        end
      end
    end
  endfunction

  // Verbatim analog functions
  analog function integer initialize_limiting;
    integer il;
    begin
      il = $simparam("iniLim", -1);
      if (il<0) begin
        // iniLim not available, use heuristics
        initialize_limiting = 
          $simparam("iteration", 10)==1 && 
          (analysis("dc") || analysis("static")) && 
          analysis("nodeset");
      end else begin
        initialize_limiting = il;
      end
    end
  endfunction

  analog function real DEVlimitOldGet;
    input vnew, vold;
    real vnew, vold, result;
    begin
      DEVlimitOldGet = vold;
    end
  endfunction

  analog function real DEVlimitNewSet;
    input vnew, vold, new_value, limited;
    real vnew, vold, new_value;
    integer limited;
    begin
      DEVlimitNewSet = new_value;
      if (limited) begin
        $discontinuity(-1);
      end
    end
  endfunction

  analog function real DEVpnjlim;
    input vnew, vold, vt, vcrit;
    inout limiting_applied;
    real vnew, vold, vt, vcrit, limited, arg;
    integer limiting_applied;
    
    begin
      limited = vnew;
      if ((vnew > vcrit) && (abs(vnew - vold) > (vt + vt))) begin
        // Positive vnew above vcrit, change greater than 2*vt
        if(vold > 0) begin
          arg = (vnew - vold) / vt;
          if(arg > 0) begin
            limited = vold + vt * ln(1+arg);
            limiting_applied = 1;
          end else begin
            limited = vold - vt * ln(1-arg);
            limiting_applied = 1;
          end
        end else begin
          limited = vt *ln(vnew/vt);
          limiting_applied = 1;
        end
      end else if (vnew<0) begin
        // Negative vnew, use ngspice limiting
        if (vold > 0) begin
          arg = -1*vold-1; 
        end else begin
          arg = 2*vold-1;
        end
        if (vnew<arg) begin
          limited = arg;
          limiting_applied = 1;
        end
      end 
      DEVpnjlim = limited;
    end
  endfunction

  analog function real DEVfetlim;
    input vnew, vold, vto;
    inout limiting_applied;
    real vnew, vold, vto, vlimited;
    real vtsthi, vtstlo, vtox, delv, vtemp;
    integer limiting_applied;  
    begin
      vlimited = vnew;
      vtsthi = abs(2*(vold-vto))+2;
      // vtstlo = vtsthi/2 +2;
      vtstlo = abs(vold-vto)+1;
      vtox = vto + 3.5;
      delv = vnew-vold;
      
      if (vold >= vto) begin
        if(vold >= vtox) begin
          if(delv <= 0) begin
            /* going off */
            if(vlimited >= vtox) begin
                if(-delv > vtstlo) begin
                vlimited =  vold - vtstlo;
                end
            end else begin
              vlimited = max(vnew,vto+2);
            end
          end else begin
            /* staying on */
            if(delv >= vtsthi) begin
              vlimited = vold + vtsthi;
            end
          end
        end else begin
          /* middle region */
          if(delv <= 0) begin
            /* decreasing */
            vlimited = max(vnew,vto-0.5);
          end else begin
            /* increasing */
            vlimited = min(vnew,vto+4);
          end
        end
      end else begin
        /* off */
        if(delv <= 0) begin
          if(-delv >vtsthi) begin
            vlimited = vold - vtsthi;
          end
        end else begin
          vtemp = vto + 0.5;
          if(vnew <= vtemp) begin
            if(delv > vtstlo) begin
              vlimited = vold + vtstlo;
            end
          end else begin
            vlimited = vtemp;
          end
        end
      end
      if (vlimited!=vnew) begin
        limiting_applied = 1;
      end
      DEVfetlim = vlimited;
    end
  endfunction

  analog function real DEVlimvds;
    input vnew, vold;
    inout limiting_applied;
    real vnew, vold, vlimited;
    integer limiting_applied;
    begin
      if (vold >= 3.5) begin
        if(vnew > vold) begin
          vlimited = min(vnew, (3 * vold) + 2);
        end else begin
          if (vnew < 3.5) begin
            vlimited = max(vnew, 2);
          end else begin
            vlimited = vnew;
          end
        end
      end else begin
        if(vnew > vold) begin
          vlimited = min(vnew, 4);
        end else begin
          vlimited = max(vnew, -0.5);
        end
      end
      DEVlimvds = vlimited;
      if (vlimited!=vnew) begin
        limiting_applied = 1;
      end
    end
  endfunction

  // Analog block
  analog begin

    // Instance field assignments
    if ($param_given(l)) begin
      MOS1l = l*cpscale;
      MOS1lGiven = 1;
    end
    if ($param_given(w)) begin
      MOS1w = w*cpscale;
      MOS1wGiven = 1;
    end
    if ($param_given(ad)) begin
      MOS1drainArea = ad*cpscale*cpscale;
      MOS1drainAreaGiven = 1;
    end
    if ($param_given(as)) begin
      MOS1sourceArea = as*cpscale*cpscale;
      MOS1sourceAreaGiven = 1;
    end
    if ($param_given(pd)) begin
      MOS1drainPerimiter = pd*cpscale;
      MOS1drainPerimiterGiven = 1;
    end
    if ($param_given(ps)) begin
      MOS1sourcePerimiter = ps*cpscale;
      MOS1sourcePerimiterGiven = 1;
    end
    if ($param_given(temp)) begin
      MOS1temp = temp+273.15;
      MOS1tempGiven = 1;
    end

    // Model field assignments
    MOS1type = type;
    if ($param_given(vto)) begin
      MOS1vt0 = vto;
    end
    if ($param_given(kp)) begin
      MOS1transconductance = kp;
    end
    if ($param_given(gamma)) begin
      MOS1gamma = gamma;
    end
    if ($param_given(phi)) begin
      MOS1phi = phi;
    end
    if ($param_given(nsub)) begin
      MOS1substrateDoping = nsub;
    end
    if ($param_given(tnom)) begin
      MOS1tnom = tnom+273.15;
      MOS1tnomGiven = 1;
    end

    // Evaluation constants
    lc_gmin = $simparam("gmin", 1e-12);

    // Tag: setup, function: MOS1setup
    if (!$param_given(kp)) begin
      MOS1transconductance = 2e-5;
    end
    if (!$param_given(vto)) begin
      MOS1vt0 = 0;
    end
    if (!$param_given(phi)) begin
      MOS1phi = 0.6;
    end
    if (!$param_given(gamma)) begin
      MOS1gamma = 0;
    end
    if (!MOS1drainPerimiterGiven) begin
      MOS1drainPerimiter = 0;
    end
    if (!MOS1sourcePerimiterGiven) begin
      MOS1sourcePerimiter = 0;
    end
    MOS1vdsat = 0;
    MOS1von = 0;
    if (!(rd!=0||rsh!=0&&nrd!=0)) begin
      V(d_int, d) <+ 0;
    end
    if (!(rs!=0||rsh!=0&&nrs!=0)) begin
      V(s_int, s) <+ 0;
    end

    // Tag: temp, function: MOS1temp
    if (!MOS1tnomGiven) begin
      MOS1tnom = VACONST_tnom;
    end
    fact1 = MOS1tnom/(27.0+273.15);
    vtnom = MOS1tnom*CONSTKoverQ;
    kt1 = 1.38064852e-23*MOS1tnom;
    egfet1 = 1.16-7.02e-4*MOS1tnom*MOS1tnom/(MOS1tnom+1108);
    arg1 = -egfet1/(kt1+kt1)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact1 = -2*vtnom*(1.5*ln(fact1)+1.6021766208e-19*arg1);
    if (MOS1phi<=0.0) begin
      $fatal(0, "Phi is not positive.");
    end
    if (!$param_given(tox)||tox==0) begin
      MOS1oxideCapFactor = 0;
    end else begin
      MOS1oxideCapFactor = 3.9*8.854214871e-12/tox;
      if (!$param_given(kp)) begin
        MOS1transconductance = u0*MOS1oxideCapFactor*1e-4;
      end
      if ($param_given(nsub)) begin
        if (MOS1substrateDoping*1e6>1.45e16) begin
          if (!$param_given(phi)) begin
            MOS1phi = 2*vtnom*ln(MOS1substrateDoping*1e6/1.45e16);
            MOS1phi = ((0.1>MOS1phi) ? (0.1) : (MOS1phi));
          end
          fermis = MOS1type*0.5*MOS1phi;
          wkfng = 3.2;
          if (tpg!=0) begin
            fermig = MOS1type*tpg*0.5*egfet1;
            wkfng = 3.25+0.5*egfet1-fermig;
          end
          wkfngs = wkfng-(3.25+0.5*egfet1+fermis);
          if (!$param_given(gamma)) begin
            MOS1gamma = sqrt(2*11.70*8.854214871e-12*1.6021766208e-19*MOS1substrateDoping*1e6)/MOS1oxideCapFactor;
          end
          if (!$param_given(vto)) begin
            vfb = wkfngs-nss*1e4*1.6021766208e-19/MOS1oxideCapFactor;
            MOS1vt0 = vfb+MOS1type*(MOS1gamma*sqrt(MOS1phi)+MOS1phi);
          end
        end else begin
          MOS1substrateDoping = 0;
          $fatal(0, "Nsub < Ni");
        end
      end
    end
    if (!MOS1tempGiven) begin
      MOS1temp = $temperature+dtemp;
    end
    vt = MOS1temp*CONSTKoverQ;
    ratio = MOS1temp/MOS1tnom;
    fact2 = MOS1temp/(27.0+273.15);
    kt = MOS1temp*1.38064852e-23;
    egfet = 1.16-7.02e-4*MOS1temp*MOS1temp/(MOS1temp+1108);
    arg = -egfet/(kt+kt)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact = -2*vt*(1.5*ln(fact2)+1.6021766208e-19*arg);
    if (!MOS1drainAreaGiven) begin
      MOS1drainArea = defad;
    end
    if (!MOS1lGiven) begin
      MOS1l = defl;
    end
    if (!MOS1sourceAreaGiven) begin
      MOS1sourceArea = defas;
    end
    if (!MOS1wGiven) begin
      MOS1w = defw;
    end
    if (MOS1l-2*ld<=0) begin
      $warning("effective channel length less than zero");
    end
    ratio4 = ratio*sqrt(ratio);
    MOS1tTransconductance = MOS1transconductance/ratio4;
    MOS1tSurfMob = u0/ratio4;
    phio = (MOS1phi-pbfact1)/fact1;
    MOS1tPhi = fact2*phio+pbfact;
    MOS1tVbi = MOS1vt0-MOS1type*(MOS1gamma*sqrt(MOS1phi))+0.5*(egfet1-egfet)+MOS1type*0.5*(MOS1tPhi-MOS1phi);
    MOS1tVto = MOS1tVbi+MOS1type*MOS1gamma*sqrt(MOS1tPhi);
    MOS1tSatCur = is*exp(-egfet/vt+egfet1/vtnom);
    MOS1tSatCurDens = js*exp(-egfet/vt+egfet1/vtnom);
    pbo = (pb-pbfact1)/fact1;
    gmaold = (pb-pbo)/pbo;
    capfact = 1/(1+mj*(4e-4*(MOS1tnom-(27.0+273.15))-gmaold));
    MOS1tCbd = cbd*capfact;
    MOS1tCbs = cbs*capfact;
    MOS1tCj = cj*capfact;
    capfact = 1/(1+mjsw*(4e-4*(MOS1tnom-(27.0+273.15))-gmaold));
    MOS1tCjsw = cjsw*capfact;
    MOS1tBulkPot = fact2*pbo+pbfact;
    gmanew = (MOS1tBulkPot-pbo)/pbo;
    capfact = 1+mj*(4e-4*(MOS1temp-(27.0+273.15))-gmanew);
    MOS1tCbd = MOS1tCbd * (capfact);
    MOS1tCbs = MOS1tCbs * (capfact);
    MOS1tCj = MOS1tCj * (capfact);
    capfact = 1+mjsw*(4e-4*(MOS1temp-(27.0+273.15))-gmanew);
    MOS1tCjsw = MOS1tCjsw * (capfact);
    MOS1tDepCap = fc*MOS1tBulkPot;
    if (MOS1tSatCurDens==0||MOS1drainArea==0||MOS1sourceArea==0) begin
      MOS1drainVcrit = vt*ln(vt/(CONSTroot2*MOS1tSatCur));
      MOS1sourceVcrit = MOS1drainVcrit;
    end else begin
      MOS1drainVcrit = vt*ln(vt/(CONSTroot2*MOS1tSatCurDens*MOS1drainArea));
      MOS1sourceVcrit = vt*ln(vt/(CONSTroot2*MOS1tSatCurDens*MOS1sourceArea));
    end
    if ($param_given(cbd)) begin
      czbd = MOS1tCbd;
    end else if ($param_given(cj)) begin
      czbd = MOS1tCj*MOS1drainArea;
    end else begin
      czbd = 0;
    end
    if ($param_given(cjsw)) begin
      czbdsw = MOS1tCjsw*MOS1drainPerimiter;
    end else begin
      czbdsw = 0;
    end
    arg = 1-fc;
    sarg = exp(-mj*ln(arg));
    sargsw = exp(-mjsw*ln(arg));
    MOS1Cbd = czbd;
    MOS1Cbdsw = czbdsw;
    MOS1f2d = czbd*(1-fc*(1+mj))*sarg/arg+czbdsw*(1-fc*(1+mjsw))*sargsw/arg;
    MOS1f3d = czbd*mj*sarg/arg/MOS1tBulkPot+czbdsw*mjsw*sargsw/arg/MOS1tBulkPot;
    MOS1f4d = czbd*MOS1tBulkPot*(1-arg*sarg)/(1-mj)+czbdsw*MOS1tBulkPot*(1-arg*sargsw)/(1-mjsw)-MOS1f3d/2*(MOS1tDepCap*MOS1tDepCap)-MOS1tDepCap*MOS1f2d;
    if ($param_given(cbs)) begin
      czbs = MOS1tCbs;
    end else if ($param_given(cj)) begin
      czbs = MOS1tCj*MOS1sourceArea;
    end else begin
      czbs = 0;
    end
    if ($param_given(cjsw)) begin
      czbssw = MOS1tCjsw*MOS1sourcePerimiter;
    end else begin
      czbssw = 0;
    end
    arg = 1-fc;
    sarg = exp(-mj*ln(arg));
    sargsw = exp(-mjsw*ln(arg));
    MOS1Cbs = czbs;
    MOS1Cbssw = czbssw;
    MOS1f2s = czbs*(1-fc*(1+mj))*sarg/arg+czbssw*(1-fc*(1+mjsw))*sargsw/arg;
    MOS1f3s = czbs*mj*sarg/arg/MOS1tBulkPot+czbssw*mjsw*sargsw/arg/MOS1tBulkPot;
    MOS1f4s = czbs*MOS1tBulkPot*(1-arg*sarg)/(1-mj)+czbssw*MOS1tBulkPot*(1-arg*sargsw)/(1-mjsw)-MOS1f3s/2*(MOS1tDepCap*MOS1tDepCap)-MOS1tDepCap*MOS1f2s;
    if ($param_given(rd)) begin
      if (rd!=0) begin
        MOS1drainConductance = 1.0/rd;
      end else begin
        MOS1drainConductance = 0;
      end
    end else if ($param_given(rsh)) begin
      if (rsh!=0) begin
        MOS1drainConductance = 1.0/(rsh*nrd);
      end else begin
        MOS1drainConductance = 0;
      end
    end else begin
      MOS1drainConductance = 0;
    end
    if ($param_given(rs)) begin
      if (rs!=0) begin
        MOS1sourceConductance = 1.0/rs;
      end else begin
        MOS1sourceConductance = 0;
      end
    end else if ($param_given(rsh)) begin
      if (rsh!=0&&nrs!=0) begin
        MOS1sourceConductance = 1.0/(rsh*nrs);
      end else begin
        MOS1sourceConductance = 0;
      end
    end else begin
      MOS1sourceConductance = 0;
    end

    // Tag: load, function: MOS1load
    xfact = 0.0;
    capgs = 0.0;
    capgd = 0.0;
    capgb = 0.0;
    load_vt = CONSTKoverQ*MOS1temp;
    EffectiveLength = MOS1l-2*ld;
    if (MOS1tSatCurDens==0||MOS1drainArea==0||MOS1sourceArea==0) begin
      DrainSatCur = MOS1tSatCur;
      SourceSatCur = MOS1tSatCur;
    end else begin
      DrainSatCur = MOS1tSatCurDens*MOS1drainArea;
      SourceSatCur = MOS1tSatCurDens*MOS1sourceArea;
    end
    GateSourceOverlapCap = cgso*MOS1w;
    GateDrainOverlapCap = cgdo*MOS1w;
    GateBulkOverlapCap = cgbo*EffectiveLength;
    Beta = MOS1tTransconductance*MOS1w/EffectiveLength;
    OxideCap = MOS1oxideCapFactor*EffectiveLength*MOS1w;
    limited = 0;
    /* Previous vgs, vds, vbs, and vbd */
    MOS1vgs = MOS1type * $limit(V(g, s_int), DEVlimitOldGet);
    MOS1vds = MOS1type * $limit(V(d_int, s_int), DEVlimitOldGet);
    MOS1vbs = MOS1type * $limit(V(b, s_int), DEVlimitOldGet);
    MOS1vbd = MOS1type * $limit(V(b, d_int), DEVlimitOldGet);
    
    /* Previous mode */
    if (MOS1vds >= 0) begin
        /* normal mode */
        MOS1mode = 1;
    end else begin
        /* inverse mode */
        MOS1mode = -1;
    end
    
    /* Recompute previous von */
    if ((MOS1mode==1?MOS1vbs:MOS1vbd) <= 0 ) begin
        load_sarg=sqrt(MOS1tPhi-(MOS1mode==1?MOS1vbs:MOS1vbd));
    end else begin
        load_sarg=sqrt(MOS1tPhi);
        load_sarg=load_sarg-(MOS1mode?MOS1vbs:MOS1vbd)/(load_sarg+load_sarg);
        load_sarg=max(0,load_sarg);
    end
    MOS1von=(MOS1tVbi*MOS1type)+MOS1gamma*load_sarg;
    load_vbs = MOS1type*V(b, s_int);
    load_vgs = MOS1type*V(g, s_int);
    load_vds = MOS1type*V(d_int, s_int);
    load_vbd = load_vbs-load_vds;
    vgd = load_vgs-load_vds;
    vgdo = MOS1vgs-MOS1vds;
    load_von = MOS1type*MOS1von;
    if (MOS1vds>=0) begin
      load_vgs = DEVfetlim(load_vgs, MOS1vgs, load_von, limited);
      load_vds = load_vgs-vgd;
      load_vds = DEVlimvds(load_vds, MOS1vds, limited);
      vgd = load_vgs-load_vds;
    end else begin
      vgd = DEVfetlim(vgd, vgdo, load_von, limited);
      load_vds = load_vgs-vgd;
      if (!oldlimit) begin
        load_vds = -DEVlimvds(-load_vds, -MOS1vds, limited);
      end
      load_vgs = vgd+load_vds;
    end
    if (load_vds>=0) begin
      load_vbs = DEVpnjlim(load_vbs, MOS1vbs, load_vt, MOS1sourceVcrit, limited);
      load_vbd = load_vbs-load_vds;
    end else begin
      load_vbd = DEVpnjlim(load_vbd, MOS1vbd, load_vt, MOS1drainVcrit, limited);
      load_vbs = load_vbd+load_vds;
    end
    if (initialize_limiting()) begin
        load_vbs = -1;
        load_vgs = MOS1type * MOS1tVto;
        load_vds = 0;
        load_vbd = load_vbs - load_vds;
    end
    
    load_vgs = MOS1type * $limit(V(g, s_int), DEVlimitNewSet, MOS1type * load_vgs, limited);
    load_vds = MOS1type * $limit(V(d_int, s_int), DEVlimitNewSet, MOS1type * load_vds, limited);
    load_vbs = MOS1type * $limit(V(b, s_int), DEVlimitNewSet, MOS1type * load_vbs, limited);
    load_vbd = MOS1type * $limit(V(b, d_int), DEVlimitNewSet, MOS1type * load_vbd, limited);
    load_vbd = load_vbs-load_vds;
    vgd = load_vgs-load_vds;
    vgb = load_vgs-load_vbs;
    if (load_vbs<=-3*load_vt) begin
      MOS1gbs = lc_gmin/$mfactor;
      MOS1cbs = lc_gmin/$mfactor*load_vbs-SourceSatCur;
    end else begin
      evbs = exp(((709.0<load_vbs/load_vt) ? (709.0) : (load_vbs/load_vt)));
      MOS1gbs = SourceSatCur*evbs/load_vt+lc_gmin/$mfactor;
      MOS1cbs = SourceSatCur*(evbs-1)+lc_gmin/$mfactor*load_vbs;
    end
    if (load_vbd<=-3*load_vt) begin
      MOS1gbd = lc_gmin/$mfactor;
      MOS1cbd = lc_gmin/$mfactor*load_vbd-DrainSatCur;
    end else begin
      evbd = exp(((709.0<load_vbd/load_vt) ? (709.0) : (load_vbd/load_vt)));
      MOS1gbd = DrainSatCur*evbd/load_vt+lc_gmin/$mfactor;
      MOS1cbd = DrainSatCur*(evbd-1)+lc_gmin/$mfactor*load_vbd;
    end
    if (load_vds>=0) begin
      MOS1mode = 1;
    end else begin
      MOS1mode = -1;
    end
    if (((MOS1mode==1) ? (load_vbs) : (load_vbd))<=0) begin
      load_sarg = sqrt(MOS1tPhi-((MOS1mode==1) ? (load_vbs) : (load_vbd)));
    end else begin
      load_sarg = sqrt(MOS1tPhi);
      load_sarg = load_sarg-((MOS1mode==1) ? (load_vbs) : (load_vbd))/(load_sarg+load_sarg);
      load_sarg = ((0>load_sarg) ? (0) : (load_sarg));
    end
    load_von = MOS1tVbi*MOS1type+MOS1gamma*load_sarg;
    vgst = ((MOS1mode==1) ? (load_vgs) : (vgd))-load_von;
    load_vdsat = ((vgst>0) ? (vgst) : (0));
    if (load_sarg<=0) begin
      load_arg = 0;
    end else begin
      load_arg = MOS1gamma/(load_sarg+load_sarg);
    end
    if (vgst<=0) begin
      cdrain = 0;
      MOS1gm = 0;
      MOS1gds = 0;
      MOS1gmbs = 0;
    end else begin
      betap = Beta*(1+lambda*(load_vds*MOS1mode));
      if (vgst<=load_vds*MOS1mode) begin
        cdrain = betap*vgst*vgst*0.5;
        MOS1gm = betap*vgst;
        MOS1gds = lambda*Beta*vgst*vgst*0.5;
        MOS1gmbs = MOS1gm*load_arg;
      end else begin
        cdrain = betap*(load_vds*MOS1mode)*(vgst-0.5*(load_vds*MOS1mode));
        MOS1gm = betap*(load_vds*MOS1mode);
        MOS1gds = betap*(vgst-load_vds*MOS1mode)+lambda*Beta*(load_vds*MOS1mode)*(vgst-0.5*(load_vds*MOS1mode));
        MOS1gmbs = MOS1gm*load_arg;
      end
    end
    MOS1von = MOS1type*load_von;
    MOS1vdsat = MOS1type*load_vdsat;
    MOS1dcCurrent = MOS1mode*cdrain-MOS1cbd;
    MOS1cd = MOS1dcCurrent;
    if (OxideCap==0) begin
        meyer_scale = 0;
        meyer_unscale = 1;
    end else begin
        meyer_scale = OxideCap;
        meyer_unscale = OxideCap;
    end
    if (MOS1Cbs!=0||MOS1Cbssw!=0) begin
      if (load_vbs<MOS1tDepCap) begin
        load1_arg = 1-load_vbs/MOS1tBulkPot;
        if (mj==mjsw) begin
          if (mj==0.5) begin
            load_sargsw = 1/sqrt(load1_arg);
            load1_sarg = load_sargsw;
          end else begin
            load_sargsw = exp(-mj*ln(load1_arg));
            load1_sarg = load_sargsw;
          end
        end else begin
          if (mj==0.5) begin
            load1_sarg = 1/sqrt(load1_arg);
          end else begin
            load1_sarg = exp(-mj*ln(load1_arg));
          end
          if (mjsw==0.5) begin
            load_sargsw = 1/sqrt(load1_arg);
          end else begin
            load_sargsw = exp(-mjsw*ln(load1_arg));
          end
        end
        MOS1qbs = MOS1tBulkPot*(MOS1Cbs*(1-load1_arg*load1_sarg)/(1-mj)+MOS1Cbssw*(1-load1_arg*load_sargsw)/(1-mjsw));
        MOS1capbs = MOS1Cbs*load1_sarg+MOS1Cbssw*load_sargsw;
      end else begin
        MOS1qbs = MOS1f4s+load_vbs*(MOS1f2s+load_vbs*(MOS1f3s/2));
        MOS1capbs = MOS1f2s+MOS1f3s*load_vbs;
      end
    end else begin
      MOS1qbs = 0;
      MOS1capbs = 0;
    end
    if (MOS1Cbd!=0||MOS1Cbdsw!=0) begin
      if (load_vbd<MOS1tDepCap) begin
        load2_arg = 1-load_vbd/MOS1tBulkPot;
        if (mj==0.5&&mjsw==0.5) begin
          load_sargsw = 1/sqrt(load2_arg);
          load2_sarg = load_sargsw;
        end else begin
          if (mj==0.5) begin
            load2_sarg = 1/sqrt(load2_arg);
          end else begin
            load2_sarg = exp(-mj*ln(load2_arg));
          end
          if (mjsw==0.5) begin
            load_sargsw = 1/sqrt(load2_arg);
          end else begin
            load_sargsw = exp(-mjsw*ln(load2_arg));
          end
        end
        MOS1qbd = MOS1tBulkPot*(MOS1Cbd*(1-load2_arg*load2_sarg)/(1-mj)+MOS1Cbdsw*(1-load2_arg*load_sargsw)/(1-mjsw));
        MOS1capbd = MOS1Cbd*load2_sarg+MOS1Cbdsw*load_sargsw;
      end else begin
        MOS1qbd = MOS1f4d+load_vbd*(MOS1f2d+load_vbd*MOS1f3d/2);
        MOS1capbd = MOS1f2d+load_vbd*MOS1f3d;
      end
    end else begin
      MOS1qbd = 0;
      MOS1capbd = 0;
    end
    geq = 0;
    MOS1cqbd = ddt(MOS1qbd);
    ceq = MOS1cqbd;
    MOS1gbd = MOS1gbd + (geq);
    MOS1cbd = MOS1cbd + (MOS1cqbd);
    MOS1cd = MOS1cd - (MOS1cqbd);
    geq = 0;
    MOS1cqbs = ddt(MOS1qbs);
    ceq = MOS1cqbs;
    MOS1gbs = MOS1gbs + (geq);
    MOS1cbs = MOS1cbs + (MOS1cqbs);
    MOS1vbs = load_vbs;
    MOS1vbd = load_vbd;
    MOS1vgs = load_vgs;
    MOS1vds = load_vds;
    if (MOS1mode>0) begin
      DEVqmeyer(load_vgs, vgd, vgb, load_von, load_vdsat, MOS1capgs, MOS1capgd, MOS1capgb, MOS1tPhi, OxideCap);
    end else begin
      DEVqmeyer(vgd, load_vgs, vgb, load_von, load_vdsat, MOS1capgd, MOS1capgs, MOS1capgb, MOS1tPhi, OxideCap);
    end
    capgs = MOS1capgs+MOS1capgs+GateSourceOverlapCap;
    capgd = MOS1capgd+MOS1capgd+GateDrainOverlapCap;
    capgb = MOS1capgb+MOS1capgb+GateBulkOverlapCap;
    if (capgs==0) begin
      MOS1cqgs = 0;
    end
    if (capgd==0) begin
      MOS1cqgd = 0;
    end
    if (capgb==0) begin
      MOS1cqgb = 0;
    end
    gcgs = 0;
    ceqgs = capgs*(ddt(meyer_scale*load_vgs)/meyer_unscale);
    MOS1cqgs = ceqgs;
    gcgd = 0;
    ceqgd = capgd*(ddt(meyer_scale*vgd)/meyer_unscale);
    MOS1cqgd = ceqgd;
    gcgb = 0;
    ceqgb = capgb*(ddt(meyer_scale*vgb)/meyer_unscale);
    MOS1cqgb = ceqgb;
    ceqbs = MOS1type*MOS1cbs;
    ceqbd = MOS1type*MOS1cbd;
    if (MOS1mode>=0) begin
      xnrm = 1;
      xrev = 0;
      cdreq = MOS1type*cdrain;
    end else begin
      xnrm = 0;
      xrev = 1;
      cdreq = -MOS1type*cdrain;
    end
    
    // Residuals
    I(d) <+ MOS1drainConductance*V(d, d_int);
    I(g) <+ gcgb*V(g, b)+gcgd*V(g, d_int)+gcgs*V(g, s_int)+MOS1type*(ceqgs+ceqgb+ceqgd);
    I(s) <+ MOS1sourceConductance*V(s, s_int);
    I(b) <+ gcgb*V(b, g)+(ceqbs+ceqbd-MOS1type*ceqgb);
    I(d_int) <+ MOS1drainConductance*V(d_int, d)+gcgd*V(d_int, g)+-(ceqbd-cdreq+MOS1type*ceqgd);
    I(s_int) <+ MOS1sourceConductance*V(s_int, s)+gcgs*V(s_int, g)+-(cdreq+ceqbs+MOS1type*ceqgs);

    // Tag: noise, function: MOS1noise
    if (MOS1oxideCapFactor==0.0) begin
      coxSquared = 3.9*8.854214871e-12/1e-7;
    end else begin
      coxSquared = MOS1oxideCapFactor;
    end
    coxSquared = coxSquared * (coxSquared);
    if (MOS1tempGiven) begin
      noise_dtemp = MOS1temp-$temperature+(MOS1tnom-273.15);
    end else begin
      noise_dtemp = dtemp;
    end
    I(d_int, d) <+ white_noise(4*(VACONSTboltz*(($temperature+noise_dtemp)*MOS1drainConductance)), "rd");
    I(s_int, s) <+ white_noise(4*(VACONSTboltz*(($temperature+noise_dtemp)*MOS1sourceConductance)), "rs");
    if (nlev<3) begin
      Sid = 2.0/3.0*abs(MOS1gm);
    end else begin
      noise_vds = MOS1vds;
      noise_vgs = MOS1vgs;
      noise_vgd = noise_vgs-noise_vds;
      noise_vgst = ((MOS1mode==1) ? (noise_vgs) : (noise_vgd))-MOS1type*MOS1von;
      if (noise_vgst>0) begin
        if (noise_vgst<=noise_vds*MOS1mode) begin
          alpha = 0.0;
        end else begin
          alpha = 1.0-noise_vds*MOS1mode/(MOS1type*MOS1vdsat);
        end
        beta = MOS1tTransconductance*MOS1w/(MOS1l-2*ld);
        Sid = 2.0/3.0*beta*noise_vgst*(1.0+alpha+alpha*alpha)/(1.0+alpha)*gdsnoi;
      end else begin
        Sid = 0.0;
      end
    end
    I(d_int, s_int) <+ white_noise(4*(VACONSTboltz*(($temperature+noise_dtemp)*Sid)), "id");
    case (nlev)
      0: begin
        flicker_psd = kf*exp(af*ln(((abs(MOS1cd)>1E-38) ? (abs(MOS1cd)) : (1E-38))))/((MOS1l-2*ld)*(MOS1l-2*ld)*sqrt(coxSquared));
        flicker_exp = 1;
      end
      1: begin
        flicker_psd = kf*exp(af*ln(((abs(MOS1cd)>1E-38) ? (abs(MOS1cd)) : (1E-38))))/(MOS1w*(MOS1l-2*ld)*sqrt(coxSquared));
        flicker_exp = 1;
      end
      2, 
      3: begin
        flicker_psd = kf*MOS1gm*MOS1gm/(MOS1w*(MOS1l-2*ld)*sqrt(coxSquared));
        flicker_exp = af;
      end
    endcase

    I(d_int, s_int) <+ flicker_noise(flicker_psd, flicker_exp, "flicker");

    // Instance output variable computation
    i_d = MOS1cd;
    i_s = -MOS1cd;
    i_s = i_s - (MOS1cbd+MOS1cbs-MOS1cqgb);
    i_s = i_s - (MOS1cqgb+MOS1cqgd+MOS1cqgs);
    i_g = MOS1cqgb+MOS1cqgd+MOS1cqgs;
    i_b = MOS1cbd+MOS1cbs-MOS1cqgb;
    ibd = MOS1cbd;
    ibs = MOS1cbs;
    vgs = MOS1vgs;
    vds = MOS1vds;
    vbs = MOS1vbs;
    vbd = MOS1vbd;
    von = MOS1von;
    vdsat = MOS1vdsat;
    sourcevcrit = MOS1sourceVcrit;
    drainvcrit = MOS1drainVcrit;
    sourceconductance = MOS1sourceConductance;
    drainconductance = MOS1drainConductance;
    gm = MOS1gm;
    gds = MOS1gds;
    gmb = MOS1gmbs;
    gbd = MOS1gbd;
    gbs = MOS1gbs;
    c_bd = MOS1capbd;
    c_bs = MOS1capbs;
    cgs = 2*MOS1capgs;
    cgs = cgs + (cgso*MOS1w);
    cgd = 2*MOS1capgd;
    cgd = cgd + (cgdo*MOS1w);
    cgb = 2*MOS1capgb;
    cgb = cgb + (cgbo*(MOS1l-2*ld));
    cqgs = MOS1cqgs;
    cqgd = MOS1cqgd;
    cqgb = MOS1cqgb;
    cqbd = MOS1cqbd;
    cqbs = MOS1cqbs;
    cbd0 = MOS1Cbd;
    cbdsw0 = MOS1Cbdsw;
    cbs0 = MOS1Cbs;
    cbssw0 = MOS1Cbssw;
    qbd = MOS1qbd;
    qbs = MOS1qbs;

    // Model output variable computation

  end
endmodule
