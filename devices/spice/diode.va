// Model generated by Verilog-A Distiller.
// (c)2024 Arpad Buermen. All rights reserved.
// 
// SPICE flavour: ngspice
// Version      : ngspice-42-330-g5a440b763
// Origin       : https://sourceforge.net/u/arpadbuermen/ngspice/ci/vad-simparam/tree/
// Date         : 2025-01-03 21:30:56 UTC
// Module name  : sp_diode
// 
// Notes:
//   Parameter m was replaced with builtin Verilog-A parameter $mfactor.
//
//   All parameters and opvars refer to a single parallel instance,
//   even if $mfactor>1.
//
//   Parameter off was removed. Bypassing is not available in Verilog-A. 
//   
//   Model parameters area, pj, lm, lp, wm, and wp were renamed to 
//   model_area, model_pj, model_lm, model_lp, model_wm, and model_wp 
//   due to name conflicts with instance parameters. 
//   
//   Parameter ic was removed. Initial conditions should be set via the 
//   simulator's initial conditions mechanism. 
//   
//   Instance parameter thermal and model parameters rth0 and cth0 were 
//   removed because the model does not support self-heating. 
//   
//   Opvar alias c was removed due to a conflict with a terminal name.
//
//   This model exposes opvars that can lead to creation of
//   implicit equations by OpenVAF.
//
//   Simplified noise model used (ignores capacitive current).
//   Appropriate only for small-signal noise analysis.
//
// SPICE variable mapping
//   scale -> $simparam("scale", 1)
//
// CKTcircuit member mapping
//   CKTnomTemp -> ('tnom', '($simparam("tnom", 27)+273.15)')
//    CKTepsmin -> ('epsmin', '$simparam("epsmin", 1e-28)')
//      CKTtemp -> (None, '$temperature')
//    CKTreltol -> ('reltol', '$simparam("reltol", 1e-3)')
//      CKTgmin -> ('gmin', '$simparam("gmin", 1e-12)')
//
// Source files and copyright information:
//   dio/diodefs.h
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified by Paolo Nenzi 2003 and Dietmar Warning 2012
//   dio/dio.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified by Paolo Nenzi 2003 and Dietmar Warning 2012
//   dio/dioparam.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified by Paolo Nenzi 2003 and Dietmar Warning 2012
//   dio/diompar.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified by Paolo Nenzi 2003 and Dietmar Warning 2012
//   dio/dioask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified by Paolo Nenzi 2003 and Dietmar Warning 2012
//   dio/diomask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified by Paolo Nenzi 2003 and Dietmar Warning 2012
//   dio/diosetup.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//     Modified by Paolo Nenzi 2003 and Dietmar Warning 2012
//   dio/diotemp.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//     Modified by Paolo Nenzi 2003 and Dietmar Warning 2012
//   dio/dioload.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//     Modified by Paolo Nenzi 2003 and Dietmar Warning 2012
//   dio/dionoise.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1987 Gary W. Ng
//     Modified by Dietmar Warning 2003

`include "constants.vams"
`include "disciplines.vams"

module sp_diode(a, c);
  inout a, c;
  electrical a, c, a_int;

  // Instance parameters
  (* desc = "Instance temperature", type = "instance" *) parameter real temp = 0;
  (* desc = "Instance delta temperature", type = "instance" *) parameter real dtemp = 0.0;
  (* desc = "Area factor", type = "instance" *) parameter real area = 0;
  (* desc = "Perimeter factor", type = "instance" *) parameter real pj = 0;
  (* desc = "Diode width", type = "instance" *) parameter real w = 0;
  (* desc = "Diode length", type = "instance" *) parameter real l = 0;
  (* desc = "Length of metal capacitor (level=3)", type = "instance" *) parameter real lm = 0;
  (* desc = "Length of polysilicon capacitor (level=3)", type = "instance" *) parameter real lp = 0;
  (* desc = "Width of metal capacitor (level=3)", type = "instance" *) parameter real wm = 0;
  (* desc = "Width of polysilicon capacitor (level=3)", type = "instance" *) parameter real wp = 0;

  // Model parameters
  (* desc = "Diode level selector" *) parameter integer level = 1;
  (* desc = "Saturation current" *) parameter real is = 1e-14;
  aliasparam js = is;
  (* desc = "Sidewall Saturation current" *) parameter real jsw = 0.0;
  (* desc = "Parameter measurement temperature" *) parameter real tnom = 0;
  aliasparam tref = tnom;
  (* desc = "Ohmic resistance" *) parameter real rs = 0;
  (* desc = "Ohmic resistance 1st order temp. coeff." *) parameter real trs = 0.0;
  aliasparam trs1 = trs;
  (* desc = "Ohmic resistance 2nd order temp. coeff." *) parameter real trs2 = 0.0;
  (* desc = "Emission Coefficient" *) parameter real n = 1;
  (* desc = "Sidewall emission Coefficient" *) parameter real ns = 1;
  (* desc = "Transit Time" *) parameter real tt = 0;
  (* desc = "Transit Time 1st order temp. coeff." *) parameter real ttt1 = 0.0;
  (* desc = "Transit Time 2nd order temp. coeff." *) parameter real ttt2 = 0.0;
  (* desc = "Junction capacitance" *) parameter real cjo = 0.0;
  aliasparam cj0 = cjo;
  aliasparam cj = cjo;
  (* desc = "Junction potential" *) parameter real vj = 1;
  aliasparam pb = vj;
  (* desc = "Grading coefficient" *) parameter real m = 0.5;
  aliasparam mj = m;
  (* desc = "Grading coefficient 1st temp. coeff." *) parameter real tm1 = 0.0;
  (* desc = "Grading coefficient 2nd temp. coeff." *) parameter real tm2 = 0.0;
  (* desc = "Sidewall junction capacitance" *) parameter real cjp = 0;
  aliasparam cjsw = cjp;
  (* desc = "Sidewall junction potential" *) parameter real php = 1;
  (* desc = "Sidewall Grading coefficient" *) parameter real mjsw = 0.33;
  (* desc = "Forward Knee current" *) parameter real ikf = 0;
  aliasparam ik = ikf;
  (* desc = "Reverse Knee current" *) parameter real ikr = 0;
  (* desc = "Breakdown Emission Coefficient" *) parameter real nbv = 0;
  (* desc = "Area factor" *) parameter real model_area = 1.0;
  (* desc = "Perimeter factor" *) parameter real model_pj = 0.0;
  (* desc = "Diode temperature equation selector" *) parameter integer tlev = 0;
  (* desc = "Diode temperature equation selector" *) parameter integer tlevc = 0;
  (* desc = "Activation energy" *) parameter real eg = 0;
  (* desc = "First bandgap correction factor" *) parameter real gap1 = 0.000702;
  (* desc = "Second bandgap correction factor" *) parameter real gap2 = 1108.0;
  (* desc = "Saturation current temperature exp." *) parameter real xti = 3;
  (* desc = "Area junction temperature coefficient" *) parameter real cta = 0.0;
  aliasparam ctc = cta;
  (* desc = "Perimeter junction capacitance temperature coefficient" *) parameter real ctp = 0.0;
  (* desc = "Area junction potential temperature coefficient" *) parameter real tpb = 0.0;
  aliasparam tvj = tpb;
  (* desc = "Perimeter junction potential temperature coefficient" *) parameter real tphp = 0.0;
  (* desc = "Tunneling saturation current" *) parameter real jtun = 0.0;
  (* desc = "Tunneling sidewall saturation current" *) parameter real jtunsw = 0.0;
  (* desc = "Tunneling emission coefficient" *) parameter real ntun = 30.0;
  (* desc = "Tunneling saturation current exponential" *) parameter real xtitun = 3.0;
  (* desc = "EG correction factor for tunneling" *) parameter real keg = 1.0;
  (* desc = "flicker noise coefficient" *) parameter real kf = 0.0;
  (* desc = "flicker noise exponent" *) parameter real af = 1.0;
  (* desc = "Forward bias junction fit parameter" *) parameter real fc = 0.5;
  (* desc = "Forward bias sidewall junction fit parameter" *) parameter real fcs = 0.5;
  (* desc = "Reverse breakdown voltage" *) parameter real bv = 0;
  aliasparam vb = bv;
  aliasparam vrb = bv;
  aliasparam var = bv;
  (* desc = "Current at reverse breakdown voltage" *) parameter real ibv = 0.001;
  aliasparam ib = ibv;
  (* desc = "Reverse breakdown voltage temperature coefficient" *) parameter real tcv = 0.0;
  (* desc = "Recombination saturation current" *) parameter real isr = 1e-14;
  (* desc = "Recombination current emission coefficient" *) parameter real nr = 2;
  (* desc = "maximum voltage in forward direction" *) parameter real fv_max = 1e+99;
  (* desc = "maximum voltage in reverse direction" *) parameter real bv_max = 1e+99;
  (* desc = "maximum current" *) parameter real id_max = 1e+99;
  (* desc = "temperature" *) parameter real te_max = 1e+99;
  (* desc = "maximum power dissipation" *) parameter real pd_max = 1e+99;
  (* desc = "Length of metal capacitor (level=3)" *) parameter real model_lm = 0.0;
  (* desc = "Length of polysilicon capacitor (level=3)" *) parameter real model_lp = 0.0;
  (* desc = "Width of metal capacitor (level=3)" *) parameter real model_wm = 0.0;
  (* desc = "Width of polysilicon capacitor (level=3)" *) parameter real model_wp = 0.0;
  (* desc = "Thickness of the metal to bulk oxide (level=3)" *) parameter real xom = 1e-06;
  (* desc = "Thickness of the polysilicon to bulk oxide (level=3)" *) parameter real xoi = 1e-06;
  (* desc = "Masking and etching effects in metal (level=3)" *) parameter real xm = 0.0;
  (* desc = "Masking and etching effects in polysilicon (level=3)" *) parameter real xp = 0.0;
  (* desc = "Masking and etching effects (level=3)" *) parameter real xw = 0.0;

  // Instance opvars
  (* desc = "Diode voltage" *) real vd;
  (* desc = "Diode current" *) real id;
  (* desc = "Diode conductance" *) real gd;
  (* desc = "Diode capacitance" *) real cd;
  (* desc = "Diode capacitor charge" *) real charge;
  (* desc = "Diode capacitor current" *) real capcur;
  (* desc = "Diode power" *) real p;

  // Model opvars
  (* desc = "Ohmic conductance" *) real cond;

  // Instance fields
  integer DIOtempNode;
  real DIOcap;
  real DIOareaParam;
  real DIOpjParam;
  real DIOarea;
  real DIOpj;
  real DIOtemp;
  real DIOtJctPot;
  real DIOtJctCap;
  real DIOtJctSWPot;
  real DIOtJctSWCap;
  real DIOtTransitTime;
  real DIOtGradingCoeff;
  real DIOtConductance;
  real DIOtConductance_dT;
  real DIOtDepCap;
  real DIOtDepSWCap;
  real DIOtSatCur;
  real DIOtSatCur_dT;
  real DIOtSatSWCur;
  real DIOtSatSWCur_dT;
  real DIOtTunSatCur;
  real DIOtTunSatCur_dT;
  real DIOtTunSatSWCur;
  real DIOtTunSatSWCur_dT;
  real DIOtVcrit;
  real DIOtF1;
  real DIOtBrkdwnV;
  real DIOtF2;
  real DIOtF3;
  real DIOtF2SW;
  real DIOtF3SW;
  real DIOforwardKneeCurrent;
  real DIOreverseKneeCurrent;
  real DIOjunctionCap;
  real DIOjunctionSWCap;
  real DIOtRecSatCur;
  real DIOtRecSatCur_dT;
  real DIOdIth_dVrs;
  real DIOdIth_dVdio;
  real DIOdIth_dT;
  real DIOgcTt;
  real DIOdIrs_dT;
  real i_DIOdIdio_dT;
  real DIOcmetal;
  real DIOcpoly;
  real DIOdcCurrent;
  integer DIOtempGiven = 0;

  // Model fields
  real DIOsatCur;
  real DIOconductance;
  real DIObrkdEmissionCoeff;
  real DIOactivationEnergy;
  real DIOnomTemp;
  real DIOmetalOxideThick;
  real DIOpolyOxideThick;
  integer DIOnomTempGiven = 0;
  integer DIOforwardKneeCurrentGiven = 0;
  integer DIOreverseKneeCurrentGiven = 0;
  integer DIOmetalOxideThickGiven = 0;
  integer DIOpolyOxideThickGiven = 0;

  // States
  real DIOvoltage;
  real DIOcurrent;
  real DIOconduct;
  real DIOcapCharge;
  real DIOcapCurrent;
  real DIOdeltemp;
  real DIOdIdio_dT;
  real DIOsensxp;

  // Device setup locals
  real scale;
  real setup_wm;
  real setup_lm;
  real setup_wp;
  real setup_lp;

  // Device temperature dependence locals
  real xfc;
  real xfcs;
  real vt;
  real vte;
  real vts;
  real vtt;
  real vtr;
  real cbv;
  real xbv;
  real xcbv;
  real tol;
  real vtnom;
  integer iter;
  real dt;
  real factor;
  real tBreakdownVoltage;
  real egfet1;
  real arg1;
  real fact1;
  real pbfact1;
  real pbo;
  real gmaold;
  real pboSW;
  real gmaSWold;
  real fact2;
  real pbfact;
  real arg;
  real egfet;
  real gmanew;
  real gmaSWnew;
  real arg1_dT;
  real arg2;
  real arg2_dT;
  real lnTRatio;
  real egfet_dT;
  real arg0;
  real vte_dT;
  real vts_dT;
  real vtt_dT;
  real vtr_dT;

  // Device load locals
  integer limited;
  real load_arg;
  real argsw;
  real capd;
  real load_cd;
  real cdb;
  real cdsw;
  real cdb_dT;
  real cdsw_dT;
  real cdeq;
  real cdhat;
  real ceq;
  real csat;
  real csatsw;
  real czero;
  real czof2;
  real argSW;
  real czeroSW;
  real czof2SW;
  real sargSW;
  real sqrt_ikr;
  real sqrt_ikf;
  real ikf_area_m;
  real ikr_area_m;
  real delvd;
  real evd;
  real evrev;
  real load_gd;
  real gdb;
  real gdsw;
  real gen_fac;
  real gen_fac_vd;
  real t1;
  real evd_rec;
  real cdb_rec;
  real gdb_rec;
  real cdb_rec_dT;
  real geq;
  real gspr;
  real sarg;
  real load_vd;
  real vdtemp;
  real load_vt;
  real load_vte;
  real vtesw;
  real vtetun;
  real vtebrk;
  integer Check_th;
  real diffcharge;
  real deplcharge;
  real deplchargeSW;
  real diffcap;
  real deplcap;
  real deplcapSW;
  real deldelTemp;
  real delTemp;
  real Temp;
  real ceqqth;
  real Ith;
  real gcTt;
  real vrs;
  real dIdio_dT;
  real dIth_dVdio;
  real dIrs_dT;
  real dIth_dVrs;
  real dIth_dT;
  real argsw_dT;
  real csat_dT;
  real csatsw_dT;
  real evrev_dT;
  real vterec;
  real darg_dT;
  real load1_evrev_dT;

  // Device noise locals
  real tempOnoise;
  real tempInoise;
  integer i;
  real noise_dtemp;

  // Global constants
  real CONSTroot2 = sqrt(2.0);
  real CONSTvt0 = 1.38064852e-23*(27+273.15)/1.6021766208e-19;
  real CONSTKoverQ = 1.38064852e-23/1.6021766208e-19;
  real CONSTe = exp(1.0);
  real VACONSTcharge = 1.6021766208e-19;
  real VACONSTboltz = 1.38064852e-23;
  real VACONST_tnom = ($simparam("tnom", 27)+273.15);
  real reltol = $simparam("reltol", 1e-3);
  real epsmin = $simparam("epsmin", 1e-28);
  real cpscale = $simparam("scale", 1);

  // Evaluation constants
  real gmin = 0;

  // Translated function definitions

  // Verbatim analog functions
  analog function integer initialize_limiting;
    integer il;
    begin
      il = $simparam("initializeLimiting", -1);
      initialize_limiting = 
        (il>0) || 
        (
          il<0 &&
        $simparam("iteration", 10)==1 && 
        (analysis("dc") || analysis("static")) && 
          analysis("nodeset")
        );
    end
  endfunction

  analog function DEVlimitOldGet;
    input vnew, vold;
    real vnew, vold, result;
    begin
      DEVlimitOldGet = vold;
    end
  endfunction

  analog function DEVlimitNewSet;
    input vnew, vold, new_value, limited;
    real vnew, vold, new_value;
    integer limited;
    begin
      DEVlimitNewSet = new_value;
      if (limited) begin
        $discontinuity(-1);
      end
    end
  endfunction

  analog function real DEVpnjlim;
    input vnew, vold, vt, vcrit;
    inout limiting_applied;
    real vnew, vold, vt, vcrit, limited, arg;
    integer limiting_applied;
    
    begin
      limited = vnew;
      if ((vnew > vcrit) && (abs(vnew - vold) > (vt + vt))) begin
        // Positive vnew above vcrit, change greater than 2*vt
        if(vold > 0) begin
          arg = (vnew - vold) / vt;
          if(arg > 0) begin
            limited = vold + vt * (2+ln(arg-2));
            limiting_applied = 1;
          end else begin
            limited = vold - vt * (2+ln(2-arg));
            limiting_applied = 1;
          end
        end else begin
          limited = vt *ln(vnew/vt);
          limiting_applied = 1;
        end
      end else if (vnew<0) begin
        // Negative vnew, use ngspice limiting
        if (vold > 0) begin
          arg = -1*vold-1; 
        end else begin
          arg = 2*vold-1;
        end
        if (vnew<arg) begin
          limited = arg;
          limiting_applied = 1;
        end
      end 
      DEVpnjlim = limited;
    end
  endfunction

  // Analog block
  analog begin

    // Instance field assignments
    if ($param_given(temp)) begin
      DIOtemp = temp+273.15;
      DIOtempGiven = 1;
    end
    if ($param_given(area)) begin
      DIOareaParam = area;
    end
    if ($param_given(pj)) begin
      DIOpjParam = pj;
    end

    // Model field assignments
    if ($param_given(is)) begin
      DIOsatCur = is;
    end
    if ($param_given(tnom)) begin
      DIOnomTemp = tnom+273.15;
      DIOnomTempGiven = 1;
    end
    if ($param_given(nbv)) begin
      DIObrkdEmissionCoeff = nbv;
    end
    if ($param_given(eg)) begin
      DIOactivationEnergy = eg;
    end
    if ($param_given(xom)) begin
      DIOmetalOxideThick = xom*1e-10;
      DIOmetalOxideThickGiven = 1;
    end
    if ($param_given(xoi)) begin
      DIOpolyOxideThick = xoi*1e-10;
      DIOpolyOxideThickGiven = 1;
    end

    // Evaluation constants
    gmin = $simparam("gmin", 1e-12);

    // Tag: setup, function: DIOsetup
    scale = cpscale;
    if (!$param_given(is)) begin
      DIOsatCur = 1e-14;
    end
    if (DIOforwardKneeCurrentGiven) begin
      if (ikf<epsmin) begin
        DIOforwardKneeCurrentGiven = 0;
        $warning("IKF too small - model effect disabled!");
      end
    end
    if (DIOreverseKneeCurrentGiven) begin
      if (ikr<epsmin) begin
        DIOreverseKneeCurrentGiven = 0;
        $warning("IKR too small - model effect disabled!");
      end
    end
    if (!$param_given(nbv)) begin
      DIObrkdEmissionCoeff = n;
    end
    if (!$param_given(eg)) begin
      if (tlev==2) begin
        DIOactivationEnergy = 1.16;
      end else begin
        DIOactivationEnergy = 1.11;
      end
    end
    if (DIOsatCur<epsmin) begin
      DIOsatCur = epsmin;
    end
    if (!DIOnomTempGiven) begin
      DIOnomTemp = VACONST_tnom;
    end
    if (!$param_given(rs)||rs==0) begin
      DIOconductance = 0.0;
    end else begin
      DIOconductance = 1/rs;
    end
    if (!DIOmetalOxideThickGiven) begin
      DIOmetalOxideThick = 1e-06;
    end
    if (!DIOpolyOxideThickGiven) begin
      DIOpolyOxideThick = 1e-06;
    end
    if (!$param_given(area)) begin
      if (!$param_given(w)&&!$param_given(l)) begin
        DIOareaParam = model_area;
      end else begin
        DIOareaParam = 1;
      end
    end
    if (!$param_given(pj)) begin
      if (!$param_given(w)&&!$param_given(l)) begin
        DIOpjParam = model_pj;
      end else begin
        DIOpjParam = 0;
      end
    end
    DIOarea = DIOareaParam;
    DIOpj = DIOpjParam;
    DIOcmetal = 0.0;
    DIOcpoly = 0.0;
    if (level==3) begin
      if ($param_given(w)&&$param_given(l)) begin
        DIOarea = (w+xw)*(l+xw);
        DIOpj = 2*(w+xw)+2*(l+xw);
      end
      DIOarea = DIOarea*scale*scale;
      DIOpj = DIOpj*scale;
      if ($param_given(wm)) begin
        setup_wm = wm;
      end else begin
        setup_wm = model_wm;
      end
      if ($param_given(lm)) begin
        setup_lm = lm;
      end else begin
        setup_lm = model_lm;
      end
      if ($param_given(wp)) begin
        setup_wp = wp;
      end else begin
        setup_wp = model_wp;
      end
      if ($param_given(lp)) begin
        setup_lp = lp;
      end else begin
        setup_lp = model_lp;
      end
      DIOcmetal = 3.9*(1.0/(4.0*3.1415926535897932384626433832795*1E-7*299792458*299792458))/DIOmetalOxideThick*(setup_wm*scale+xm)*(setup_lm*scale+xm);
      DIOcpoly = 3.9*(1.0/(4.0*3.1415926535897932384626433832795*1E-7*299792458*299792458))/DIOpolyOxideThick*(setup_wp*scale+xp)*(setup_lp*scale+xp);
    end
    DIOforwardKneeCurrent = ikf*DIOarea;
    DIOreverseKneeCurrent = ikr*DIOarea;
    DIOjunctionCap = cjo*DIOarea;
    DIOjunctionSWCap = cjp*DIOpj;
    if (rs==0) begin
      V(a_int, a) <+ 0;
    end

    // Tag: temp, function: DIOtemp
    if (!DIOtempGiven) begin
      DIOtemp = $temperature+dtemp;
    end
    egfet_dT = 0.0;
    vt = CONSTKoverQ*DIOtemp;
    vte = n*vt;
    vte_dT = CONSTKoverQ*n;
    vts = ns*vt;
    vts_dT = CONSTKoverQ*ns;
    vtt = ntun*vt;
    vtt_dT = CONSTKoverQ*ntun;
    vtr = nr*vt;
    vtr_dT = CONSTKoverQ*nr;
    vtnom = CONSTKoverQ*DIOnomTemp;
    dt = DIOtemp-DIOnomTemp;
    lnTRatio = ln(DIOtemp/DIOnomTemp);
    factor = 1.0+tm1*dt+tm2*dt*dt;
    DIOtGradingCoeff = m*factor;
    if (tlev==0||tlev==1) begin
      egfet = 1.16-7.02e-4*DIOtemp*DIOtemp/(DIOtemp+1108);
      egfet1 = 1.16-7.02e-4*DIOnomTemp*DIOnomTemp/(DIOnomTemp+1108);
    end else begin
      egfet = DIOactivationEnergy-gap1*DIOtemp*DIOtemp/(DIOtemp+gap2);
      egfet_dT = gap1*DIOtemp*DIOtemp/((DIOtemp+gap2)*(DIOtemp+gap2))-2*gap1*DIOtemp/(DIOtemp+gap2);
      egfet1 = DIOactivationEnergy-gap1*DIOnomTemp*DIOnomTemp/(DIOnomTemp+gap2);
    end
    fact2 = DIOtemp/(27.0+273.15);
    arg = -egfet/(2*1.38064852e-23*DIOtemp)+1.1150877/(1.38064852e-23*(27.0+273.15+(27.0+273.15)));
    pbfact = -2*vt*(1.5*ln(fact2)+1.6021766208e-19*arg);
    arg1 = -egfet1/(1.38064852e-23*2*DIOnomTemp)+1.1150877/(2*1.38064852e-23*(27.0+273.15));
    fact1 = DIOnomTemp/(27.0+273.15);
    pbfact1 = -2*vtnom*(1.5*ln(fact1)+1.6021766208e-19*arg1);
    if (tlevc==0) begin
      pbo = (vj-pbfact1)/fact1;
      gmaold = (vj-pbo)/pbo;
      DIOtJctCap = DIOjunctionCap/(1+DIOtGradingCoeff*(400e-6*(DIOnomTemp-(27.0+273.15))-gmaold));
      DIOtJctPot = pbfact+fact2*pbo;
      gmanew = (DIOtJctPot-pbo)/pbo;
      DIOtJctCap = DIOtJctCap * (1+DIOtGradingCoeff*(400e-6*(DIOtemp-(27.0+273.15))-gmanew));
    end else begin
      if (tlevc==1) begin
        DIOtJctPot = vj-tpb*(DIOtemp-(27.0+273.15));
        DIOtJctCap = DIOjunctionCap*(1+cta*(DIOtemp-(27.0+273.15)));
      end
    end
    if (tlevc==0) begin
      pboSW = (php-pbfact1)/fact1;
      gmaSWold = (php-pboSW)/pboSW;
      DIOtJctSWCap = DIOjunctionSWCap/(1+mjsw*(400e-6*(DIOnomTemp-(27.0+273.15))-gmaSWold));
      DIOtJctSWPot = pbfact+fact2*pboSW;
      gmaSWnew = (DIOtJctSWPot-pboSW)/pboSW;
      DIOtJctSWCap = DIOtJctSWCap * (1+mjsw*(400e-6*(DIOtemp-(27.0+273.15))-gmaSWnew));
    end else begin
      if (tlevc==1) begin
        DIOtJctSWPot = php-tphp*(DIOtemp-(27.0+273.15));
        DIOtJctSWCap = DIOjunctionSWCap*(1+ctp*(DIOtemp-(27.0+273.15)));
      end
    end
    if (tlev==0||tlev==1) begin
      arg1 = (DIOtemp/DIOnomTemp-1)*DIOactivationEnergy/vte;
      arg1_dT = DIOactivationEnergy/(vte*DIOnomTemp)-DIOactivationEnergy*(DIOtemp/DIOnomTemp-1)/(vte*DIOtemp);
      arg2 = xti/n*lnTRatio;
      arg2_dT = xti/n/DIOtemp;
      DIOtSatCur = DIOsatCur*DIOarea*exp(arg1+arg2);
      DIOtSatCur_dT = DIOtSatCur*(arg1_dT+arg2_dT);
      arg1 = (DIOtemp/DIOnomTemp-1)*DIOactivationEnergy/vts;
      arg1_dT = DIOactivationEnergy/(vts*DIOnomTemp)-DIOactivationEnergy*(DIOtemp/DIOnomTemp-1)/(vts*DIOtemp);
      arg2 = xti/ns*lnTRatio;
      arg2_dT = xti/ns/DIOtemp;
      DIOtSatSWCur = jsw*DIOpj*exp(arg1+arg2);
      DIOtSatSWCur_dT = DIOtSatSWCur*(arg1_dT+arg2_dT);
      arg1 = (DIOtemp/DIOnomTemp-1)*keg*DIOactivationEnergy/vtt;
      arg1_dT = keg*DIOactivationEnergy/(vtt*DIOnomTemp)-DIOactivationEnergy*(DIOtemp/DIOnomTemp-1)/(vtt*DIOtemp);
      arg2 = xtitun/ntun*lnTRatio;
      arg2_dT = xtitun/ntun/DIOtemp;
      DIOtTunSatCur = jtun*DIOarea*exp(arg1+arg2);
      DIOtTunSatCur_dT = DIOtTunSatCur*(arg1_dT+arg2_dT);
      DIOtTunSatSWCur = jtunsw*DIOpj*exp(arg1+arg2);
      DIOtTunSatSWCur_dT = DIOtTunSatSWCur*(arg1_dT+arg2_dT);
      arg1 = (DIOtemp/DIOnomTemp-1)*DIOactivationEnergy/vtr;
      arg1_dT = DIOactivationEnergy/(vtr*DIOnomTemp)-DIOactivationEnergy*(DIOtemp/DIOnomTemp-1)/(vtr*DIOtemp);
      arg2 = xti/nr*lnTRatio;
      arg2_dT = xti/nr/DIOtemp;
      DIOtRecSatCur = isr*DIOarea*exp(arg1+arg2);
      DIOtRecSatCur_dT = DIOtRecSatCur*(arg1_dT+arg2_dT);
    end else begin
      arg0 = egfet1/(n*vtnom);
      arg1 = egfet/vte;
      arg1_dT = (egfet_dT*vte-egfet*vte_dT)/(egfet*egfet);
      arg2 = xti/n*lnTRatio;
      arg2_dT = xti/n/DIOtemp;
      DIOtSatCur = DIOsatCur*DIOarea*exp(arg0-arg1+arg2);
      DIOtSatCur_dT = DIOtSatCur*(-arg1_dT+arg2_dT);
      arg0 = egfet1/(ns*vtnom);
      arg1 = egfet/vts;
      arg1_dT = (egfet_dT*vts-egfet*vts_dT)/(egfet*egfet);
      arg2 = xti/ns*lnTRatio;
      arg2_dT = xti/ns/DIOtemp;
      DIOtSatSWCur = jsw*DIOpj*exp(arg0-arg1+arg2);
      DIOtSatSWCur_dT = DIOtSatSWCur*(-arg1_dT+arg2_dT);
      arg0 = keg*egfet1/(ntun*vtnom);
      arg1 = keg*egfet/vtt;
      arg1_dT = keg*(egfet_dT*vtt-egfet*vtt_dT)/(egfet*egfet);
      arg2 = xtitun/ntun*lnTRatio;
      arg2_dT = xtitun/ntun/DIOtemp;
      DIOtTunSatCur = jtun*DIOarea*exp(arg0-arg1+arg2);
      DIOtTunSatCur_dT = DIOtTunSatCur*(-arg1_dT+arg2_dT);
      DIOtTunSatSWCur = jtunsw*DIOpj*exp(arg0-arg1+arg2);
      DIOtTunSatSWCur_dT = DIOtTunSatSWCur*(-arg1_dT+arg2_dT);
      arg0 = egfet1/(nr*vtnom);
      arg1 = egfet/vtr;
      arg1_dT = (egfet_dT*vtr-egfet*vtr_dT)/(egfet*egfet);
      arg2 = xti/nr*lnTRatio;
      arg2_dT = xti/nr/DIOtemp;
      DIOtRecSatCur = isr*DIOarea*exp(arg0-arg1+arg2);
      DIOtRecSatCur_dT = DIOtRecSatCur*(-arg1_dT+arg2_dT);
    end
    xfc = ln(1-fc);
    xfcs = ln(1-fcs);
    DIOtF1 = DIOtJctPot*(1-exp((1-DIOtGradingCoeff)*xfc))/(1-DIOtGradingCoeff);
    DIOtDepCap = fc*DIOtJctPot;
    DIOtDepSWCap = fcs*DIOtJctSWPot;
    DIOtVcrit = vte*ln(vte/(CONSTroot2*DIOtSatCur));
    if ($param_given(bv)) begin
      if (tlev==0) begin
        tBreakdownVoltage = bv-tcv*dt;
      end else begin
        tBreakdownVoltage = bv*(1-tcv*dt);
      end
      if (level==1) begin
        cbv = $mfactor*ibv;
      end else begin
        cbv = ibv*DIOarea;
      end
      if (cbv<DIOtSatCur*tBreakdownVoltage/vt) begin
        xbv = tBreakdownVoltage;
      end else begin
        tol = reltol*cbv*$mfactor;
        xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(1+cbv/(DIOtSatCur*$mfactor));
        iter = 0;
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<=tol)) begin
          xbv = tBreakdownVoltage-DIObrkdEmissionCoeff*vt*ln(cbv/(DIOtSatCur*$mfactor)+1-xbv/vt);
          xcbv = DIOtSatCur*$mfactor*(exp((tBreakdownVoltage-xbv)/(DIObrkdEmissionCoeff*vt))-1+xbv/vt);
          iter = iter+1;
        end
        if (!(abs(xcbv-cbv)<tol)) begin
          $warning("unable to match forward and reverse diode regions: bv = %g, ibv = %g", xbv, xcbv);
        end
      end
      DIOtBrkdwnV = xbv;
    end
    factor = 1.0+ttt1*dt+ttt2*dt*dt;
    DIOtTransitTime = tt*factor;
    DIOtConductance = DIOconductance*DIOarea;
    if ($param_given(rs)&&rs!=0.0) begin
      factor = 1.0+trs*dt+trs2*dt*dt;
      DIOtConductance = DIOconductance*DIOarea/factor;
      DIOtConductance_dT = -DIOconductance*DIOarea*(trs+trs2*dt)/(factor*factor);
    end
    DIOtF2 = exp((1+DIOtGradingCoeff)*xfc);
    DIOtF3 = 1-fc*(1+DIOtGradingCoeff);
    DIOtF2SW = exp((1+mjsw)*xfcs);
    DIOtF3SW = 1-fcs*(1+mjsw);

    // Tag: load, function: DIOload
    ceqqth = 0.0;
    Ith = 0.0;
    gcTt = 0.0;
    vrs = 0.0;
    dIth_dVdio = 0.0;
    dIrs_dT = 0.0;
    dIth_dVrs = 0.0;
    dIth_dT = 0.0;
    Check_th = 0;
    cdsw = 0.0;
    cdsw_dT = 0.0;
    gdsw = 0.0;
    delTemp = 0.0;
    load_vt = CONSTKoverQ*DIOtemp;
    load_vte = n*load_vt;
    vtebrk = DIObrkdEmissionCoeff*load_vt;
    gspr = DIOtConductance;
    limited = 0;
    DIOvoltage = $limit(V(a_int,c), DEVlimitOldGet);
    load_vd = V(a_int, c);
    delTemp = 0.0;
    delvd = load_vd-DIOvoltage;
    deldelTemp = delTemp-DIOdeltemp;
    cdhat = DIOcurrent+DIOconduct*delvd+DIOdIdio_dT*deldelTemp;
    if ($param_given(bv)&&load_vd<((0<-DIOtBrkdwnV+10*vtebrk) ? (0) : (-DIOtBrkdwnV+10*vtebrk))) begin
      vdtemp = -(load_vd+DIOtBrkdwnV);
      vdtemp = DEVpnjlim(vdtemp, -(DIOvoltage+DIOtBrkdwnV), vtebrk, DIOtVcrit, limited);
      load_vd = -(vdtemp+DIOtBrkdwnV);
    end else begin
      load_vd = DEVpnjlim(load_vd, DIOvoltage, load_vte, DIOtVcrit, limited);
    end
    delTemp = 0.0;
    if (initialize_limiting()) begin
        load_vd = DIOtVcrit;
    end
    load_vd = $limit(V(a_int,c), DEVlimitNewSet, load_vd, limited);
    Temp = DIOtemp;
    csat = DIOtSatCur;
    csat_dT = DIOtSatCur_dT;
    csatsw = DIOtSatSWCur;
    csatsw_dT = DIOtSatSWCur_dT;
    gspr = DIOtConductance;
    if ($param_given(jsw)) begin
      if ($param_given(ns)) begin
        vtesw = ns*load_vt;
        if (load_vd>=-3*vtesw) begin
          evd = exp(load_vd/vtesw);
          cdsw = csatsw*(evd-1);
          gdsw = csatsw*evd/vtesw;
          cdsw_dT = csatsw_dT*(evd-1)-csatsw*load_vd*evd/(vtesw*Temp);
        end else begin
          if (!$param_given(bv)||load_vd>=-DIOtBrkdwnV) begin
            argsw = 3*vtesw/(load_vd*CONSTe);
            argsw = argsw*argsw*argsw;
            argsw_dT = 3*argsw/Temp;
            cdsw = -csatsw*(1+argsw);
            gdsw = csatsw*3*argsw/load_vd;
            cdsw_dT = -csatsw_dT-(csatsw_dT*argsw+csatsw*argsw_dT);
          end else begin
            evrev = exp(-(DIOtBrkdwnV+load_vd)/vtebrk);
            evrev_dT = (DIOtBrkdwnV+load_vd)*evrev/(vtebrk*Temp);
            cdsw = -csatsw*evrev;
            gdsw = csatsw*evrev/vtebrk;
            cdsw_dT = -(csatsw_dT*evrev+csatsw*evrev_dT);
          end
        end
      end else begin
        csat = csat+csatsw;
        csat_dT = csat_dT+csatsw_dT;
        cdsw_dT = 0.0;
      end
    end
    if (load_vd>=-3*load_vte) begin
      evd = exp(load_vd/load_vte);
      cdb = csat*(evd-1);
      gdb = csat*evd/load_vte;
      cdb_dT = csat_dT*(evd-1)-csat*load_vd*evd/(load_vte*Temp);
      if ($param_given(isr)) begin
        vterec = nr*load_vt;
        evd_rec = exp(load_vd/vterec);
        cdb_rec = DIOtRecSatCur*(evd_rec-1);
        gdb_rec = DIOtRecSatCur*evd_rec/vterec;
        cdb_rec_dT = DIOtRecSatCur_dT*(evd_rec-1)-DIOtRecSatCur*load_vd*evd_rec/(vterec*Temp);
        t1 = pow(1-load_vd/DIOtJctPot, 2)+0.005;
        gen_fac = pow(t1, DIOtGradingCoeff/2);
        gen_fac_vd = -DIOtGradingCoeff*(1-load_vd/DIOtJctPot)*pow(t1, DIOtGradingCoeff/2-1);
        cdb_rec = cdb_rec*gen_fac;
        gdb_rec = gdb_rec*gen_fac+cdb_rec*gen_fac_vd;
        cdb = cdb+cdb_rec;
        gdb = gdb+gdb_rec;
        cdb_dT = cdb_dT+cdb_rec_dT*gen_fac;
      end
    end else begin
      if (!$param_given(bv)||load_vd>=-DIOtBrkdwnV) begin
        load_arg = 3*load_vte/(load_vd*CONSTe);
        load_arg = load_arg*load_arg*load_arg;
        darg_dT = 3*load_arg/Temp;
        cdb = -csat*(1+load_arg);
        gdb = csat*3*load_arg/load_vd;
        cdb_dT = -csat_dT-(csat_dT*load_arg+csat*darg_dT);
      end else begin
        evrev = exp(-(DIOtBrkdwnV+load_vd)/vtebrk);
        load1_evrev_dT = (DIOtBrkdwnV+load_vd)*evrev/(vtebrk*Temp);
        cdb = -csat*evrev;
        gdb = csat*evrev/vtebrk;
        cdb_dT = -(csat_dT*evrev+csat*load1_evrev_dT);
      end
    end
    if ($param_given(jtunsw)) begin
      vtetun = ntun*load_vt;
      evd = exp(-load_vd/vtetun);
      cdsw = cdsw-DIOtTunSatSWCur*(evd-1);
      gdsw = gdsw+DIOtTunSatSWCur*evd/vtetun;
      cdsw_dT = cdsw_dT-DIOtTunSatSWCur_dT*(evd-1)-DIOtTunSatSWCur*load_vd*evd/(vtetun*Temp);
    end
    if ($param_given(jtun)) begin
      vtetun = ntun*load_vt;
      evd = exp(-load_vd/vtetun);
      cdb = cdb-DIOtTunSatCur*(evd-1);
      gdb = gdb+DIOtTunSatCur*evd/vtetun;
      cdb_dT = cdb_dT-DIOtTunSatCur_dT*(evd-1)-DIOtTunSatCur*load_vd*evd/(vtetun*Temp);
    end
    load_cd = cdb+cdsw;
    load_gd = gdb+gdsw;
    dIdio_dT = cdb_dT+cdsw_dT;
    if (load_vd>=-3*load_vte) begin
      if (DIOforwardKneeCurrentGiven&&load_cd>1.0e-18) begin
        ikf_area_m = DIOforwardKneeCurrent;
        sqrt_ikf = sqrt(load_cd/ikf_area_m);
        load_gd = ((1+sqrt_ikf)*load_gd-load_cd*load_gd/(2*sqrt_ikf*ikf_area_m))/(1+2*sqrt_ikf+load_cd/ikf_area_m)+gmin;
        load_cd = load_cd/(1+sqrt_ikf)+gmin*load_vd;
      end else begin
        load_gd = load_gd+gmin;
        load_cd = load_cd+gmin*load_vd;
      end
    end else begin
      if (DIOreverseKneeCurrentGiven&&load_cd<-1.0e-18) begin
        ikr_area_m = DIOreverseKneeCurrent;
        sqrt_ikr = sqrt(load_cd/-ikr_area_m);
        load_gd = ((1+sqrt_ikr)*load_gd+load_cd*load_gd/(2*sqrt_ikr*ikr_area_m))/(1+2*sqrt_ikr-load_cd/ikr_area_m)+gmin;
        load_cd = load_cd/(1+sqrt_ikr)+gmin*load_vd;
      end else begin
        load_gd = load_gd+gmin;
        load_cd = load_cd+gmin*load_vd;
      end
    end
    czero = DIOtJctCap;
    if (load_vd<DIOtDepCap) begin
      load_arg = 1-load_vd/DIOtJctPot;
      sarg = exp(-DIOtGradingCoeff*ln(load_arg));
      deplcharge = DIOtJctPot*czero*(1-load_arg*sarg)/(1-DIOtGradingCoeff);
      deplcap = czero*sarg;
    end else begin
      czof2 = czero/DIOtF2;
      deplcharge = czero*DIOtF1+czof2*(DIOtF3*(load_vd-DIOtDepCap)+DIOtGradingCoeff/(DIOtJctPot+DIOtJctPot)*(load_vd*load_vd-DIOtDepCap*DIOtDepCap));
      deplcap = czof2*(DIOtF3+DIOtGradingCoeff*load_vd/DIOtJctPot);
    end
    czeroSW = DIOtJctSWCap;
    if (load_vd<DIOtDepSWCap) begin
      argSW = 1-load_vd/DIOtJctSWPot;
      sargSW = exp(-mjsw*ln(argSW));
      deplchargeSW = DIOtJctSWPot*czeroSW*(1-argSW*sargSW)/(1-mjsw);
      deplcapSW = czeroSW*sargSW;
    end else begin
      czof2SW = czeroSW/DIOtF2SW;
      deplchargeSW = czeroSW*DIOtF1+czof2SW*(DIOtF3SW*(load_vd-DIOtDepSWCap)+mjsw/(DIOtJctSWPot+DIOtJctSWPot)*(load_vd*load_vd-DIOtDepSWCap*DIOtDepSWCap));
      deplcapSW = czof2SW*(DIOtF3SW+mjsw*load_vd/DIOtJctSWPot);
    end
    diffcharge = DIOtTransitTime*load_cd;
    DIOcapCharge = diffcharge+deplcharge+deplchargeSW;
    diffcap = DIOtTransitTime*load_gd;
    capd = diffcap+deplcap+deplcapSW+DIOcmetal+DIOcpoly;
    DIOcap = capd;
    geq = 0;
    DIOcapCurrent = ddt(DIOcapCharge);
    ceq = DIOcapCurrent;
    load_gd = load_gd+geq;
    DIOdcCurrent = load_cd;
    load_cd = load_cd+DIOcapCurrent;
    load_gd = load_gd + gmin * (1.0/$mfactor - 1);
    load_cd = load_cd + gmin * (1.0/$mfactor - 1) * load_vd;
    DIOvoltage = load_vd;
    DIOcurrent = load_cd;
    DIOconduct = load_gd;
    DIOdeltemp = delTemp;
    DIOdIdio_dT = dIdio_dT;
    cdeq = load_cd;
    
    // Residuals
    I(a) <+ gspr*V(a, a_int);
    I(c) <+ -cdeq;
    I(a_int) <+ gspr*V(a_int, a)+cdeq;

    // Tag: noise, function: DIOnoise
    if (DIOtempGiven) begin
      noise_dtemp = DIOtemp-$temperature+(DIOnomTemp-273.15);
    end else begin
      noise_dtemp = dtemp;
    end
    I(a_int, a) <+ white_noise(4*(VACONSTboltz*(($temperature+noise_dtemp)*DIOtConductance)), "rs");
    I(a_int, c) <+ white_noise(2*(VACONSTcharge*DIOcurrent), "id");
    I(a_int, c) <+ flicker_noise(kf*exp(af*ln(((abs(DIOcurrent)>1E-38) ? (abs(DIOcurrent)) : (1E-38)))), 1, "flicker");

    // Instance opvar computation
    vd = DIOvoltage;
    id = DIOcurrent;
    gd = DIOconduct;
    cd = DIOcap;
    charge = DIOcapCharge;
    capcur = DIOcapCurrent;
    p = DIOcurrent*DIOvoltage+DIOcurrent*DIOcurrent/DIOtConductance;

    // Model opvar computation

  end
endmodule
