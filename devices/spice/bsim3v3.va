// Model generated by Verilog-A Distiller.
// (c)2025 Arpad Buermen. All rights reserved.
// SPDX-License-Identifier: AGPL-3.0-or-later
// 
// SPICE flavour: ngspice
// Version      : ngspice-45-84-g7f75f09ec
// Origin       : https://sourceforge.net/u/arpadbuermen/ngspice/ci/vadng-pre-46/tree/
// Date         : 2025-11-21 10:57:45 UTC
// Module name  : sp_bsim3v3
// Model variant: default
// 
// Notes:
//   Parameter m was replaced with builtin Verilog-A parameter $mfactor.
//
//   All parameters and output variables refer to a single parallel instance,
//   even if $mfactor>1.
//
//   Parameter off was removed. Bypassing is not available in Verilog-A. 
//   
//   Device type is set by the type parameter to NMOS (1) or PMOS (-1). 
//   
//   Instance parameters nqsmod and acnqsmod renamed to instance_nqsmod and 
//   instance_acnqsmod. 
//   
//   Parameters ic, icvds, icvgs, and icvbs were removed. Initial conditions 
//   should be set via the simulator's initial conditions mechanism. 
//   
//   Parameters acnqsmod and instance_acnqsmod have no effect because 
//   Verilog-A does not provide frequency domain modelling for ac analysis. 
//   The NQS model always uses lumped approximation. Verilog-A provides 
//   $absdelay() which could model NQS effects in both time and frequency 
//   domain but is not supported by OpenVAF. Implementations of $absdelay() 
//   use a lot of memory for storing past samples, and are thus not 
//   appropriate for simulating circuits with many transistors.
//
//   Full noise model used (appropriate for all noise analyses).
//
// SPICE variable mapping
//   scale -> $simparam("scale", 1)
//
// CKTcircuit member mapping
//      CKTgmin -> ('gmin', '$simparam("gmin", 1e-12)')
//   CKTnomTemp -> ('tnom', '($simparam("tnom", 27)+273.15)')
//      CKTtemp -> (None, '$temperature')
//
// Source files and copyright information:
//   devsup.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//     Modified: 2000 AlansFixes
//   bsim3/bsim3def.h
//     Copyright 2004 Regents of the University of California.  All rights reserved.
//     Author: 1995 Min-Chie Jeng and Mansun Chan.
//     Author: 1997-1999 Weidong Liu.
//     Author: 2001- Xuemei Xi
//     **** OpenMP support for ngspice by Holger Vogt 06/28/2010 ****
//     File: bsim3def.h
//   bsim3/b3.c
//      * Copyright 2004 Regents of the University of California. All rights reserved.
//      * File: b3.c of BSIM3v3.3.0
//      * Author: 1995 Min-Chie Jeng and Mansun Chan
//      * Author: 1997-1999 Weidong Liu.
//      * Author: 2001  Xuemei Xi
//   bsim3/b3par.c
//      * Copyright 2004 Regents of the University of California. All rights reserved.
//      * File: b3par.c of BSIM3v3.3.0
//      * Author: 1995 Min-Chie Jeng and Mansun Chan
//      * Author: 1997-1999 Weidong Liu.
//      * Author: 2001 Xuemei Xi
//   bsim3/b3mpar.c
//      * Copyright 2004 Regents of the University of California. All rights reserved.
//      * File: b3mpar.c of BSIM3v3.3.0
//      * Author: 1995 Min-Chie Jeng and Mansun Chan. 
//      * Author: 1997-1999 Weidong Liu.
//      * Author: 2001  Xuemei Xi
//   bsim3/b3ask.c
//      * Copyright 2004 Regents of the University of California. All rights reserved.
//      * File: b3ask.c of BSIM3v3.3.0
//      * Author: 1995 Min-Chie Jeng and Mansun Chan
//      * Author: 1997-1999 Weidong Liu.
//      * Author: 2001  Xuemei Xi
//   bsim3/b3mask.c
//      * Copyright 2004 Regents of the University of California. All rights reserved.
//      * File: b3mask.c of BSIM3v3.3.0
//      * Author: 1995 Min-Chie Jeng and Mansun Chan.
//      * Author: 1997-1999 Weidong Liu.
//      * Author: 2001  Xuemei Xi
//   bsim3/b3set.c
//      * Copyright 2004 Regents of the University of California. All rights reserved.
//      * File: b3set.c of BSIM3v3.3.0
//      * Author: 1995 Min-Chie Jeng and Mansun Chan.
//      * Author: 1997-1999 Weidong Liu.
//      * Author: 2001  Xuemei Xi
//   bsim3/b3temp.c
//      * Copyright 2004 Regents of the University of California. All rights reserved.
//      * File: b3temp.c of BSIM3v3.3.0
//      * Author: 1995 Min-Chie Jeng and Mansun Chan.
//      * Author: 1997-1999 Weidong Liu.
//      * Author: 2001  Xuemei Xi
//   bsim3/b3ld.c
//      * Copyright 2004 Regents of the University of California. All rights reserved.
//      * File: b3ld.c of BSIM3v3.3.0
//      * Author: 1991 JianHui Huang and Min-Chie Jeng.
//      * Modified by Mansun Chan (1995).
//      * Author: 1997-1999 Weidong Liu.
//      * Author: 2001 Xuemei Xi
//      * Modified by Xuemei Xi, 10/05, 12/21, 2001.
//      * Modified by Xuemei Xi, 07/29/2005.
//   bsim3/b3noi.c
//      * Copyright 2004 Regents of the University of California. All rights reserved.
//      * File: b3noi.c of BSIM3v3.3.0
//      * Author: 1995 Gary W. Ng and Min-Chie Jeng.
//      * Author: 1997-1999 Weidong Liu.
//      * Author: 2001 Xuemei Xi
//      * Modified by Xuemei Xi, 10/05/2001.

`include "constants.vams"
`include "disciplines.vams"

module sp_bsim3v3(d, g, s, b);
  inout d, g, s, b;
  electrical d, g, s, b, d_int, s_int, q_int;

  // Instance parameters
  (* desc = "Length", type = "instance" *) parameter real l = 5e-06;
  (* desc = "Width", type = "instance" *) parameter real w = 5e-06;
  (* desc = "Drain area", type = "instance" *) parameter real ad = 0.0;
  (* desc = "Source area", type = "instance" *) parameter real as = 0.0;
  (* desc = "Drain perimeter", type = "instance" *) parameter real pd = 0.0;
  (* desc = "Source perimeter", type = "instance" *) parameter real ps = 0.0;
  (* desc = "Number of squares in drain", type = "instance" *) parameter real nrd = 0;
  (* desc = "Number of squares in source", type = "instance" *) parameter real nrs = 0;
  (* desc = "Non-quasi-static model selector", type = "instance" *) parameter integer instance_nqsmod = 0;
  (* desc = "AC NQS model selector", type = "instance" *) parameter integer instance_acnqsmod = 0;
  (* desc = "ACM model drain/source connection", type = "instance" *) parameter integer geo = 0;
  (* desc = "Zero bias threshold voltage variation", type = "instance" *) parameter real delvto = 0.0;
  (* desc = "Low field mobility multiplier", type = "instance" *) parameter real mulu0 = 1.0;

  // Model parameters
  (* desc = "Capacitance model selector" *) parameter integer capmod = 3;
  (* desc = "Mobility model selector" *) parameter integer mobmod = 1;
  (* desc = "Noise model selector" *) parameter integer noimod = 1;
  (* desc = "Non-quasi-static model selector" *) parameter integer nqsmod = 0;
  (* desc = "AC NQS model selector" *) parameter integer acnqsmod = 0;
  (* desc = "Area calculation method selector" *) parameter integer acm = 0;
  (* desc = "Area calculation method ACM=12" *) parameter integer calcacm = 0;
  (* desc = "Model parameter checking selector" *) parameter integer paramchk = 0;
  (* desc = "Bin  unit  selector" *) parameter integer binunit = 1;
  (* desc = "Gate oxide thickness in meters" *) parameter real tox = 1.5e-08;
  (* desc = "Gate oxide thickness used in extraction" *) parameter real toxm = 0;
  (* desc = "Drain/Source and channel coupling capacitance" *) parameter real cdsc = 0.00024;
  (* desc = "Body-bias dependence of cdsc" *) parameter real cdscb = 0.0;
  (* desc = "Drain-bias dependence of cdsc" *) parameter real cdscd = 0.0;
  (* desc = "Interface state capacitance" *) parameter real cit = 0.0;
  (* desc = "Subthreshold swing Coefficient" *) parameter real nfactor = 1;
  (* desc = "Junction depth in meters" *) parameter real xj = 1.5e-07;
  (* desc = "Saturation velocity at tnom" *) parameter real vsat = 80000.0;
  (* desc = "Temperature coefficient of vsat" *) parameter real at = 33000.0;
  (* desc = "Non-uniform depletion width effect coefficient." *) parameter real a0 = 1.0;
  (* desc = "Gate bias  coefficient of Abulk." *) parameter real ags = 0.0;
  (* desc = "Non-saturation effect coefficient" *) parameter real a1 = 0.0;
  (* desc = "Non-saturation effect coefficient" *) parameter real a2 = 1.0;
  (* desc = "Body-bias coefficient of non-uniform depletion width effect." *) parameter real keta = 0;
  (* desc = "Substrate doping concentration" *) parameter real nsub = 6e+16;
  (* desc = "Channel doping concentration" *) parameter real nch = 1.7e+17;
  (* desc = "Poly-gate doping concentration" *) parameter real ngate = 0;
  (* desc = "Vth body coefficient" *) parameter real gamma1 = 0;
  (* desc = "Vth body coefficient" *) parameter real gamma2 = 0;
  (* desc = "Vth transition body Voltage" *) parameter real vbx = 0;
  (* desc = "Maximum body voltage" *) parameter real vbm = 0;
  (* desc = "Doping depth" *) parameter real xt = 1.55e-07;
  (* desc = "Bulk effect coefficient 1" *) parameter real k1 = 0;
  (* desc = "Temperature coefficient of Vth" *) parameter real kt1 = 0;
  (* desc = "Temperature coefficient of Vth" *) parameter real kt1l = 0.0;
  (* desc = "Body-coefficient of kt1" *) parameter real kt2 = 0.022;
  (* desc = "Bulk effect coefficient 2" *) parameter real k2 = 0;
  (* desc = "Narrow width effect coefficient" *) parameter real k3 = 80.0;
  (* desc = "Body effect coefficient of k3" *) parameter real k3b = 0.0;
  (* desc = "Narrow width effect parameter" *) parameter real w0 = 2.5e-06;
  (* desc = "Lateral non-uniform doping effect" *) parameter real nlx = 1.74e-07;
  (* desc = "Short channel effect coeff. 0" *) parameter real dvt0 = 2.2;
  (* desc = "Short channel effect coeff. 1" *) parameter real dvt1 = 0.53;
  (* desc = "Short channel effect coeff. 2" *) parameter real dvt2 = 0;
  (* desc = "Narrow Width coeff. 0" *) parameter real dvt0w = 0.0;
  (* desc = "Narrow Width effect coeff. 1" *) parameter real dvt1w = 5300000.0;
  (* desc = "Narrow Width effect coeff. 2" *) parameter real dvt2w = 0;
  (* desc = "DIBL coefficient of output resistance" *) parameter real drout = 0.56;
  (* desc = "DIBL coefficient in the subthreshold region" *) parameter real dsub = 0;
  (* desc = "Threshold voltage" *) parameter real vth0 = 0;
  aliasparam vtho = vth0;
  (* desc = "Linear gate dependence of mobility" *) parameter real ua = 2.25e-09;
  (* desc = "Temperature coefficient of ua" *) parameter real ua1 = 4.31e-09;
  (* desc = "Quadratic gate dependence of mobility" *) parameter real ub = 5.87e-19;
  (* desc = "Temperature coefficient of ub" *) parameter real ub1 = 0;
  (* desc = "Body-bias dependence of mobility" *) parameter real uc = 0;
  (* desc = "Temperature coefficient of uc" *) parameter real uc1 = 0;
  (* desc = "Low-field mobility at Tnom" *) parameter real u0 = 0;
  (* desc = "Temperature coefficient of mobility" *) parameter real ute = 0;
  (* desc = "Threshold voltage offset" *) parameter real voff = 0;
  (* desc = "Parameter measurement temperature" *) parameter real tnom = 0;
  (* desc = "Gate-source overlap capacitance per width" *) parameter real cgso = 0;
  (* desc = "Gate-drain overlap capacitance per width" *) parameter real cgdo = 0;
  (* desc = "Gate-bulk overlap capacitance per length" *) parameter real cgbo = 0;
  (* desc = "Channel charge partitioning" *) parameter real xpart = 0.0;
  (* desc = "Non-quasi-static Elmore Constant Parameter" *) parameter real elm = 5.0;
  (* desc = "Effective Vds parameter" *) parameter real delta = 0.01;
  (* desc = "Source-drain sheet resistance" *) parameter real rsh = 0.0;
  (* desc = "Source-drain resistance per width" *) parameter real rdsw = 0;
  (* desc = "Gate-bias effect on parasitic resistance " *) parameter real prwg = 0.0;
  (* desc = "Body-effect on parasitic resistance " *) parameter real prwb = 0.0;
  (* desc = "Temperature coefficient of parasitic resistance " *) parameter real prt = 0.0;
  (* desc = "Subthreshold region DIBL coefficient" *) parameter real eta0 = 0.08;
  (* desc = "Subthreshold region DIBL coefficient" *) parameter real etab = 0;
  (* desc = "Channel length modulation Coefficient" *) parameter real pclm = 1.3;
  (* desc = "Drain-induced barrier lowering coefficient" *) parameter real pdiblc1 = 0.39;
  (* desc = "Drain-induced barrier lowering coefficient" *) parameter real pdiblc2 = 0.0086;
  (* desc = "Body-effect on drain-induced barrier lowering" *) parameter real pdiblcb = 0.0;
  (* desc = "Substrate current body-effect coefficient" *) parameter real pscbe1 = 424000000.0;
  (* desc = "Substrate current body-effect coefficient" *) parameter real pscbe2 = 1e-05;
  (* desc = "Gate dependence of output resistance parameter" *) parameter real pvag = 0.0;
  (* desc = "Source/drain junction reverse saturation current density" *) parameter real js = 0.0001;
  (* desc = "Sidewall junction reverse saturation current density" *) parameter real jsw = 0.0;
  (* desc = "Source/drain junction built-in potential" *) parameter real pb = 1.0;
  (* desc = "Source/drain junction emission coefficient" *) parameter real nj = 1.0;
  (* desc = "Junction current temperature exponent" *) parameter real xti = 3.0;
  (* desc = "Source/drain bottom junction capacitance grading coefficient" *) parameter real mj = 0.5;
  (* desc = "Source/drain sidewall junction capacitance built in potential" *) parameter real pbsw = 1.0;
  (* desc = "Source/drain sidewall junction capacitance grading coefficient" *) parameter real mjsw = 0.33;
  (* desc = "Source/drain (gate side) sidewall junction capacitance built in potential" *) parameter real pbswg = 0;
  (* desc = "Source/drain (gate side) sidewall junction capacitance grading coefficient" *) parameter real mjswg = 0;
  (* desc = "Source/drain bottom junction capacitance per unit area" *) parameter real cj = 0.0005;
  (* desc = "Flat Band Voltage parameter for capmod=0 only" *) parameter real vfbcv = 0;
  (* desc = "Flat Band Voltage" *) parameter real vfb = 0;
  (* desc = "Source/drain sidewall junction capacitance per unit periphery" *) parameter real cjsw = 5e-10;
  (* desc = "Source/drain (gate side) sidewall junction capacitance per unit width" *) parameter real cjswg = 0;
  (* desc = "Temperature coefficient of pb" *) parameter real tpb = 0.0;
  (* desc = "Temperature coefficient of cj" *) parameter real tcj = 0.0;
  (* desc = "Temperature coefficient of pbsw" *) parameter real tpbsw = 0.0;
  (* desc = "Temperature coefficient of cjsw" *) parameter real tcjsw = 0.0;
  (* desc = "Temperature coefficient of pbswg" *) parameter real tpbswg = 0.0;
  (* desc = "Temperature coefficient of cjswg" *) parameter real tcjswg = 0.0;
  (* desc = "Exponential coefficient for finite charge thickness" *) parameter real acde = 1.0;
  (* desc = "Coefficient for gate-bias dependent surface potential" *) parameter real moin = 15.0;
  (* desc = "C-V turn-on/off parameter" *) parameter real noff = 1.0;
  (* desc = "C-V lateral-shift parameter" *) parameter real voffcv = 0.0;
  (* desc = "lint offset for noise calculation" *) parameter real lintnoi = 0.0;
  (* desc = "Length reduction parameter" *) parameter real lint = 0.0;
  (* desc = "Length reduction parameter" *) parameter real ll = 0.0;
  (* desc = "Length reduction parameter for CV" *) parameter real llc = 0;
  (* desc = "Length reduction parameter" *) parameter real lln = 1.0;
  (* desc = "Length reduction parameter" *) parameter real lw = 0.0;
  (* desc = "Length reduction parameter for CV" *) parameter real lwc = 0;
  (* desc = "Length reduction parameter" *) parameter real lwn = 1.0;
  (* desc = "Length reduction parameter" *) parameter real lwl = 0.0;
  (* desc = "Length reduction parameter for CV" *) parameter real lwlc = 0;
  (* desc = "Minimum length for the model" *) parameter real lmin = 0.0;
  (* desc = "Maximum length for the model" *) parameter real lmax = 1.0;
  (* desc = "Length correction parameter" *) parameter real xl = 0.0;
  (* desc = "Width correction parameter" *) parameter real xw = 0.0;
  (* desc = "Width dependence of rds" *) parameter real wr = 1.0;
  (* desc = "Width reduction parameter" *) parameter real wint = 0.0;
  (* desc = "Width reduction parameter" *) parameter real dwg = 0.0;
  (* desc = "Width reduction parameter" *) parameter real dwb = 0.0;
  (* desc = "Width reduction parameter" *) parameter real wl = 0.0;
  (* desc = "Width reduction parameter for CV" *) parameter real wlc = 0;
  (* desc = "Width reduction parameter" *) parameter real wln = 1.0;
  (* desc = "Width reduction parameter" *) parameter real ww = 0.0;
  (* desc = "Width reduction parameter for CV" *) parameter real wwc = 0;
  (* desc = "Width reduction parameter" *) parameter real wwn = 1.0;
  (* desc = "Width reduction parameter" *) parameter real wwl = 0.0;
  (* desc = "Width reduction parameter for CV" *) parameter real wwlc = 0;
  (* desc = "Minimum width for the model" *) parameter real wmin = 0.0;
  (* desc = "Maximum width for the model" *) parameter real wmax = 1.0;
  (* desc = "Abulk narrow width parameter" *) parameter real b0 = 0.0;
  (* desc = "Abulk narrow width parameter" *) parameter real b1 = 0.0;
  (* desc = "New C-V model parameter" *) parameter real cgsl = 0.0;
  (* desc = "New C-V model parameter" *) parameter real cgdl = 0.0;
  (* desc = "New C-V model parameter" *) parameter real ckappa = 0.6;
  (* desc = "Fringe capacitance parameter" *) parameter real cf = 0;
  (* desc = "Vdsat parameter for C-V model" *) parameter real clc = 1e-07;
  (* desc = "Vdsat parameter for C-V model" *) parameter real cle = 0.6;
  (* desc = "Delta W for C-V model" *) parameter real dwc = 0;
  (* desc = "Delta L for C-V model" *) parameter real dlc = 0;
  (* desc = "ACM Parameter: Distance Gate - contact" *) parameter real hdif = 0.0;
  (* desc = "ACM Parameter: Length of LDD Gate-Source/Drain" *) parameter real ldif = 0.0;
  (* desc = "ACM Parameter: Length of LDD under Gate" *) parameter real ld = 0.0;
  (* desc = "ACM Parameter: Resistance of LDD drain side" *) parameter real rd = 0.0;
  (* desc = "ACM Parameter: Resistance of LDD source side" *) parameter real rs = 0.0;
  (* desc = "ACM Parameter: Resistance contact drain side" *) parameter real rdc = 0.0;
  (* desc = "ACM Parameter: Resistance contact source side" *) parameter real rsc = 0.0;
  (* desc = "ACM Parameter: Width shrink factor" *) parameter real wmlt = 1.0;
  (* desc = "substrate current model parameter" *) parameter real alpha0 = 0.0;
  (* desc = "substrate current model parameter" *) parameter real alpha1 = 0.0;
  (* desc = "substrate current model parameter" *) parameter real beta0 = 30.0;
  (* desc = "Diode limiting current" *) parameter real ijth = 0.1;
  (* desc = "Length dependence of cdsc" *) parameter real lcdsc = 0.0;
  (* desc = "Length dependence of cdscb" *) parameter real lcdscb = 0.0;
  (* desc = "Length dependence of cdscd" *) parameter real lcdscd = 0.0;
  (* desc = "Length dependence of cit" *) parameter real lcit = 0.0;
  (* desc = "Length dependence of nfactor" *) parameter real lnfactor = 0.0;
  (* desc = "Length dependence of xj" *) parameter real lxj = 0.0;
  (* desc = "Length dependence of vsat" *) parameter real lvsat = 0.0;
  (* desc = "Length dependence of at" *) parameter real lat = 0.0;
  (* desc = "Length dependence of a0" *) parameter real la0 = 0.0;
  (* desc = "Length dependence of ags" *) parameter real lags = 0.0;
  (* desc = "Length dependence of a1" *) parameter real la1 = 0.0;
  (* desc = "Length dependence of a2" *) parameter real la2 = 0.0;
  (* desc = "Length dependence of keta" *) parameter real lketa = 0.0;
  (* desc = "Length dependence of nsub" *) parameter real lnsub = 0.0;
  (* desc = "Length dependence of nch" *) parameter real lnch = 0.0;
  (* desc = "Length dependence of ngate" *) parameter real lngate = 0.0;
  (* desc = "Length dependence of gamma1" *) parameter real lgamma1 = 0;
  (* desc = "Length dependence of gamma2" *) parameter real lgamma2 = 0;
  (* desc = "Length dependence of vbx" *) parameter real lvbx = 0;
  (* desc = "Length dependence of vbm" *) parameter real lvbm = 0.0;
  (* desc = "Length dependence of xt" *) parameter real lxt = 0.0;
  (* desc = "Length dependence of k1" *) parameter real lk1 = 0;
  (* desc = "Length dependence of kt1" *) parameter real lkt1 = 0.0;
  (* desc = "Length dependence of kt1l" *) parameter real lkt1l = 0.0;
  (* desc = "Length dependence of kt2" *) parameter real lkt2 = 0.0;
  (* desc = "Length dependence of k2" *) parameter real lk2 = 0;
  (* desc = "Length dependence of k3" *) parameter real lk3 = 0.0;
  (* desc = "Length dependence of k3b" *) parameter real lk3b = 0.0;
  (* desc = "Length dependence of w0" *) parameter real lw0 = 0.0;
  (* desc = "Length dependence of nlx" *) parameter real lnlx = 0.0;
  (* desc = "Length dependence of dvt0" *) parameter real ldvt0 = 0.0;
  (* desc = "Length dependence of dvt1" *) parameter real ldvt1 = 0.0;
  (* desc = "Length dependence of dvt2" *) parameter real ldvt2 = 0.0;
  (* desc = "Length dependence of dvt0w" *) parameter real ldvt0w = 0.0;
  (* desc = "Length dependence of dvt1w" *) parameter real ldvt1w = 0.0;
  (* desc = "Length dependence of dvt2w" *) parameter real ldvt2w = 0.0;
  (* desc = "Length dependence of drout" *) parameter real ldrout = 0.0;
  (* desc = "Length dependence of dsub" *) parameter real ldsub = 0.0;
  (* desc = "Length dependence of vth0" *) parameter real lvth0 = 0.0;
  aliasparam lvtho = lvth0;
  (* desc = "Length dependence of ua" *) parameter real lua = 0.0;
  (* desc = "Length dependence of ua1" *) parameter real lua1 = 0.0;
  (* desc = "Length dependence of ub" *) parameter real lub = 0.0;
  (* desc = "Length dependence of ub1" *) parameter real lub1 = 0.0;
  (* desc = "Length dependence of uc" *) parameter real luc = 0.0;
  (* desc = "Length dependence of uc1" *) parameter real luc1 = 0.0;
  (* desc = "Length dependence of u0" *) parameter real lu0 = 0.0;
  (* desc = "Length dependence of ute" *) parameter real lute = 0.0;
  (* desc = "Length dependence of voff" *) parameter real lvoff = 0.0;
  (* desc = "Length dependence of elm" *) parameter real lelm = 0.0;
  (* desc = "Length dependence of delta" *) parameter real ldelta = 0.0;
  (* desc = "Length dependence of rdsw " *) parameter real lrdsw = 0.0;
  (* desc = "Length dependence of prwg " *) parameter real lprwg = 0.0;
  (* desc = "Length dependence of prwb " *) parameter real lprwb = 0.0;
  (* desc = "Length dependence of prt " *) parameter real lprt = 0.0;
  (* desc = "Length dependence of eta0" *) parameter real leta0 = 0.0;
  (* desc = "Length dependence of etab" *) parameter real letab = 0;
  (* desc = "Length dependence of pclm" *) parameter real lpclm = 0.0;
  (* desc = "Length dependence of pdiblc1" *) parameter real lpdiblc1 = 0.0;
  (* desc = "Length dependence of pdiblc2" *) parameter real lpdiblc2 = 0.0;
  (* desc = "Length dependence of pdiblcb" *) parameter real lpdiblcb = 0.0;
  (* desc = "Length dependence of pscbe1" *) parameter real lpscbe1 = 0.0;
  (* desc = "Length dependence of pscbe2" *) parameter real lpscbe2 = 0.0;
  (* desc = "Length dependence of pvag" *) parameter real lpvag = 0.0;
  (* desc = "Length dependence of wr" *) parameter real lwr = 0.0;
  (* desc = "Length dependence of dwg" *) parameter real ldwg = 0.0;
  (* desc = "Length dependence of dwb" *) parameter real ldwb = 0.0;
  (* desc = "Length dependence of b0" *) parameter real lb0 = 0.0;
  (* desc = "Length dependence of b1" *) parameter real lb1 = 0.0;
  (* desc = "Length dependence of cgsl" *) parameter real lcgsl = 0.0;
  (* desc = "Length dependence of cgdl" *) parameter real lcgdl = 0.0;
  (* desc = "Length dependence of ckappa" *) parameter real lckappa = 0.0;
  (* desc = "Length dependence of cf" *) parameter real lcf = 0.0;
  (* desc = "Length dependence of clc" *) parameter real lclc = 0.0;
  (* desc = "Length dependence of cle" *) parameter real lcle = 0.0;
  (* desc = "Length dependence of alpha0" *) parameter real lalpha0 = 0.0;
  (* desc = "Length dependence of alpha1" *) parameter real lalpha1 = 0.0;
  (* desc = "Length dependence of beta0" *) parameter real lbeta0 = 0.0;
  (* desc = "Length dependence of vfbcv" *) parameter real lvfbcv = 0.0;
  (* desc = "Length dependence of vfb" *) parameter real lvfb = 0.0;
  (* desc = "Length dependence of acde" *) parameter real lacde = 0.0;
  (* desc = "Length dependence of moin" *) parameter real lmoin = 0.0;
  (* desc = "Length dependence of noff" *) parameter real lnoff = 0.0;
  (* desc = "Length dependence of voffcv" *) parameter real lvoffcv = 0.0;
  (* desc = "Width dependence of cdsc" *) parameter real wcdsc = 0.0;
  (* desc = "Width dependence of cdscb" *) parameter real wcdscb = 0.0;
  (* desc = "Width dependence of cdscd" *) parameter real wcdscd = 0.0;
  (* desc = "Width dependence of cit" *) parameter real wcit = 0.0;
  (* desc = "Width dependence of nfactor" *) parameter real wnfactor = 0.0;
  (* desc = "Width dependence of xj" *) parameter real wxj = 0.0;
  (* desc = "Width dependence of vsat" *) parameter real wvsat = 0.0;
  (* desc = "Width dependence of at" *) parameter real wat = 0.0;
  (* desc = "Width dependence of a0" *) parameter real wa0 = 0.0;
  (* desc = "Width dependence of ags" *) parameter real wags = 0.0;
  (* desc = "Width dependence of a1" *) parameter real wa1 = 0.0;
  (* desc = "Width dependence of a2" *) parameter real wa2 = 0.0;
  (* desc = "Width dependence of keta" *) parameter real wketa = 0.0;
  (* desc = "Width dependence of nsub" *) parameter real wnsub = 0.0;
  (* desc = "Width dependence of nch" *) parameter real wnch = 0.0;
  (* desc = "Width dependence of ngate" *) parameter real wngate = 0.0;
  (* desc = "Width dependence of gamma1" *) parameter real wgamma1 = 0;
  (* desc = "Width dependence of gamma2" *) parameter real wgamma2 = 0;
  (* desc = "Width dependence of vbx" *) parameter real wvbx = 0;
  (* desc = "Width dependence of vbm" *) parameter real wvbm = 0.0;
  (* desc = "Width dependence of xt" *) parameter real wxt = 0.0;
  (* desc = "Width dependence of k1" *) parameter real wk1 = 0;
  (* desc = "Width dependence of kt1" *) parameter real wkt1 = 0.0;
  (* desc = "Width dependence of kt1l" *) parameter real wkt1l = 0.0;
  (* desc = "Width dependence of kt2" *) parameter real wkt2 = 0.0;
  (* desc = "Width dependence of k2" *) parameter real wk2 = 0;
  (* desc = "Width dependence of k3" *) parameter real wk3 = 0.0;
  (* desc = "Width dependence of k3b" *) parameter real wk3b = 0.0;
  (* desc = "Width dependence of w0" *) parameter real ww0 = 0.0;
  (* desc = "Width dependence of nlx" *) parameter real wnlx = 0.0;
  (* desc = "Width dependence of dvt0" *) parameter real wdvt0 = 0.0;
  (* desc = "Width dependence of dvt1" *) parameter real wdvt1 = 0.0;
  (* desc = "Width dependence of dvt2" *) parameter real wdvt2 = 0.0;
  (* desc = "Width dependence of dvt0w" *) parameter real wdvt0w = 0.0;
  (* desc = "Width dependence of dvt1w" *) parameter real wdvt1w = 0.0;
  (* desc = "Width dependence of dvt2w" *) parameter real wdvt2w = 0.0;
  (* desc = "Width dependence of drout" *) parameter real wdrout = 0.0;
  (* desc = "Width dependence of dsub" *) parameter real wdsub = 0.0;
  (* desc = "Width dependence of vth0" *) parameter real wvth0 = 0.0;
  aliasparam wvtho = wvth0;
  (* desc = "Width dependence of ua" *) parameter real wua = 0.0;
  (* desc = "Width dependence of ua1" *) parameter real wua1 = 0.0;
  (* desc = "Width dependence of ub" *) parameter real wub = 0.0;
  (* desc = "Width dependence of ub1" *) parameter real wub1 = 0.0;
  (* desc = "Width dependence of uc" *) parameter real wuc = 0.0;
  (* desc = "Width dependence of uc1" *) parameter real wuc1 = 0.0;
  (* desc = "Width dependence of u0" *) parameter real wu0 = 0.0;
  (* desc = "Width dependence of ute" *) parameter real wute = 0.0;
  (* desc = "Width dependence of voff" *) parameter real wvoff = 0.0;
  (* desc = "Width dependence of elm" *) parameter real welm = 0.0;
  (* desc = "Width dependence of delta" *) parameter real wdelta = 0.0;
  (* desc = "Width dependence of rdsw " *) parameter real wrdsw = 0.0;
  (* desc = "Width dependence of prwg " *) parameter real wprwg = 0.0;
  (* desc = "Width dependence of prwb " *) parameter real wprwb = 0.0;
  (* desc = "Width dependence of prt" *) parameter real wprt = 0.0;
  (* desc = "Width dependence of eta0" *) parameter real weta0 = 0.0;
  (* desc = "Width dependence of etab" *) parameter real wetab = 0.0;
  (* desc = "Width dependence of pclm" *) parameter real wpclm = 0.0;
  (* desc = "Width dependence of pdiblc1" *) parameter real wpdiblc1 = 0.0;
  (* desc = "Width dependence of pdiblc2" *) parameter real wpdiblc2 = 0.0;
  (* desc = "Width dependence of pdiblcb" *) parameter real wpdiblcb = 0.0;
  (* desc = "Width dependence of pscbe1" *) parameter real wpscbe1 = 0.0;
  (* desc = "Width dependence of pscbe2" *) parameter real wpscbe2 = 0.0;
  (* desc = "Width dependence of pvag" *) parameter real wpvag = 0.0;
  (* desc = "Width dependence of wr" *) parameter real wwr = 0.0;
  (* desc = "Width dependence of dwg" *) parameter real wdwg = 0.0;
  (* desc = "Width dependence of dwb" *) parameter real wdwb = 0.0;
  (* desc = "Width dependence of b0" *) parameter real wb0 = 0.0;
  (* desc = "Width dependence of b1" *) parameter real wb1 = 0.0;
  (* desc = "Width dependence of cgsl" *) parameter real wcgsl = 0.0;
  (* desc = "Width dependence of cgdl" *) parameter real wcgdl = 0.0;
  (* desc = "Width dependence of ckappa" *) parameter real wckappa = 0.0;
  (* desc = "Width dependence of cf" *) parameter real wcf = 0.0;
  (* desc = "Width dependence of clc" *) parameter real wclc = 0.0;
  (* desc = "Width dependence of cle" *) parameter real wcle = 0.0;
  (* desc = "Width dependence of alpha0" *) parameter real walpha0 = 0.0;
  (* desc = "Width dependence of alpha1" *) parameter real walpha1 = 0.0;
  (* desc = "Width dependence of beta0" *) parameter real wbeta0 = 0.0;
  (* desc = "Width dependence of vfbcv" *) parameter real wvfbcv = 0.0;
  (* desc = "Width dependence of vfb" *) parameter real wvfb = 0.0;
  (* desc = "Width dependence of acde" *) parameter real wacde = 0.0;
  (* desc = "Width dependence of moin" *) parameter real wmoin = 0.0;
  (* desc = "Width dependence of noff" *) parameter real wnoff = 0.0;
  (* desc = "Width dependence of voffcv" *) parameter real wvoffcv = 0.0;
  (* desc = "Cross-term dependence of cdsc" *) parameter real pcdsc = 0.0;
  (* desc = "Cross-term dependence of cdscb" *) parameter real pcdscb = 0.0;
  (* desc = "Cross-term dependence of cdscd" *) parameter real pcdscd = 0.0;
  (* desc = "Cross-term dependence of cit" *) parameter real pcit = 0.0;
  (* desc = "Cross-term dependence of nfactor" *) parameter real pnfactor = 0.0;
  (* desc = "Cross-term dependence of xj" *) parameter real pxj = 0.0;
  (* desc = "Cross-term dependence of vsat" *) parameter real pvsat = 0.0;
  (* desc = "Cross-term dependence of at" *) parameter real pat = 0.0;
  (* desc = "Cross-term dependence of a0" *) parameter real pa0 = 0.0;
  (* desc = "Cross-term dependence of ags" *) parameter real pags = 0.0;
  (* desc = "Cross-term dependence of a1" *) parameter real pa1 = 0.0;
  (* desc = "Cross-term dependence of a2" *) parameter real pa2 = 0.0;
  (* desc = "Cross-term dependence of keta" *) parameter real pketa = 0.0;
  (* desc = "Cross-term dependence of nsub" *) parameter real pnsub = 0.0;
  (* desc = "Cross-term dependence of nch" *) parameter real pnch = 0.0;
  (* desc = "Cross-term dependence of ngate" *) parameter real pngate = 0.0;
  (* desc = "Cross-term dependence of gamma1" *) parameter real pgamma1 = 0;
  (* desc = "Cross-term dependence of gamma2" *) parameter real pgamma2 = 0;
  (* desc = "Cross-term dependence of vbx" *) parameter real pvbx = 0;
  (* desc = "Cross-term dependence of vbm" *) parameter real pvbm = 0.0;
  (* desc = "Cross-term dependence of xt" *) parameter real pxt = 0.0;
  (* desc = "Cross-term dependence of k1" *) parameter real pk1 = 0;
  (* desc = "Cross-term dependence of kt1" *) parameter real pkt1 = 0.0;
  (* desc = "Cross-term dependence of kt1l" *) parameter real pkt1l = 0.0;
  (* desc = "Cross-term dependence of kt2" *) parameter real pkt2 = 0.0;
  (* desc = "Cross-term dependence of k2" *) parameter real pk2 = 0;
  (* desc = "Cross-term dependence of k3" *) parameter real pk3 = 0.0;
  (* desc = "Cross-term dependence of k3b" *) parameter real pk3b = 0.0;
  (* desc = "Cross-term dependence of w0" *) parameter real pw0 = 0.0;
  (* desc = "Cross-term dependence of nlx" *) parameter real pnlx = 0.0;
  (* desc = "Cross-term dependence of dvt0" *) parameter real pdvt0 = 0.0;
  (* desc = "Cross-term dependence of dvt1" *) parameter real pdvt1 = 0.0;
  (* desc = "Cross-term dependence of dvt2" *) parameter real pdvt2 = 0.0;
  (* desc = "Cross-term dependence of dvt0w" *) parameter real pdvt0w = 0.0;
  (* desc = "Cross-term dependence of dvt1w" *) parameter real pdvt1w = 0.0;
  (* desc = "Cross-term dependence of dvt2w" *) parameter real pdvt2w = 0.0;
  (* desc = "Cross-term dependence of drout" *) parameter real pdrout = 0.0;
  (* desc = "Cross-term dependence of dsub" *) parameter real pdsub = 0.0;
  (* desc = "Cross-term dependence of vth0" *) parameter real pvth0 = 0.0;
  aliasparam pvtho = pvth0;
  (* desc = "Cross-term dependence of ua" *) parameter real pua = 0.0;
  (* desc = "Cross-term dependence of ua1" *) parameter real pua1 = 0.0;
  (* desc = "Cross-term dependence of ub" *) parameter real pub = 0.0;
  (* desc = "Cross-term dependence of ub1" *) parameter real pub1 = 0.0;
  (* desc = "Cross-term dependence of uc" *) parameter real puc = 0.0;
  (* desc = "Cross-term dependence of uc1" *) parameter real puc1 = 0.0;
  (* desc = "Cross-term dependence of u0" *) parameter real pu0 = 0.0;
  (* desc = "Cross-term dependence of ute" *) parameter real pute = 0.0;
  (* desc = "Cross-term dependence of voff" *) parameter real pvoff = 0.0;
  (* desc = "Cross-term dependence of elm" *) parameter real pelm = 0.0;
  (* desc = "Cross-term dependence of delta" *) parameter real pdelta = 0.0;
  (* desc = "Cross-term dependence of rdsw " *) parameter real prdsw = 0.0;
  (* desc = "Cross-term dependence of prwg " *) parameter real pprwg = 0.0;
  (* desc = "Cross-term dependence of prwb " *) parameter real pprwb = 0.0;
  (* desc = "Cross-term dependence of prt " *) parameter real pprt = 0.0;
  (* desc = "Cross-term dependence of eta0" *) parameter real peta0 = 0.0;
  (* desc = "Cross-term dependence of etab" *) parameter real petab = 0.0;
  (* desc = "Cross-term dependence of pclm" *) parameter real ppclm = 0.0;
  (* desc = "Cross-term dependence of pdiblc1" *) parameter real ppdiblc1 = 0.0;
  (* desc = "Cross-term dependence of pdiblc2" *) parameter real ppdiblc2 = 0.0;
  (* desc = "Cross-term dependence of pdiblcb" *) parameter real ppdiblcb = 0.0;
  (* desc = "Cross-term dependence of pscbe1" *) parameter real ppscbe1 = 0.0;
  (* desc = "Cross-term dependence of pscbe2" *) parameter real ppscbe2 = 0.0;
  (* desc = "Cross-term dependence of pvag" *) parameter real ppvag = 0.0;
  (* desc = "Cross-term dependence of wr" *) parameter real pwr = 0.0;
  (* desc = "Cross-term dependence of dwg" *) parameter real pdwg = 0.0;
  (* desc = "Cross-term dependence of dwb" *) parameter real pdwb = 0.0;
  (* desc = "Cross-term dependence of b0" *) parameter real pb0 = 0.0;
  (* desc = "Cross-term dependence of b1" *) parameter real pb1 = 0.0;
  (* desc = "Cross-term dependence of cgsl" *) parameter real pcgsl = 0.0;
  (* desc = "Cross-term dependence of cgdl" *) parameter real pcgdl = 0.0;
  (* desc = "Cross-term dependence of ckappa" *) parameter real pckappa = 0.0;
  (* desc = "Cross-term dependence of cf" *) parameter real pcf = 0.0;
  (* desc = "Cross-term dependence of clc" *) parameter real pclc = 0.0;
  (* desc = "Cross-term dependence of cle" *) parameter real pcle = 0.0;
  (* desc = "Cross-term dependence of alpha0" *) parameter real palpha0 = 0.0;
  (* desc = "Cross-term dependence of alpha1" *) parameter real palpha1 = 0.0;
  (* desc = "Cross-term dependence of beta0" *) parameter real pbeta0 = 0.0;
  (* desc = "Cross-term dependence of vfbcv" *) parameter real pvfbcv = 0.0;
  (* desc = "Cross-term dependence of vfb" *) parameter real pvfb = 0.0;
  (* desc = "Cross-term dependence of acde" *) parameter real pacde = 0.0;
  (* desc = "Cross-term dependence of moin" *) parameter real pmoin = 0.0;
  (* desc = "Cross-term dependence of noff" *) parameter real pnoff = 0.0;
  (* desc = "Cross-term dependence of voffcv" *) parameter real pvoffcv = 0.0;
  (* desc = "Flicker noise parameter" *) parameter real noia = 0;
  (* desc = "Flicker noise parameter" *) parameter real noib = 0;
  (* desc = "Flicker noise parameter" *) parameter real noic = 0;
  (* desc = "Flicker noise parameter" *) parameter real em = 41000000.0;
  (* desc = "Flicker noise frequency exponent" *) parameter real ef = 1.0;
  (* desc = "Flicker noise exponent" *) parameter real af = 1.0;
  (* desc = "Flicker noise coefficient" *) parameter real kf = 0.0;
  (* desc = "maximum voltage G-S branch" *) parameter real vgs_max = 1e+99;
  (* desc = "maximum voltage G-D branch" *) parameter real vgd_max = 1e+99;
  (* desc = "maximum voltage G-B branch" *) parameter real vgb_max = 1e+99;
  (* desc = "maximum voltage D-S branch" *) parameter real vds_max = 1e+99;
  (* desc = "maximum voltage B-S branch" *) parameter real vbs_max = 1e+99;
  (* desc = "maximum voltage B-D branch" *) parameter real vbd_max = 1e+99;
  (* desc = "maximum voltage G-S branch" *) parameter real vgsr_max = 1e+99;
  (* desc = "maximum voltage G-D branch" *) parameter real vgdr_max = 1e+99;
  (* desc = "maximum voltage G-B branch" *) parameter real vgbr_max = 1e+99;
  (* desc = "maximum voltage B-S branch" *) parameter real vbsr_max = 1e+99;
  (* desc = "maximum voltage B-D branch" *) parameter real vbdr_max = 1e+99;
  (* desc = "N-type (1) or P-type (-1)" *) parameter integer type = 1;

  // Instance output variables
  (* desc = "Gmb" *) real gmbs;
  (* desc = "Gm" *) real gm;
  (* desc = "Gds" *) real gds;
  (* desc = "Vdsat" *) real vdsat;
  (* desc = "Vth" *) real vth;
  (* desc = "Ids" *) real id;
  (* desc = "Vbs" *) real vbs;
  (* desc = "Vgs" *) real vgs;
  (* desc = "Vds" *) real vds;
  (* desc = "Ibd" *) real ibd;
  (* desc = "Ibs" *) real ibs;
  (* desc = "gbd" *) real gbd;
  (* desc = "gbs" *) real gbs;
  (* desc = "Qbulk" *) real qb;
  (* desc = "Qgate" *) real qg;
  (* desc = "Qdrain" *) real qd;
  (* desc = "Cggb" *) real cgg;
  (* desc = "Cgdb" *) real cgd;
  (* desc = "Cgsb" *) real cgs;
  (* desc = "Cdgb" *) real cdg;
  (* desc = "Cddb" *) real cdd;
  (* desc = "Cdsb" *) real cds;
  (* desc = "Cbgb" *) real cbg;
  (* desc = "Cbdb" *) real cbd;
  (* desc = "Cbsb" *) real cbs;
  (* desc = "Capbd" *) real capbd;
  (* desc = "Capbs" *) real capbs;

  // Model output variables

  // Instance fields
  real BSIM3ueff = 0;
  real BSIM3thetavth = 0;
  real BSIM3von = 0;
  real BSIM3vdsat = 0;
  real i_BSIM3cgdo = 0;
  real i_BSIM3cgso = 0;
  real BSIM3vjsm = 0;
  real BSIM3IsEvjsm = 0;
  real BSIM3vjdm = 0;
  real BSIM3IsEvjdm = 0;
  real BSIM3l = 0;
  real BSIM3w = 0;
  real BSIM3drainArea = 0;
  real BSIM3sourceArea = 0;
  real BSIM3drainSquares = 0;
  real BSIM3sourceSquares = 0;
  real BSIM3drainPerimeter = 0;
  real BSIM3sourcePerimeter = 0;
  real BSIM3sourceConductance = 0;
  real BSIM3drainConductance = 0;
  real i_BSIM3vth0 = 0;
  real i_BSIM3vfb = 0;
  real BSIM3vfbzb = 0;
  real BSIM3u0temp = 0;
  real BSIM3tconst = 0;
  integer BSIM3mode = 0;
  integer i_BSIM3nqsMod = 0;
  integer i_BSIM3acnqsMod = 0;
  real BSIM3qinv = 0;
  real BSIM3cd = 0;
  real BSIM3cbs = 0;
  real BSIM3cbd = 0;
  real BSIM3csub = 0;
  real BSIM3gm = 0;
  real BSIM3gds = 0;
  real BSIM3gmbs = 0;
  real BSIM3gbd = 0;
  real BSIM3gbs = 0;
  real BSIM3gbbs = 0;
  real BSIM3gbgs = 0;
  real BSIM3gbds = 0;
  real BSIM3cggb = 0;
  real BSIM3cgdb = 0;
  real BSIM3cgsb = 0;
  real BSIM3cbgb = 0;
  real BSIM3cbdb = 0;
  real BSIM3cbsb = 0;
  real BSIM3cdgb = 0;
  real BSIM3cddb = 0;
  real BSIM3cdsb = 0;
  real BSIM3capbd = 0;
  real BSIM3capbs = 0;
  real BSIM3cqgb = 0;
  real BSIM3cqdb = 0;
  real BSIM3cqsb = 0;
  real BSIM3cqbb = 0;
  real BSIM3qgate = 0;
  real BSIM3qbulk = 0;
  real BSIM3qdrn = 0;
  real BSIM3gtau = 0;
  real BSIM3gtg = 0;
  real BSIM3gtd = 0;
  real BSIM3gts = 0;
  real BSIM3gtb = 0;
  real BSIM3rds = 0;
  real BSIM3Vgsteff = 0;
  real BSIM3Vdseff = 0;
  real BSIM3Abulk = 0;
  real BSIM3AbovVgst2Vtm = 0;
  real BSIM3taunet = 0;
  integer BSIM3lGiven = 0;
  integer BSIM3wGiven = 0;
  integer BSIM3drainAreaGiven = 0;
  integer BSIM3sourceAreaGiven = 0;
  integer BSIM3drainPerimeterGiven = 0;
  integer BSIM3sourcePerimeterGiven = 0;

  // Model fields
  integer BSIM3nqsMod = 0;
  integer BSIM3acnqsMod = 0;
  real BSIM3toxm = 0;
  real BSIM3keta = 0;
  real BSIM3vbm = 0;
  real BSIM3kt1 = 0;
  real BSIM3dvt2 = 0;
  real BSIM3dvt2w = 0;
  real BSIM3dsub = 0;
  real BSIM3vth0 = 0;
  real BSIM3ub1 = 0;
  real BSIM3uc = 0;
  real BSIM3uc1 = 0;
  real BSIM3u0 = 0;
  real BSIM3ute = 0;
  real BSIM3voff = 0;
  real BSIM3etab = 0;
  real BSIM3cf = 0;
  real BSIM3vfbcv = 0;
  real BSIM3dwc = 0;
  real BSIM3dlc = 0;
  real BSIM3letab = 0;
  real BSIM3tnom = 0;
  real BSIM3cgso = 0;
  real BSIM3cgdo = 0;
  real BSIM3cgbo = 0;
  real BSIM3cFringOut = 0;
  real BSIM3cFringMax = 0;
  real BSIM3bulkJctPotential = 0;
  real BSIM3bulkJctGateSideGradingCoeff = 0;
  real BSIM3sidewallJctPotential = 0;
  real BSIM3GatesidewallJctPotential = 0;
  real BSIM3unitLengthGateSidewallJctCap = 0;
  real BSIM3Llc = 0;
  real BSIM3Lwc = 0;
  real BSIM3Lwlc = 0;
  real BSIM3Wlc = 0;
  real BSIM3Wwc = 0;
  real BSIM3Wwlc = 0;
  real BSIM3vtm = 0;
  real BSIM3cox = 0;
  real BSIM3cof1 = 0;
  real BSIM3cof2 = 0;
  real BSIM3cof3 = 0;
  real BSIM3cof4 = 0;
  real BSIM3vcrit = 0;
  real BSIM3factor1 = 0;
  real BSIM3PhiB = 0;
  real BSIM3PhiBSW = 0;
  real BSIM3PhiBSWG = 0;
  real BSIM3jctTempSatCurDensity = 0;
  real BSIM3jctSidewallTempSatCurDensity = 0;
  real BSIM3unitAreaTempJctCap = 0;
  real BSIM3unitLengthSidewallTempJctCap = 0;
  real BSIM3unitLengthGateSidewallTempJctCap = 0;
  real BSIM3oxideTrapDensityA = 0;
  real BSIM3oxideTrapDensityB = 0;
  real BSIM3oxideTrapDensityC = 0;
  integer BSIM3type = 0;
  integer BSIM3tnomGiven = 0;

  // Structure: size dependent parameters
  real Width = 0;
  real Length = 0;
  real sd_BSIM3cdsc = 0;
  real sd_BSIM3cdscb = 0;
  real sd_BSIM3cdscd = 0;
  real sd_BSIM3cit = 0;
  real sd_BSIM3nfactor = 0;
  real sd_BSIM3xj = 0;
  real sd_BSIM3vsat = 0;
  real sd_BSIM3at = 0;
  real sd_BSIM3a0 = 0;
  real sd_BSIM3ags = 0;
  real sd_BSIM3a1 = 0;
  real sd_BSIM3a2 = 0;
  real sd_BSIM3keta = 0;
  real sd_BSIM3nsub = 0;
  real sd_BSIM3npeak = 0;
  real sd_BSIM3ngate = 0;
  real sd_BSIM3gamma1 = 0;
  real sd_BSIM3gamma2 = 0;
  real sd_BSIM3vbx = 0;
  real BSIM3vbi = 0;
  real sd_BSIM3vbm = 0;
  real BSIM3vbsc = 0;
  real sd_BSIM3xt = 0;
  real BSIM3phi = 0;
  real BSIM3litl = 0;
  real sd_BSIM3k1 = 0;
  real sd_BSIM3kt1 = 0;
  real sd_BSIM3kt1l = 0;
  real sd_BSIM3kt2 = 0;
  real sd_BSIM3k2 = 0;
  real sd_BSIM3k3 = 0;
  real sd_BSIM3k3b = 0;
  real sd_BSIM3w0 = 0;
  real sd_BSIM3nlx = 0;
  real sd_BSIM3dvt0 = 0;
  real sd_BSIM3dvt1 = 0;
  real sd_BSIM3dvt2 = 0;
  real sd_BSIM3dvt0w = 0;
  real sd_BSIM3dvt1w = 0;
  real sd_BSIM3dvt2w = 0;
  real sd_BSIM3drout = 0;
  real sd_BSIM3dsub = 0;
  real sd_BSIM3vth0 = 0;
  real sd_BSIM3ua = 0;
  real sd_BSIM3ua1 = 0;
  real sd_BSIM3ub = 0;
  real sd_BSIM3ub1 = 0;
  real sd_BSIM3uc = 0;
  real sd_BSIM3uc1 = 0;
  real sd_BSIM3u0 = 0;
  real sd_BSIM3ute = 0;
  real sd_BSIM3voff = 0;
  real sd_BSIM3vfb = 0;
  real sd_BSIM3delta = 0;
  real sd_BSIM3rdsw = 0;
  real BSIM3rds0 = 0;
  real sd_BSIM3prwg = 0;
  real sd_BSIM3prwb = 0;
  real sd_BSIM3prt = 0;
  real sd_BSIM3eta0 = 0;
  real sd_BSIM3etab = 0;
  real sd_BSIM3pclm = 0;
  real sd_BSIM3pdibl1 = 0;
  real sd_BSIM3pdibl2 = 0;
  real sd_BSIM3pdiblb = 0;
  real sd_BSIM3pscbe1 = 0;
  real sd_BSIM3pscbe2 = 0;
  real sd_BSIM3pvag = 0;
  real sd_BSIM3wr = 0;
  real sd_BSIM3dwg = 0;
  real sd_BSIM3dwb = 0;
  real sd_BSIM3b0 = 0;
  real sd_BSIM3b1 = 0;
  real sd_BSIM3alpha0 = 0;
  real sd_BSIM3alpha1 = 0;
  real sd_BSIM3beta0 = 0;
  real sd_BSIM3elm = 0;
  real sd_BSIM3cgsl = 0;
  real sd_BSIM3cgdl = 0;
  real sd_BSIM3ckappa = 0;
  real sd_BSIM3cf = 0;
  real sd_BSIM3clc = 0;
  real sd_BSIM3cle = 0;
  real sd_BSIM3vfbcv = 0;
  real sd_BSIM3noff = 0;
  real sd_BSIM3voffcv = 0;
  real sd_BSIM3acde = 0;
  real sd_BSIM3moin = 0;
  real BSIM3dw = 0;
  real BSIM3dl = 0;
  real BSIM3leff = 0;
  real BSIM3weff = 0;
  real sd_BSIM3dwc = 0;
  real sd_BSIM3dlc = 0;
  real BSIM3leffCV = 0;
  real BSIM3weffCV = 0;
  real BSIM3abulkCVfactor = 0;
  real sd_BSIM3cgso = 0;
  real sd_BSIM3cgdo = 0;
  real sd_BSIM3cgbo = 0;
  real sd_BSIM3tconst = 0;
  real sd_BSIM3u0temp = 0;
  real BSIM3vsattemp = 0;
  real BSIM3sqrtPhi = 0;
  real BSIM3phis3 = 0;
  real BSIM3Xdep0 = 0;
  real BSIM3sqrtXdep0 = 0;
  real BSIM3theta0vb0 = 0;
  real BSIM3thetaRout = 0;
  real sd_BSIM3cof1 = 0;
  real sd_BSIM3cof2 = 0;
  real sd_BSIM3cof3 = 0;
  real sd_BSIM3cof4 = 0;
  real BSIM3cdep0 = 0;
  real sd_BSIM3vfbzb = 0;
  real BSIM3ldeb = 0;
  real BSIM3k1ox = 0;
  real BSIM3k2ox = 0;

  // States
  real BSIM3vbd = 0;
  real BSIM3vbs = 0;
  real BSIM3vgs = 0;
  real BSIM3vds = 0;
  real BSIM3qb = 0;
  real BSIM3cqb = 0;
  real BSIM3qg = 0;
  real BSIM3cqg = 0;
  real BSIM3qd = 0;
  real BSIM3cqd = 0;
  real BSIM3qbs = 0;
  real BSIM3qbd = 0;
  real BSIM3qcheq = 0;
  real BSIM3cqcheq = 0;
  real BSIM3qcdump = 0;
  real BSIM3cqcdump = 0;
  real BSIM3qdef = 0;

  // Model parameter access locals

  // Instance parameter access locals

  // Device setup locals
  real drainResistance = 0;
  real sourceResistance = 0;

  // Device temperature dependence locals
  real tmp = 0;
  real tmp1 = 0;
  real tmp2 = 0;
  real tmp3 = 0;
  real Eg = 0;
  real Eg0 = 0;
  real ni = 0;
  real T0 = 0;
  real T1 = 0;
  real T2 = 0;
  real T3 = 0;
  real T4 = 0;
  real T5 = 0;
  real Ldrn = 0;
  real Wdrn = 0;
  real delTemp = 0;
  real Temp = 0;
  real TRatio = 0;
  real Inv_L = 0;
  real Inv_W = 0;
  real Inv_LW = 0;
  real Vtm0 = 0;
  real Tnom = 0;
  real Nvtm = 0;
  real SourceSatCurrent = 0;
  real DrainSatCurrent = 0;
  integer error = 0;
  real temp_drainResistance = 0;
  real temp_sourceResistance = 0;

  // Device load locals
  integer limited = 0;
  real load_SourceSatCurrent = 0;
  real load_DrainSatCurrent = 0;
  real qgd = 0;
  real qgs = 0;
  real qgb = 0;
  real von = 0;
  real VgstNVt = 0;
  real ExpVgst = 0;
  real cdrain = 0;
  real cdreq = 0;
  real ceqbd = 0;
  real ceqbs = 0;
  real ceqqb = 0;
  real ceqqd = 0;
  real ceqqg = 0;
  real ceq = 0;
  real geq = 0;
  real czbd = 0;
  real czbdsw = 0;
  real czbdswg = 0;
  real czbs = 0;
  real czbssw = 0;
  real czbsswg = 0;
  real evbd = 0;
  real evbs = 0;
  real arg = 0;
  real sarg = 0;
  real delvbd = 0;
  real delvbs = 0;
  real Vfbeff = 0;
  real dVfbeff_dVg = 0;
  real dVfbeff_dVb = 0;
  real V3 = 0;
  real V4 = 0;
  real MJ = 0;
  real MJSW = 0;
  real MJSWG = 0;
  real vbd = 0;
  real load_vbs = 0;
  real load_vds = 0;
  real vgb = 0;
  real vgd = 0;
  real load_vgs = 0;
  real vgdo = 0;
  real qgate = 0;
  real qbulk = 0;
  real qdrn = 0;
  real qsrc = 0;
  real qinoi = 0;
  real cqgate = 0;
  real cqbulk = 0;
  real cqdrn = 0;
  real Vds = 0;
  real Vgs = 0;
  real Vbs = 0;
  real Gmbs = 0;
  real FwdSum = 0;
  real RevSum = 0;
  real Vgs_eff = 0;
  real Vfb = 0;
  real Phis = 0;
  real dPhis_dVb = 0;
  real sqrtPhis = 0;
  real dsqrtPhis_dVb = 0;
  real Vth = 0;
  real dVth_dVb = 0;
  real dVth_dVd = 0;
  real Vgst = 0;
  real dVgst_dVg = 0;
  real dVgst_dVb = 0;
  real dVgs_eff_dVg = 0;
  real load_Nvtm = 0;
  real Vtm = 0;
  real n = 0;
  real dn_dVb = 0;
  real dn_dVd = 0;
  real load_voffcv = 0;
  real load_noff = 0;
  real dnoff_dVd = 0;
  real dnoff_dVb = 0;
  real ExpArg = 0;
  real V0 = 0;
  real CoxWLcen = 0;
  real QovCox = 0;
  real LINK = 0;
  real DeltaPhi = 0;
  real dDeltaPhi_dVg = 0;
  real VgDP = 0;
  real dVgDP_dVg = 0;
  real Cox = 0;
  real Tox = 0;
  real Tcen = 0;
  real dTcen_dVg = 0;
  real dTcen_dVd = 0;
  real dTcen_dVb = 0;
  real Ccen = 0;
  real Coxeff = 0;
  real dCoxeff_dVg = 0;
  real dCoxeff_dVd = 0;
  real dCoxeff_dVb = 0;
  real Denomi = 0;
  real dDenomi_dVg = 0;
  real dDenomi_dVd = 0;
  real dDenomi_dVb = 0;
  real ueff = 0;
  real dueff_dVg = 0;
  real dueff_dVd = 0;
  real dueff_dVb = 0;
  real Esat = 0;
  real Vdsat = 0;
  real EsatL = 0;
  real dEsatL_dVg = 0;
  real dEsatL_dVd = 0;
  real dEsatL_dVb = 0;
  real dVdsat_dVg = 0;
  real dVdsat_dVb = 0;
  real dVdsat_dVd = 0;
  real Vasat = 0;
  real dAlphaz_dVg = 0;
  real dAlphaz_dVb = 0;
  real dVasat_dVg = 0;
  real dVasat_dVb = 0;
  real dVasat_dVd = 0;
  real Va = 0;
  real dVa_dVd = 0;
  real dVa_dVg = 0;
  real dVa_dVb = 0;
  real Vbseff = 0;
  real dVbseff_dVb = 0;
  real VbseffCV = 0;
  real dVbseffCV_dVb = 0;
  real Arg1 = 0;
  real One_Third_CoxWL = 0;
  real Two_Third_CoxWL = 0;
  real Alphaz = 0;
  real CoxWL = 0;
  real load_T0 = 0;
  real dT0_dVg = 0;
  real dT0_dVd = 0;
  real dT0_dVb = 0;
  real load_T1 = 0;
  real dT1_dVg = 0;
  real dT1_dVd = 0;
  real dT1_dVb = 0;
  real load_T2 = 0;
  real dT2_dVg = 0;
  real dT2_dVd = 0;
  real dT2_dVb = 0;
  real load_T3 = 0;
  real dT3_dVg = 0;
  real dT3_dVd = 0;
  real dT3_dVb = 0;
  real load_T4 = 0;
  real load_T5 = 0;
  real T6 = 0;
  real T7 = 0;
  real T8 = 0;
  real T9 = 0;
  real T10 = 0;
  real T11 = 0;
  real T12 = 0;
  real load_tmp = 0;
  real Abulk = 0;
  real dAbulk_dVb = 0;
  real Abulk0 = 0;
  real dAbulk0_dVb = 0;
  real VACLM = 0;
  real dVACLM_dVg = 0;
  real dVACLM_dVd = 0;
  real dVACLM_dVb = 0;
  real VADIBL = 0;
  real dVADIBL_dVg = 0;
  real dVADIBL_dVd = 0;
  real dVADIBL_dVb = 0;
  real Xdep = 0;
  real dXdep_dVb = 0;
  real lt1 = 0;
  real dlt1_dVb = 0;
  real ltw = 0;
  real dltw_dVb = 0;
  real Delt_vth = 0;
  real dDelt_vth_dVb = 0;
  real Theta0 = 0;
  real dTheta0_dVb = 0;
  real TempRatio = 0;
  real load_tmp1 = 0;
  real load_tmp2 = 0;
  real load_tmp3 = 0;
  real tmp4 = 0;
  real DIBL_Sft = 0;
  real dDIBL_Sft_dVd = 0;
  real Lambda = 0;
  real dLambda_dVg = 0;
  real load_a1 = 0;
  real ScalingFactor = 0;
  real Vgsteff = 0;
  real dVgsteff_dVg = 0;
  real dVgsteff_dVd = 0;
  real dVgsteff_dVb = 0;
  real Vdseff = 0;
  real dVdseff_dVg = 0;
  real dVdseff_dVd = 0;
  real dVdseff_dVb = 0;
  real VdseffCV = 0;
  real dVdseffCV_dVg = 0;
  real dVdseffCV_dVd = 0;
  real dVdseffCV_dVb = 0;
  real diffVds = 0;
  real dAbulk_dVg = 0;
  real beta = 0;
  real dbeta_dVg = 0;
  real dbeta_dVd = 0;
  real dbeta_dVb = 0;
  real gche = 0;
  real dgche_dVg = 0;
  real dgche_dVd = 0;
  real dgche_dVb = 0;
  real fgche1 = 0;
  real dfgche1_dVg = 0;
  real dfgche1_dVd = 0;
  real dfgche1_dVb = 0;
  real fgche2 = 0;
  real dfgche2_dVg = 0;
  real dfgche2_dVd = 0;
  real dfgche2_dVb = 0;
  real Idl = 0;
  real dIdl_dVg = 0;
  real dIdl_dVd = 0;
  real dIdl_dVb = 0;
  real Idsa = 0;
  real dIdsa_dVg = 0;
  real dIdsa_dVd = 0;
  real dIdsa_dVb = 0;
  real Ids = 0;
  real Gm = 0;
  real Gds = 0;
  real Gmb = 0;
  real Isub = 0;
  real Gbd = 0;
  real Gbg = 0;
  real Gbb = 0;
  real VASCBE = 0;
  real dVASCBE_dVg = 0;
  real dVASCBE_dVd = 0;
  real dVASCBE_dVb = 0;
  real CoxWovL = 0;
  real Rds = 0;
  real dRds_dVg = 0;
  real dRds_dVb = 0;
  real WVCox = 0;
  real WVCoxRds = 0;
  real Vgst2Vtm = 0;
  real VdsatCV = 0;
  real dVdsatCV_dVg = 0;
  real dVdsatCV_dVb = 0;
  real Leff = 0;
  real Weff = 0;
  real dWeff_dVg = 0;
  real dWeff_dVb = 0;
  real AbulkCV = 0;
  real dAbulkCV_dVb = 0;
  real qgdo = 0;
  real qgso = 0;
  real load_cgdo = 0;
  real load_cgso = 0;
  real qcheq = 0;
  real qdef = 0;
  real cqdef = 0;
  real cqcheq = 0;
  real gtau_diff = 0;
  real gtau_drift = 0;
  real dxpart = 0;
  real sxpart = 0;
  real ggtg = 0;
  real ggtd = 0;
  real ggts = 0;
  real ggtb = 0;
  real ddxpart_dVd = 0;
  real ddxpart_dVg = 0;
  real ddxpart_dVb = 0;
  real ddxpart_dVs = 0;
  real dsxpart_dVd = 0;
  real dsxpart_dVg = 0;
  real dsxpart_dVb = 0;
  real dsxpart_dVs = 0;
  real gbspsp = 0;
  real gbbdp = 0;
  real gbbsp = 0;
  real gbspg = 0;
  real gbspb = 0;
  real gbspdp = 0;
  real gbdpdp = 0;
  real gbdpg = 0;
  real gbdpb = 0;
  real gbdpsp = 0;
  real Cgg = 0;
  real Cgd = 0;
  real Cgb = 0;
  real Cdg = 0;
  real Cdd = 0;
  real Cds = 0;
  real Csg = 0;
  real Csd = 0;
  real Css = 0;
  real Csb = 0;
  real Cbg = 0;
  real Cbd = 0;
  real Cbb = 0;
  real Cgg1 = 0;
  real Cgb1 = 0;
  real Cgd1 = 0;
  real Cbg1 = 0;
  real Cbb1 = 0;
  real Cbd1 = 0;
  real Qac0 = 0;
  real Qsub0 = 0;
  real dQac0_dVg = 0;
  real dQac0_dVb = 0;
  real dQsub0_dVg = 0;
  real dQsub0_dVd = 0;
  real dQsub0_dVb = 0;

  // Device noise locals
  real noise_vds = 0;
  real noise_T1 = 0;
  real noise_T10 = 0;
  real noise_T11 = 0;
  real Ssi = 0;
  real Swi = 0;
  real cd = 0;
  real esat = 0;
  real DelClm = 0;
  real N0 = 0;
  real Nl = 0;
  real noise_Leff = 0;
  real Leffsq = 0;
  real noise_T0 = 0;
  real noise1_T1 = 0;
  real noise_T2 = 0;
  real noise_T3 = 0;
  real noise_T4 = 0;
  real noise_T5 = 0;
  real noise_T6 = 0;
  real noise_T7 = 0;
  real noise_T8 = 0;
  real noise_T9 = 0;
  real noise1_Ssi = 0;
  real sne_retval = 0;
  real flicker_psd = 0;
  real flicker_exp = 1;

  // Global constants
  real CONSTroot2 = sqrt(2.0);
  real CONSTvt0 = 1.38064852e-23*(27+273.15)/1.6021766208e-19;
  real CONSTKoverQ = 1.38064852e-23/1.6021766208e-19;
  real CONSTe = exp(1.0);
  real VACONSTcharge = 1.6021766208e-19;
  real VACONSTboltz = 1.38064852e-23;
  real VACONST_tnom = ($simparam("tnom", 27)+273.15);
  real cpscale = $simparam("scale", 1);

  // Evaluation constants
  real lc_gmin = 0;

  // Translated function definitions
  analog function integer ACM_SourceDrainResistances;
    input ACM, LD, LDIF, HDIF, WMLT, w, XW, RSH, drainSquaresGiven, RD, RDC, drainSquares, sourceSquaresGiven, RS, RSC, sourceSquares;
    inout drainResistance, sourceResistance;
    integer ACM;
    real LD;
    real LDIF;
    real HDIF;
    real WMLT;
    real w;
    real XW;
    real RSH;
    integer drainSquaresGiven;
    real RD;
    real RDC;
    real drainSquares;
    integer sourceSquaresGiven;
    real RS;
    real RSC;
    real sourceSquares;
    real drainResistance;
    real sourceResistance;
    begin
      case (ACM)
        1, 
        11: begin
          drainResistance = (LD+LDIF)/(w*WMLT+XW)*RD+RSH*drainSquares+RDC;
          sourceResistance = (LD+LDIF)/(w*WMLT+XW)*RS+RSH*sourceSquares+RSC;
        end
        2, 
        12, 
        3, 
        13: begin
          if (drainSquaresGiven) begin
            drainResistance = (LD+LDIF)/(w*WMLT+XW)*RD+RSH*drainSquares+RDC;
          end else begin
            drainResistance = ((LD+LDIF)*RD+HDIF*WMLT*RSH)/(w*WMLT+XW)+RDC;
          end
          if (sourceSquaresGiven) begin
            sourceResistance = (LD+LDIF)/(w*WMLT+XW)*RS+RSH*sourceSquares+RSC;
          end else begin
            sourceResistance = ((LD+LDIF)*RS+HDIF*WMLT*RSH)/(w*WMLT+XW)+RSC;
          end
        end
      endcase

      ACM_SourceDrainResistances = 0;
    end
  endfunction

  // Verbatim analog functions
  analog function integer initialize_limiting;
    integer il;
    begin
      il = $simparam("iniLim", -1);
      if (il<0) begin
        // iniLim not available, use heuristics
        initialize_limiting = 
          $simparam("iteration", 10)==1 && 
          (analysis("dc") || analysis("static")) && 
          analysis("nodeset");
      end else begin
        initialize_limiting = il;
      end
    end
  endfunction

  analog function real DEVlimitOldGet;
    input vnew, vold;
    real vnew, vold, result;
    begin
      DEVlimitOldGet = vold;
    end
  endfunction

  analog function real DEVlimitNewSet;
    input vnew, vold, new_value, limited;
    real vnew, vold, new_value;
    integer limited;
    begin
      DEVlimitNewSet = new_value;
      if (limited) begin
        $discontinuity(-1);
      end
    end
  endfunction

  analog function real DEVpnjlim;
    input vnew, vold, vt, vcrit;
    inout limiting_applied;
    real vnew, vold, vt, vcrit, limited, arg;
    integer limiting_applied;
    
    begin
      limited = vnew;
      if ((vnew > vcrit) && (abs(vnew - vold) > (vt + vt))) begin
        // Positive vnew above vcrit, change greater than 2*vt
        if(vold > 0) begin
          arg = (vnew - vold) / vt;
          if(arg > 0) begin
            limited = vold + vt * ln(1+arg);
            limiting_applied = 1;
          end else begin
            limited = vold - vt * ln(1-arg);
            limiting_applied = 1;
          end
        end else begin
          limited = vt *ln(vnew/vt);
          limiting_applied = 1;
        end
      end else if (vnew<0) begin
        // Negative vnew, use ngspice limiting
        if (vold > 0) begin
          arg = -1*vold-1; 
        end else begin
          arg = 2*vold-1;
        end
        if (vnew<arg) begin
          limited = arg;
          limiting_applied = 1;
        end
      end 
      DEVpnjlim = limited;
    end
  endfunction

  analog function real DEVfetlim;
    input vnew, vold, vto;
    inout limiting_applied;
    real vnew, vold, vto, vlimited;
    real vtsthi, vtstlo, vtox, delv, vtemp;
    integer limiting_applied;  
    begin
      vlimited = vnew;
      vtsthi = abs(2*(vold-vto))+2;
      // vtstlo = vtsthi/2 +2;
      vtstlo = abs(vold-vto)+1;
      vtox = vto + 3.5;
      delv = vnew-vold;
      
      if (vold >= vto) begin
        if(vold >= vtox) begin
          if(delv <= 0) begin
            /* going off */
            if(vlimited >= vtox) begin
                if(-delv > vtstlo) begin
                vlimited =  vold - vtstlo;
                end
            end else begin
              vlimited = max(vnew,vto+2);
            end
          end else begin
            /* staying on */
            if(delv >= vtsthi) begin
              vlimited = vold + vtsthi;
            end
          end
        end else begin
          /* middle region */
          if(delv <= 0) begin
            /* decreasing */
            vlimited = max(vnew,vto-0.5);
          end else begin
            /* increasing */
            vlimited = min(vnew,vto+4);
          end
        end
      end else begin
        /* off */
        if(delv <= 0) begin
          if(-delv >vtsthi) begin
            vlimited = vold - vtsthi;
          end
        end else begin
          vtemp = vto + 0.5;
          if(vnew <= vtemp) begin
            if(delv > vtstlo) begin
              vlimited = vold + vtstlo;
            end
          end else begin
            vlimited = vtemp;
          end
        end
      end
      if (vlimited!=vnew) begin
        limiting_applied = 1;
      end
      DEVfetlim = vlimited;
    end
  endfunction

  analog function real DEVlimvds;
    input vnew, vold;
    inout limiting_applied;
    real vnew, vold, vlimited;
    integer limiting_applied;
    begin
      if (vold >= 3.5) begin
        if(vnew > vold) begin
          vlimited = min(vnew, (3 * vold) + 2);
        end else begin
          if (vnew < 3.5) begin
            vlimited = max(vnew, 2);
          end else begin
            vlimited = vnew;
          end
        end
      end else begin
        if(vnew > vold) begin
          vlimited = min(vnew, 4);
        end else begin
          vlimited = max(vnew, -0.5);
        end
      end
      DEVlimvds = vlimited;
      if (vlimited!=vnew) begin
        limiting_applied = 1;
      end
    end
  endfunction

  // Analog block
  analog begin

    // Instance field assignments
    if ($param_given(l)) begin
      BSIM3l = l*cpscale;
      BSIM3lGiven = 1;
    end
    if ($param_given(w)) begin
      BSIM3w = w*cpscale;
      BSIM3wGiven = 1;
    end
    if ($param_given(ad)) begin
      BSIM3drainArea = ad*cpscale*cpscale;
      BSIM3drainAreaGiven = 1;
    end
    if ($param_given(as)) begin
      BSIM3sourceArea = as*cpscale*cpscale;
      BSIM3sourceAreaGiven = 1;
    end
    if ($param_given(pd)) begin
      BSIM3drainPerimeter = pd*cpscale;
      BSIM3drainPerimeterGiven = 1;
    end
    if ($param_given(ps)) begin
      BSIM3sourcePerimeter = ps*cpscale;
      BSIM3sourcePerimeterGiven = 1;
    end
    if ($param_given(nrd)) begin
      BSIM3drainSquares = nrd;
    end
    if ($param_given(nrs)) begin
      BSIM3sourceSquares = nrs;
    end
    if ($param_given(instance_nqsmod)) begin
      i_BSIM3nqsMod = instance_nqsmod;
    end
    if ($param_given(instance_acnqsmod)) begin
      i_BSIM3acnqsMod = instance_acnqsmod;
    end

    // Model field assignments
    if ($param_given(nqsmod)) begin
      BSIM3nqsMod = nqsmod;
    end
    if ($param_given(acnqsmod)) begin
      BSIM3acnqsMod = acnqsmod;
    end
    if ($param_given(toxm)) begin
      BSIM3toxm = toxm;
    end
    if ($param_given(keta)) begin
      BSIM3keta = keta;
    end
    if ($param_given(vbm)) begin
      BSIM3vbm = vbm;
    end
    if ($param_given(kt1)) begin
      BSIM3kt1 = kt1;
    end
    if ($param_given(dvt2)) begin
      BSIM3dvt2 = dvt2;
    end
    if ($param_given(dvt2w)) begin
      BSIM3dvt2w = dvt2w;
    end
    if ($param_given(dsub)) begin
      BSIM3dsub = dsub;
    end
    if ($param_given(vth0)) begin
      BSIM3vth0 = vth0;
    end
    if ($param_given(ub1)) begin
      BSIM3ub1 = ub1;
    end
    if ($param_given(uc)) begin
      BSIM3uc = uc;
    end
    if ($param_given(uc1)) begin
      BSIM3uc1 = uc1;
    end
    if ($param_given(u0)) begin
      BSIM3u0 = u0;
    end
    if ($param_given(ute)) begin
      BSIM3ute = ute;
    end
    if ($param_given(voff)) begin
      BSIM3voff = voff;
    end
    if ($param_given(tnom)) begin
      BSIM3tnom = tnom+273.15;
      BSIM3tnomGiven = 1;
    end
    if ($param_given(cgso)) begin
      BSIM3cgso = cgso;
    end
    if ($param_given(cgdo)) begin
      BSIM3cgdo = cgdo;
    end
    if ($param_given(cgbo)) begin
      BSIM3cgbo = cgbo;
    end
    if ($param_given(etab)) begin
      BSIM3etab = etab;
    end
    if ($param_given(pb)) begin
      BSIM3bulkJctPotential = pb;
    end
    if ($param_given(pbsw)) begin
      BSIM3sidewallJctPotential = pbsw;
    end
    if ($param_given(pbswg)) begin
      BSIM3GatesidewallJctPotential = pbswg;
    end
    if ($param_given(mjswg)) begin
      BSIM3bulkJctGateSideGradingCoeff = mjswg;
    end
    if ($param_given(vfbcv)) begin
      BSIM3vfbcv = vfbcv;
    end
    if ($param_given(cjswg)) begin
      BSIM3unitLengthGateSidewallJctCap = cjswg;
    end
    if ($param_given(llc)) begin
      BSIM3Llc = llc;
    end
    if ($param_given(lwc)) begin
      BSIM3Lwc = lwc;
    end
    if ($param_given(lwlc)) begin
      BSIM3Lwlc = lwlc;
    end
    if ($param_given(wlc)) begin
      BSIM3Wlc = wlc;
    end
    if ($param_given(wwc)) begin
      BSIM3Wwc = wwc;
    end
    if ($param_given(wwlc)) begin
      BSIM3Wwlc = wwlc;
    end
    if ($param_given(cf)) begin
      BSIM3cf = cf;
    end
    if ($param_given(dwc)) begin
      BSIM3dwc = dwc;
    end
    if ($param_given(dlc)) begin
      BSIM3dlc = dlc;
    end
    if ($param_given(letab)) begin
      BSIM3letab = letab;
    end
    if ($param_given(noia)) begin
      BSIM3oxideTrapDensityA = noia;
    end
    if ($param_given(noib)) begin
      BSIM3oxideTrapDensityB = noib;
    end
    if ($param_given(noic)) begin
      BSIM3oxideTrapDensityC = noic;
    end
    BSIM3type = type;

    // Evaluation constants
    lc_gmin = $simparam("gmin", 1e-12);

    // Tag: setup, function: BSIM3setup
    if (!$param_given(nqsmod)) begin
      BSIM3nqsMod = 0;
    end else if (BSIM3nqsMod!=0&&BSIM3nqsMod!=1) begin
      BSIM3nqsMod = 0;
      $warning("nqsMod has been set to its default value: 0.");
    end
    if (!$param_given(acnqsmod)) begin
      BSIM3acnqsMod = 0;
    end else if (BSIM3acnqsMod!=0&&BSIM3acnqsMod!=1) begin
      BSIM3acnqsMod = 0;
      $warning("acnqsMod has been set to its default value: 0.");
    end
    BSIM3cox = 3.453133e-11/tox;
    if (!$param_given(toxm)) begin
      BSIM3toxm = tox;
    end
    if (!$param_given(keta)) begin
      BSIM3keta = -0.047;
    end
    if (!$param_given(vbm)) begin
      BSIM3vbm = -3.0;
    end
    if (!$param_given(kt1)) begin
      BSIM3kt1 = -0.11;
    end
    if (!$param_given(dvt2)) begin
      BSIM3dvt2 = -0.032;
    end
    if (!$param_given(dvt2w)) begin
      BSIM3dvt2w = -0.032;
    end
    if (!$param_given(dsub)) begin
      BSIM3dsub = drout;
    end
    if (!$param_given(vth0)) begin
      BSIM3vth0 = ((BSIM3type==1) ? (0.7) : (-0.7));
    end
    if (!$param_given(ub1)) begin
      BSIM3ub1 = -7.61e-18;
    end
    if (!$param_given(uc)) begin
      BSIM3uc = ((mobmod==3) ? (-0.0465) : (-0.0465e-9));
    end
    if (!$param_given(uc1)) begin
      BSIM3uc1 = ((mobmod==3) ? (-0.056) : (-0.056e-9));
    end
    if (!$param_given(u0)) begin
      BSIM3u0 = ((BSIM3type==1) ? (0.067) : (0.025));
    end
    if (!$param_given(ute)) begin
      BSIM3ute = -1.5;
    end
    if (!$param_given(voff)) begin
      BSIM3voff = -0.08;
    end
    if (!$param_given(etab)) begin
      BSIM3etab = -0.07;
    end
    if (!$param_given(vfbcv)) begin
      BSIM3vfbcv = -1.0;
    end
    if (!$param_given(letab)) begin
      BSIM3letab = -0.0;
    end
    if (!BSIM3tnomGiven) begin
      BSIM3tnom = VACONST_tnom;
    end
    if (!$param_given(llc)) begin
      BSIM3Llc = ll;
    end
    if (!$param_given(lwc)) begin
      BSIM3Lwc = lw;
    end
    if (!$param_given(lwlc)) begin
      BSIM3Lwlc = lwl;
    end
    if (!$param_given(wlc)) begin
      BSIM3Wlc = wl;
    end
    if (!$param_given(wwc)) begin
      BSIM3Wwc = ww;
    end
    if (!$param_given(wwlc)) begin
      BSIM3Wwlc = wwl;
    end
    if (!$param_given(dwc)) begin
      BSIM3dwc = wint;
    end
    if (!$param_given(dlc)) begin
      BSIM3dlc = lint;
    end
    if (!$param_given(cf)) begin
      BSIM3cf = 2.0*3.453133e-11/3.141592654*ln(1.0+0.4e-6/tox);
    end
    if (!$param_given(cgdo)) begin
      if ($param_given(dlc)&&BSIM3dlc>0.0) begin
        BSIM3cgdo = BSIM3dlc*BSIM3cox-cgdl;
      end else begin
        BSIM3cgdo = 0.6*xj*BSIM3cox;
      end
    end
    if (!$param_given(cgso)) begin
      if ($param_given(dlc)&&BSIM3dlc>0.0) begin
        BSIM3cgso = BSIM3dlc*BSIM3cox-cgsl;
      end else begin
        BSIM3cgso = 0.6*xj*BSIM3cox;
      end
    end
    if (!$param_given(cgbo)) begin
      BSIM3cgbo = 2.0*BSIM3dwc*BSIM3cox;
    end
    if (!$param_given(cjswg)) begin
      BSIM3unitLengthGateSidewallJctCap = cjsw;
    end
    if (!$param_given(pb)) begin
      BSIM3bulkJctPotential = 1.0;
    end
    if (!$param_given(pbsw)) begin
      BSIM3sidewallJctPotential = 1.0;
    end
    if (!$param_given(pbswg)) begin
      BSIM3GatesidewallJctPotential = BSIM3sidewallJctPotential;
    end
    if (!$param_given(mjswg)) begin
      BSIM3bulkJctGateSideGradingCoeff = mjsw;
    end
    if (!$param_given(noia)) begin
      if (BSIM3type==1) begin
        BSIM3oxideTrapDensityA = 1e20;
      end else begin
        BSIM3oxideTrapDensityA = 9.9e18;
      end
    end
    if (!$param_given(noib)) begin
      if (BSIM3type==1) begin
        BSIM3oxideTrapDensityB = 5e4;
      end else begin
        BSIM3oxideTrapDensityB = 2.4e3;
      end
    end
    if (!$param_given(noic)) begin
      if (BSIM3type==1) begin
        BSIM3oxideTrapDensityC = -1.4e-12;
      end else begin
        BSIM3oxideTrapDensityC = 1.4e-12;
      end
    end
    if (!BSIM3drainAreaGiven) begin
      BSIM3drainArea = 0.0;
    end
    if (!BSIM3drainPerimeterGiven) begin
      BSIM3drainPerimeter = 0.0;
    end
    if (!$param_given(nrd)) begin
      if (acm==0) begin
        BSIM3drainSquares = 1.0;
      end else begin
        BSIM3drainSquares = 0.0;
      end
    end
    if (!BSIM3lGiven) begin
      BSIM3l = 5.0e-6;
    end
    if (!BSIM3sourceAreaGiven) begin
      BSIM3sourceArea = 0.0;
    end
    if (!BSIM3sourcePerimeterGiven) begin
      BSIM3sourcePerimeter = 0.0;
    end
    if (!$param_given(nrs)) begin
      if (acm==0) begin
        BSIM3sourceSquares = 1.0;
      end else begin
        BSIM3sourceSquares = 0.0;
      end
    end
    if (!BSIM3wGiven) begin
      BSIM3w = 5.0e-6;
    end
    if (!$param_given(instance_nqsmod)) begin
      i_BSIM3nqsMod = BSIM3nqsMod;
    end else if (i_BSIM3nqsMod!=0&&i_BSIM3nqsMod!=1) begin
      i_BSIM3nqsMod = BSIM3nqsMod;
      $warning("nqsMod has been set to its global value %d.", BSIM3nqsMod);
    end
    if (!$param_given(instance_acnqsmod)) begin
      i_BSIM3acnqsMod = BSIM3acnqsMod;
    end else if (i_BSIM3acnqsMod!=0&&i_BSIM3acnqsMod!=1) begin
      i_BSIM3acnqsMod = BSIM3acnqsMod;
      $warning("acnqsMod has been set to its global value %d.", BSIM3acnqsMod);
    end
    if (acm==0) begin
      drainResistance = rsh*BSIM3drainSquares;
      sourceResistance = rsh*BSIM3sourceSquares;
    end else begin
      error = ACM_SourceDrainResistances(acm, ld, ldif, hdif, wmlt, BSIM3w, xw, rsh, $param_given(nrd), rd, rdc, BSIM3drainSquares, $param_given(nrs), rs, rsc, BSIM3sourceSquares, drainResistance, sourceResistance);
      if (error) begin
        $fatal(0, "ACM_SourceDrainResistances() returned an error.");
      end
    end
    if (!(drainResistance!=0.0)) begin
      V(d_int, d) <+ 0;
    end
    if (!(sourceResistance!=0.0)) begin
      V(s_int, s) <+ 0;
    end
    if (!i_BSIM3nqsMod) begin
      V(q_int) <+ 0;
    end

    // Tag: temp, function: BSIM3temp
    Temp = $temperature;
    if (BSIM3bulkJctPotential<0.1) begin
      BSIM3bulkJctPotential = 0.1;
      $warning("Given pb is less than 0.1. Pb is set to 0.1.");
    end
    if (BSIM3sidewallJctPotential<0.1) begin
      BSIM3sidewallJctPotential = 0.1;
      $warning("Given pbsw is less than 0.1. Pbsw is set to 0.1.");
    end
    if (BSIM3GatesidewallJctPotential<0.1) begin
      BSIM3GatesidewallJctPotential = 0.1;
      $warning("Given pbswg is less than 0.1. Pbswg is set to 0.1.");
    end
    Tnom = BSIM3tnom;
    TRatio = Temp/Tnom;
    BSIM3vcrit = CONSTvt0*ln(CONSTvt0/(CONSTroot2*1.0e-14));
    BSIM3factor1 = sqrt(1.03594e-10/3.453133e-11*tox);
    Vtm0 = 8.617087e-5*Tnom;
    Eg0 = 1.16-7.02e-4*Tnom*Tnom/(Tnom+1108.0);
    ni = 1.45e10*(Tnom/300.15)*sqrt(Tnom/300.15)*exp(21.5565981-Eg0/(2.0*Vtm0));
    BSIM3vtm = 8.617087e-5*Temp;
    Eg = 1.16-7.02e-4*Temp*Temp/(Temp+1108.0);
    if (Temp!=Tnom) begin
      T0 = Eg0/Vtm0-Eg/BSIM3vtm+xti*ln(Temp/Tnom);
      T1 = exp(T0/nj);
      BSIM3jctTempSatCurDensity = js*T1;
      BSIM3jctSidewallTempSatCurDensity = jsw*T1;
    end else begin
      BSIM3jctTempSatCurDensity = js;
      BSIM3jctSidewallTempSatCurDensity = jsw;
    end
    if (BSIM3jctTempSatCurDensity<0.0) begin
      BSIM3jctTempSatCurDensity = 0.0;
    end
    if (BSIM3jctSidewallTempSatCurDensity<0.0) begin
      BSIM3jctSidewallTempSatCurDensity = 0.0;
    end
    delTemp = $temperature-BSIM3tnom;
    T0 = tcj*delTemp;
    if (T0>=-1.0) begin
      BSIM3unitAreaTempJctCap = cj*(1.0+T0);
    end else if (cj>0.0) begin
      BSIM3unitAreaTempJctCap = 0.0;
      $warning("Temperature effect has caused cj to be negative. Cj is clamped to zero.");
    end
    T0 = tcjsw*delTemp;
    if (T0>=-1.0) begin
      BSIM3unitLengthSidewallTempJctCap = cjsw*(1.0+T0);
    end else if (cjsw>0.0) begin
      BSIM3unitLengthSidewallTempJctCap = 0.0;
      $warning("Temperature effect has caused cjsw to be negative. Cjsw is clamped to zero.");
    end
    T0 = tcjswg*delTemp;
    if (T0>=-1.0) begin
      BSIM3unitLengthGateSidewallTempJctCap = BSIM3unitLengthGateSidewallJctCap*(1.0+T0);
    end else if (BSIM3unitLengthGateSidewallJctCap>0.0) begin
      BSIM3unitLengthGateSidewallTempJctCap = 0.0;
      $warning("Temperature effect has caused cjswg to be negative. Cjswg is clamped to zero.");
    end
    BSIM3PhiB = BSIM3bulkJctPotential-tpb*delTemp;
    if (BSIM3PhiB<0.01) begin
      BSIM3PhiB = 0.01;
      $warning("Temperature effect has caused pb to be less than 0.01. Pb is clamped to 0.01.");
    end
    BSIM3PhiBSW = BSIM3sidewallJctPotential-tpbsw*delTemp;
    if (BSIM3PhiBSW<=0.01) begin
      BSIM3PhiBSW = 0.01;
      $warning("Temperature effect has caused pbsw to be less than 0.01. Pbsw is clamped to 0.01.");
    end
    BSIM3PhiBSWG = BSIM3GatesidewallJctPotential-tpbswg*delTemp;
    if (BSIM3PhiBSWG<=0.01) begin
      BSIM3PhiBSWG = 0.01;
      $warning("Temperature effect has caused pbswg to be less than 0.01. Pbswg is clamped to 0.01.");
    end
    Ldrn = BSIM3l;
    Wdrn = BSIM3w;
    Length = Ldrn;
    Width = Wdrn;
    T0 = pow(Ldrn, lln);
    T1 = pow(Wdrn, lwn);
    tmp1 = ll/T0+lw/T1+lwl/(T0*T1);
    BSIM3dl = lint+tmp1;
    tmp2 = BSIM3Llc/T0+BSIM3Lwc/T1+BSIM3Lwlc/(T0*T1);
    sd_BSIM3dlc = BSIM3dlc+tmp2;
    T2 = pow(Ldrn, wln);
    T3 = pow(Wdrn, wwn);
    tmp1 = wl/T2+ww/T3+wwl/(T2*T3);
    BSIM3dw = wint+tmp1;
    tmp2 = BSIM3Wlc/T2+BSIM3Wwc/T3+BSIM3Wwlc/(T2*T3);
    sd_BSIM3dwc = BSIM3dwc+tmp2;
    BSIM3leff = BSIM3l+xl-2.0*BSIM3dl;
    if (BSIM3leff<=0.0) begin
      $fatal(0, "Effective channel length <= 0");
    end
    BSIM3weff = BSIM3w+xw-2.0*BSIM3dw;
    if (BSIM3weff<=0.0) begin
      $fatal(0, "Effective channel width <= 0");
    end
    BSIM3leffCV = BSIM3l+xl-2.0*sd_BSIM3dlc;
    if (BSIM3leffCV<=0.0) begin
      $fatal(0, "Effective channel length for C-V <= 0");
    end
    BSIM3weffCV = BSIM3w+xw-2.0*sd_BSIM3dwc;
    if (BSIM3weffCV<=0.0) begin
      $fatal(0, "Effective channel width for C-V <= 0");
    end
    if (binunit==1) begin
      Inv_L = 1.0e-6/BSIM3leff;
      Inv_W = 1.0e-6/BSIM3weff;
      Inv_LW = 1.0e-12/(BSIM3leff*BSIM3weff);
    end else begin
      Inv_L = 1.0/BSIM3leff;
      Inv_W = 1.0/BSIM3weff;
      Inv_LW = 1.0/(BSIM3leff*BSIM3weff);
    end
    sd_BSIM3cdsc = cdsc+lcdsc*Inv_L+wcdsc*Inv_W+pcdsc*Inv_LW;
    sd_BSIM3cdscb = cdscb+lcdscb*Inv_L+wcdscb*Inv_W+pcdscb*Inv_LW;
    sd_BSIM3cdscd = cdscd+lcdscd*Inv_L+wcdscd*Inv_W+pcdscd*Inv_LW;
    sd_BSIM3cit = cit+lcit*Inv_L+wcit*Inv_W+pcit*Inv_LW;
    sd_BSIM3nfactor = nfactor+lnfactor*Inv_L+wnfactor*Inv_W+pnfactor*Inv_LW;
    sd_BSIM3xj = xj+lxj*Inv_L+wxj*Inv_W+pxj*Inv_LW;
    sd_BSIM3vsat = vsat+lvsat*Inv_L+wvsat*Inv_W+pvsat*Inv_LW;
    sd_BSIM3at = at+lat*Inv_L+wat*Inv_W+pat*Inv_LW;
    sd_BSIM3a0 = a0+la0*Inv_L+wa0*Inv_W+pa0*Inv_LW;
    sd_BSIM3ags = ags+lags*Inv_L+wags*Inv_W+pags*Inv_LW;
    sd_BSIM3a1 = a1+la1*Inv_L+wa1*Inv_W+pa1*Inv_LW;
    sd_BSIM3a2 = a2+la2*Inv_L+wa2*Inv_W+pa2*Inv_LW;
    sd_BSIM3keta = BSIM3keta+lketa*Inv_L+wketa*Inv_W+pketa*Inv_LW;
    sd_BSIM3nsub = nsub+lnsub*Inv_L+wnsub*Inv_W+pnsub*Inv_LW;
    sd_BSIM3npeak = nch+lnch*Inv_L+wnch*Inv_W+pnch*Inv_LW;
    sd_BSIM3ngate = ngate+lngate*Inv_L+wngate*Inv_W+pngate*Inv_LW;
    sd_BSIM3gamma1 = gamma1+lgamma1*Inv_L+wgamma1*Inv_W+pgamma1*Inv_LW;
    sd_BSIM3gamma2 = gamma2+lgamma2*Inv_L+wgamma2*Inv_W+pgamma2*Inv_LW;
    sd_BSIM3vbx = vbx+lvbx*Inv_L+wvbx*Inv_W+pvbx*Inv_LW;
    sd_BSIM3vbm = BSIM3vbm+lvbm*Inv_L+wvbm*Inv_W+pvbm*Inv_LW;
    sd_BSIM3xt = xt+lxt*Inv_L+wxt*Inv_W+pxt*Inv_LW;
    sd_BSIM3vfb = vfb+lvfb*Inv_L+wvfb*Inv_W+pvfb*Inv_LW;
    sd_BSIM3k1 = k1+lk1*Inv_L+wk1*Inv_W+pk1*Inv_LW;
    sd_BSIM3kt1 = BSIM3kt1+lkt1*Inv_L+wkt1*Inv_W+pkt1*Inv_LW;
    sd_BSIM3kt1l = kt1l+lkt1l*Inv_L+wkt1l*Inv_W+pkt1l*Inv_LW;
    sd_BSIM3k2 = k2+lk2*Inv_L+wk2*Inv_W+pk2*Inv_LW;
    sd_BSIM3kt2 = kt2+lkt2*Inv_L+wkt2*Inv_W+pkt2*Inv_LW;
    sd_BSIM3k3 = k3+lk3*Inv_L+wk3*Inv_W+pk3*Inv_LW;
    sd_BSIM3k3b = k3b+lk3b*Inv_L+wk3b*Inv_W+pk3b*Inv_LW;
    sd_BSIM3w0 = w0+lw0*Inv_L+ww0*Inv_W+pw0*Inv_LW;
    sd_BSIM3nlx = nlx+lnlx*Inv_L+wnlx*Inv_W+pnlx*Inv_LW;
    sd_BSIM3dvt0 = dvt0+ldvt0*Inv_L+wdvt0*Inv_W+pdvt0*Inv_LW;
    sd_BSIM3dvt1 = dvt1+ldvt1*Inv_L+wdvt1*Inv_W+pdvt1*Inv_LW;
    sd_BSIM3dvt2 = BSIM3dvt2+ldvt2*Inv_L+wdvt2*Inv_W+pdvt2*Inv_LW;
    sd_BSIM3dvt0w = dvt0w+ldvt0w*Inv_L+wdvt0w*Inv_W+pdvt0w*Inv_LW;
    sd_BSIM3dvt1w = dvt1w+ldvt1w*Inv_L+wdvt1w*Inv_W+pdvt1w*Inv_LW;
    sd_BSIM3dvt2w = BSIM3dvt2w+ldvt2w*Inv_L+wdvt2w*Inv_W+pdvt2w*Inv_LW;
    sd_BSIM3drout = drout+ldrout*Inv_L+wdrout*Inv_W+pdrout*Inv_LW;
    sd_BSIM3dsub = BSIM3dsub+ldsub*Inv_L+wdsub*Inv_W+pdsub*Inv_LW;
    sd_BSIM3vth0 = BSIM3vth0+lvth0*Inv_L+wvth0*Inv_W+pvth0*Inv_LW;
    sd_BSIM3ua = ua+lua*Inv_L+wua*Inv_W+pua*Inv_LW;
    sd_BSIM3ua1 = ua1+lua1*Inv_L+wua1*Inv_W+pua1*Inv_LW;
    sd_BSIM3ub = ub+lub*Inv_L+wub*Inv_W+pub*Inv_LW;
    sd_BSIM3ub1 = BSIM3ub1+lub1*Inv_L+wub1*Inv_W+pub1*Inv_LW;
    sd_BSIM3uc = BSIM3uc+luc*Inv_L+wuc*Inv_W+puc*Inv_LW;
    sd_BSIM3uc1 = BSIM3uc1+luc1*Inv_L+wuc1*Inv_W+puc1*Inv_LW;
    sd_BSIM3u0 = BSIM3u0+lu0*Inv_L+wu0*Inv_W+pu0*Inv_LW;
    sd_BSIM3ute = BSIM3ute+lute*Inv_L+wute*Inv_W+pute*Inv_LW;
    sd_BSIM3voff = BSIM3voff+lvoff*Inv_L+wvoff*Inv_W+pvoff*Inv_LW;
    sd_BSIM3delta = delta+ldelta*Inv_L+wdelta*Inv_W+pdelta*Inv_LW;
    sd_BSIM3rdsw = rdsw+lrdsw*Inv_L+wrdsw*Inv_W+prdsw*Inv_LW;
    sd_BSIM3prwg = prwg+lprwg*Inv_L+wprwg*Inv_W+pprwg*Inv_LW;
    sd_BSIM3prwb = prwb+lprwb*Inv_L+wprwb*Inv_W+pprwb*Inv_LW;
    sd_BSIM3prt = prt+lprt*Inv_L+wprt*Inv_W+pprt*Inv_LW;
    sd_BSIM3eta0 = eta0+leta0*Inv_L+weta0*Inv_W+peta0*Inv_LW;
    sd_BSIM3etab = BSIM3etab+BSIM3letab*Inv_L+wetab*Inv_W+petab*Inv_LW;
    sd_BSIM3pclm = pclm+lpclm*Inv_L+wpclm*Inv_W+ppclm*Inv_LW;
    sd_BSIM3pdibl1 = pdiblc1+lpdiblc1*Inv_L+wpdiblc1*Inv_W+ppdiblc1*Inv_LW;
    sd_BSIM3pdibl2 = pdiblc2+lpdiblc2*Inv_L+wpdiblc2*Inv_W+ppdiblc2*Inv_LW;
    sd_BSIM3pdiblb = pdiblcb+lpdiblcb*Inv_L+wpdiblcb*Inv_W+ppdiblcb*Inv_LW;
    sd_BSIM3pscbe1 = pscbe1+lpscbe1*Inv_L+wpscbe1*Inv_W+ppscbe1*Inv_LW;
    sd_BSIM3pscbe2 = pscbe2+lpscbe2*Inv_L+wpscbe2*Inv_W+ppscbe2*Inv_LW;
    sd_BSIM3pvag = pvag+lpvag*Inv_L+wpvag*Inv_W+ppvag*Inv_LW;
    sd_BSIM3wr = wr+lwr*Inv_L+wwr*Inv_W+pwr*Inv_LW;
    sd_BSIM3dwg = dwg+ldwg*Inv_L+wdwg*Inv_W+pdwg*Inv_LW;
    sd_BSIM3dwb = dwb+ldwb*Inv_L+wdwb*Inv_W+pdwb*Inv_LW;
    sd_BSIM3b0 = b0+lb0*Inv_L+wb0*Inv_W+pb0*Inv_LW;
    sd_BSIM3b1 = b1+lb1*Inv_L+wb1*Inv_W+pb1*Inv_LW;
    sd_BSIM3alpha0 = alpha0+lalpha0*Inv_L+walpha0*Inv_W+palpha0*Inv_LW;
    sd_BSIM3alpha1 = alpha1+lalpha1*Inv_L+walpha1*Inv_W+palpha1*Inv_LW;
    sd_BSIM3beta0 = beta0+lbeta0*Inv_L+wbeta0*Inv_W+pbeta0*Inv_LW;
    sd_BSIM3elm = elm+lelm*Inv_L+welm*Inv_W+pelm*Inv_LW;
    sd_BSIM3cgsl = cgsl+lcgsl*Inv_L+wcgsl*Inv_W+pcgsl*Inv_LW;
    sd_BSIM3cgdl = cgdl+lcgdl*Inv_L+wcgdl*Inv_W+pcgdl*Inv_LW;
    sd_BSIM3ckappa = ckappa+lckappa*Inv_L+wckappa*Inv_W+pckappa*Inv_LW;
    sd_BSIM3cf = BSIM3cf+lcf*Inv_L+wcf*Inv_W+pcf*Inv_LW;
    sd_BSIM3clc = clc+lclc*Inv_L+wclc*Inv_W+pclc*Inv_LW;
    sd_BSIM3cle = cle+lcle*Inv_L+wcle*Inv_W+pcle*Inv_LW;
    sd_BSIM3vfbcv = BSIM3vfbcv+lvfbcv*Inv_L+wvfbcv*Inv_W+pvfbcv*Inv_LW;
    sd_BSIM3acde = acde+lacde*Inv_L+wacde*Inv_W+pacde*Inv_LW;
    sd_BSIM3moin = moin+lmoin*Inv_L+wmoin*Inv_W+pmoin*Inv_LW;
    sd_BSIM3noff = noff+lnoff*Inv_L+wnoff*Inv_W+pnoff*Inv_LW;
    sd_BSIM3voffcv = voffcv+lvoffcv*Inv_L+wvoffcv*Inv_W+pvoffcv*Inv_LW;
    BSIM3abulkCVfactor = 1.0+pow(sd_BSIM3clc/BSIM3leffCV, sd_BSIM3cle);
    T0 = TRatio-1.0;
    sd_BSIM3ua = sd_BSIM3ua+sd_BSIM3ua1*T0;
    sd_BSIM3ub = sd_BSIM3ub+sd_BSIM3ub1*T0;
    sd_BSIM3uc = sd_BSIM3uc+sd_BSIM3uc1*T0;
    if (sd_BSIM3u0>1.0) begin
      sd_BSIM3u0 = sd_BSIM3u0/1.0e4;
    end
    sd_BSIM3u0temp = sd_BSIM3u0*pow(TRatio, sd_BSIM3ute);
    BSIM3vsattemp = sd_BSIM3vsat-sd_BSIM3at*T0;
    BSIM3rds0 = (sd_BSIM3rdsw+sd_BSIM3prt*T0)/pow(BSIM3weff*1E6, sd_BSIM3wr);
    sd_BSIM3cgdo = (BSIM3cgdo+sd_BSIM3cf)*BSIM3weffCV;
    sd_BSIM3cgso = (BSIM3cgso+sd_BSIM3cf)*BSIM3weffCV;
    sd_BSIM3cgbo = BSIM3cgbo*BSIM3leffCV;
    T0 = BSIM3leffCV*BSIM3leffCV;
    sd_BSIM3tconst = sd_BSIM3u0temp*sd_BSIM3elm/(BSIM3cox*BSIM3weffCV*BSIM3leffCV*T0);
    if (!$param_given(nch)&&$param_given(gamma1)) begin
      T0 = sd_BSIM3gamma1*BSIM3cox;
      sd_BSIM3npeak = 3.021E22*T0*T0;
    end
    BSIM3phi = 2.0*Vtm0*ln(sd_BSIM3npeak/ni);
    BSIM3sqrtPhi = sqrt(BSIM3phi);
    BSIM3phis3 = BSIM3sqrtPhi*BSIM3phi;
    BSIM3Xdep0 = sqrt(2.0*1.03594e-10/(1.60219e-19*sd_BSIM3npeak*1.0e6))*BSIM3sqrtPhi;
    BSIM3sqrtXdep0 = sqrt(BSIM3Xdep0);
    BSIM3litl = sqrt(3.0*sd_BSIM3xj*tox);
    BSIM3vbi = Vtm0*ln(1.0e20*sd_BSIM3npeak/(ni*ni));
    BSIM3cdep0 = sqrt(1.60219e-19*1.03594e-10*sd_BSIM3npeak*1.0e6/2.0/BSIM3phi);
    BSIM3ldeb = sqrt(1.03594e-10*Vtm0/(1.60219e-19*sd_BSIM3npeak*1.0e6))/3.0;
    sd_BSIM3acde = sd_BSIM3acde * (pow(sd_BSIM3npeak/2.0e16, -0.25));
    if ($param_given(k1)||$param_given(k2)) begin
      if (!$param_given(k1)) begin
        $warning("k1 should be specified with k2.");
        sd_BSIM3k1 = 0.53;
      end
      if (!$param_given(k2)) begin
        $warning("k2 should be specified with k1.");
        sd_BSIM3k2 = -0.0186;
      end
      if ($param_given(nsub)) begin
        $warning("nsub is ignored because k1 or k2 is given.");
      end
      if ($param_given(xt)) begin
        $warning("xt is ignored because k1 or k2 is given.");
      end
      if ($param_given(vbx)) begin
        $warning("vbx is ignored because k1 or k2 is given.");
      end
      if ($param_given(gamma1)) begin
        $warning("gamma1 is ignored because k1 or k2 is given.");
      end
      if ($param_given(gamma2)) begin
        $warning("gamma2 is ignored because k1 or k2 is given.");
      end
    end else begin
      if (!$param_given(vbx)) begin
        sd_BSIM3vbx = BSIM3phi-7.7348e-4*sd_BSIM3npeak*sd_BSIM3xt*sd_BSIM3xt;
      end
      if (sd_BSIM3vbx>0.0) begin
        sd_BSIM3vbx = -sd_BSIM3vbx;
      end
      if (sd_BSIM3vbm>0.0) begin
        sd_BSIM3vbm = -sd_BSIM3vbm;
      end
      if (!$param_given(gamma1)) begin
        sd_BSIM3gamma1 = 5.753e-12*sqrt(sd_BSIM3npeak)/BSIM3cox;
      end
      if (!$param_given(gamma2)) begin
        sd_BSIM3gamma2 = 5.753e-12*sqrt(sd_BSIM3nsub)/BSIM3cox;
      end
      T0 = sd_BSIM3gamma1-sd_BSIM3gamma2;
      T1 = sqrt(BSIM3phi-sd_BSIM3vbx)-BSIM3sqrtPhi;
      T2 = sqrt(BSIM3phi*(BSIM3phi-sd_BSIM3vbm))-BSIM3phi;
      sd_BSIM3k2 = T0*T1/(2.0*T2+sd_BSIM3vbm);
      sd_BSIM3k1 = sd_BSIM3gamma2-2.0*sd_BSIM3k2*sqrt(BSIM3phi-sd_BSIM3vbm);
    end
    if (sd_BSIM3k2<0.0) begin
      T0 = 0.5*sd_BSIM3k1/sd_BSIM3k2;
      BSIM3vbsc = 0.9*(BSIM3phi-T0*T0);
      if (BSIM3vbsc>-3.0) begin
        BSIM3vbsc = -3.0;
      end else if (BSIM3vbsc<-30.0) begin
        BSIM3vbsc = -30.0;
      end
    end else begin
      BSIM3vbsc = -30.0;
    end
    if (BSIM3vbsc>sd_BSIM3vbm) begin
      BSIM3vbsc = sd_BSIM3vbm;
    end
    if (!$param_given(vfb)) begin
      if ($param_given(vth0)) begin
        sd_BSIM3vfb = BSIM3type*sd_BSIM3vth0-BSIM3phi-sd_BSIM3k1*BSIM3sqrtPhi;
      end else begin
        sd_BSIM3vfb = -1.0;
      end
    end
    if (!$param_given(vth0)) begin
      sd_BSIM3vth0 = BSIM3type*(sd_BSIM3vfb+BSIM3phi+sd_BSIM3k1*BSIM3sqrtPhi);
    end
    BSIM3k1ox = sd_BSIM3k1*tox/BSIM3toxm;
    BSIM3k2ox = sd_BSIM3k2*tox/BSIM3toxm;
    T1 = sqrt(1.03594e-10/3.453133e-11*tox*BSIM3Xdep0);
    T0 = exp(-0.5*sd_BSIM3dsub*BSIM3leff/T1);
    BSIM3theta0vb0 = T0+2.0*T0*T0;
    T0 = exp(-0.5*sd_BSIM3drout*BSIM3leff/T1);
    T2 = T0+2.0*T0*T0;
    BSIM3thetaRout = sd_BSIM3pdibl1*T2+sd_BSIM3pdibl2;
    tmp = sqrt(BSIM3Xdep0);
    tmp1 = BSIM3vbi-BSIM3phi;
    tmp2 = BSIM3factor1*tmp;
    T0 = -0.5*sd_BSIM3dvt1w*BSIM3weff*BSIM3leff/tmp2;
    if (T0>-34.0) begin
      T1 = exp(T0);
      T2 = T1*(1.0+2.0*T1);
    end else begin
      T1 = 1.713908431e-15;
      T2 = T1*(1.0+2.0*T1);
    end
    T0 = sd_BSIM3dvt0w*T2;
    T2 = T0*tmp1;
    T0 = -0.5*sd_BSIM3dvt1*BSIM3leff/tmp2;
    if (T0>-34.0) begin
      T1 = exp(T0);
      T3 = T1*(1.0+2.0*T1);
    end else begin
      T1 = 1.713908431e-15;
      T3 = T1*(1.0+2.0*T1);
    end
    T3 = sd_BSIM3dvt0*T3*tmp1;
    T4 = tox*BSIM3phi/(BSIM3weff+sd_BSIM3w0);
    T0 = sqrt(1.0+sd_BSIM3nlx/BSIM3leff);
    T5 = BSIM3k1ox*(T0-1.0)*BSIM3sqrtPhi+(sd_BSIM3kt1+sd_BSIM3kt1l/BSIM3leff)*(TRatio-1.0);
    tmp3 = BSIM3type*sd_BSIM3vth0-T2-T3+sd_BSIM3k3*T4+T5;
    sd_BSIM3vfbzb = tmp3-BSIM3phi-sd_BSIM3k1*BSIM3sqrtPhi;
    i_BSIM3vth0 = sd_BSIM3vth0+delvto;
    i_BSIM3vfb = sd_BSIM3vfb+BSIM3type*delvto;
    BSIM3vfbzb = sd_BSIM3vfbzb+BSIM3type*delvto;
    BSIM3u0temp = sd_BSIM3u0temp*mulu0;
    BSIM3tconst = BSIM3u0temp*sd_BSIM3elm/(BSIM3cox*BSIM3weffCV*BSIM3leffCV*T0);
    if (acm==0) begin
      temp_drainResistance = rsh*BSIM3drainSquares;
      temp_sourceResistance = rsh*BSIM3sourceSquares;
    end else begin
      error = ACM_SourceDrainResistances(acm, ld, ldif, hdif, wmlt, BSIM3w, xw, rsh, $param_given(nrd), rd, rdc, BSIM3drainSquares, $param_given(nrs), rs, rsc, BSIM3sourceSquares, temp_drainResistance, temp_sourceResistance);
      if (error) begin
        $fatal(0, "ACM_SourceDrainResistances() returned an error.");
      end
    end
    if (temp_drainResistance>0.0) begin
      BSIM3drainConductance = 1.0/temp_drainResistance;
    end else begin
      BSIM3drainConductance = 0.0;
    end
    if (temp_sourceResistance>0.0) begin
      BSIM3sourceConductance = 1.0/temp_sourceResistance;
    end else begin
      BSIM3sourceConductance = 0.0;
    end
    i_BSIM3cgso = sd_BSIM3cgso;
    i_BSIM3cgdo = sd_BSIM3cgdo;
    Nvtm = BSIM3vtm*nj;
    if (BSIM3sourceArea<=0.0&&BSIM3sourcePerimeter<=0.0) begin
      SourceSatCurrent = 1.0e-14;
    end else begin
      SourceSatCurrent = BSIM3sourceArea*BSIM3jctTempSatCurDensity+BSIM3sourcePerimeter*BSIM3jctSidewallTempSatCurDensity;
    end
    if (SourceSatCurrent>0.0&&ijth>0.0) begin
      BSIM3vjsm = Nvtm*ln(ijth/SourceSatCurrent+1.0);
      BSIM3IsEvjsm = SourceSatCurrent*exp(BSIM3vjsm/Nvtm);
    end
    if (BSIM3drainArea<=0.0&&BSIM3drainPerimeter<=0.0) begin
      DrainSatCurrent = 1.0e-14;
    end else begin
      DrainSatCurrent = BSIM3drainArea*BSIM3jctTempSatCurDensity+BSIM3drainPerimeter*BSIM3jctSidewallTempSatCurDensity;
    end
    if (DrainSatCurrent>0.0&&ijth>0.0) begin
      BSIM3vjdm = Nvtm*ln(ijth/DrainSatCurrent+1.0);
      BSIM3IsEvjdm = DrainSatCurrent*exp(BSIM3vjdm/Nvtm);
    end

    // Tag: load, function: BSIM3load
    qgate = 0.0;
    qbulk = 0.0;
    qdrn = 0.0;
    qcheq = 0.0;
    ScalingFactor = 1.0e-9;
    limited = 0;
    /* Previous vgs, vds, vbs, and vbd */
    BSIM3vgs = BSIM3type * $limit(V(g, s_int), DEVlimitOldGet);
    BSIM3vds = BSIM3type * $limit(V(d_int, s_int), DEVlimitOldGet);
    BSIM3vbs = BSIM3type * $limit(V(b, s_int), DEVlimitOldGet);
    BSIM3vbd = BSIM3type * $limit(V(b, d_int), DEVlimitOldGet);
    
    BSIM3von = BSIM3type * i_BSIM3vth0 - sd_BSIM3k1 * BSIM3sqrtPhi;
    load_vbs = BSIM3type*V(b, s_int);
    load_vgs = BSIM3type*V(g, s_int);
    load_vds = BSIM3type*V(d_int, s_int);
    qdef = BSIM3type*V(q_int);
    vbd = load_vbs-load_vds;
    vgd = load_vgs-load_vds;
    vgdo = BSIM3vgs-BSIM3vds;
    delvbs = load_vbs-BSIM3vbs;
    delvbd = vbd-BSIM3vbd;
    von = BSIM3von;
    if (BSIM3vds>=0.0) begin
      load_vgs = DEVfetlim(load_vgs, BSIM3vgs, von, limited);
      load_vds = load_vgs-vgd;
      load_vds = DEVlimvds(load_vds, BSIM3vds, limited);
      vgd = load_vgs-load_vds;
    end else begin
      vgd = DEVfetlim(vgd, vgdo, von, limited);
      load_vds = load_vgs-vgd;
      load_vds = -DEVlimvds(-load_vds, -BSIM3vds, limited);
      load_vgs = vgd+load_vds;
    end
    if (load_vds>=0.0) begin
      load_vbs = DEVpnjlim(load_vbs, BSIM3vbs, CONSTvt0, BSIM3vcrit, limited);
      vbd = load_vbs-load_vds;
    end else begin
      vbd = DEVpnjlim(vbd, BSIM3vbd, CONSTvt0, BSIM3vcrit, limited);
      load_vbs = vbd+load_vds;
    end
    if (initialize_limiting()) begin
        load_vbs = 0;
        load_vgs = BSIM3type * i_BSIM3vth0 + 0.1;
        load_vds = 0.1;
        vbd = load_vbs - load_vds;
    end
    load_vgs = BSIM3type * $limit(V(g, s_int), DEVlimitNewSet, BSIM3type * load_vgs, limited);
    load_vds = BSIM3type * $limit(V(d_int, s_int), DEVlimitNewSet, BSIM3type * load_vds, limited);
    load_vbs = BSIM3type * $limit(V(b, s_int), DEVlimitNewSet, BSIM3type * load_vbs, limited);
    vbd = BSIM3type * $limit(V(b, d_int), DEVlimitNewSet, BSIM3type * vbd, limited);
    vbd = load_vbs-load_vds;
    vgd = load_vgs-load_vds;
    vgb = load_vgs-load_vbs;
    load_Nvtm = BSIM3vtm*nj;
    if (acm==0) begin
      if (BSIM3sourceArea<=0.0&&BSIM3sourcePerimeter<=0.0) begin
        load_SourceSatCurrent = 1.0e-14;
      end else begin
        load_SourceSatCurrent = BSIM3sourceArea*BSIM3jctTempSatCurDensity+BSIM3sourcePerimeter*BSIM3jctSidewallTempSatCurDensity;
      end
      if (BSIM3drainArea<=0.0&&BSIM3drainPerimeter<=0.0) begin
        load_DrainSatCurrent = 1.0e-14;
      end else begin
        load_DrainSatCurrent = BSIM3drainArea*BSIM3jctTempSatCurDensity+BSIM3drainPerimeter*BSIM3jctSidewallTempSatCurDensity;
      end
    end
    if (load_SourceSatCurrent<=0.0) begin
      BSIM3gbs = lc_gmin;
      BSIM3cbs = 0;
    end else if (ijth==0.0) begin
      evbs = exp(load_vbs/load_Nvtm);
      BSIM3gbs = load_SourceSatCurrent*evbs/load_Nvtm+lc_gmin;
      BSIM3cbs = load_SourceSatCurrent*(evbs-1.0)+lc_gmin*load_vbs;
    end else if (load_vbs<BSIM3vjsm) begin
      evbs = exp(load_vbs/load_Nvtm);
      BSIM3gbs = load_SourceSatCurrent*evbs/load_Nvtm+lc_gmin;
      BSIM3cbs = load_SourceSatCurrent*(evbs-1.0)+lc_gmin*load_vbs;
    end else begin
      load_T0 = BSIM3IsEvjsm/load_Nvtm;
      BSIM3gbs = load_T0+lc_gmin;
      BSIM3cbs = BSIM3IsEvjsm-load_SourceSatCurrent+load_T0*(load_vbs-BSIM3vjsm)+lc_gmin*load_vbs;
    end
    if (load_DrainSatCurrent<=0.0) begin
      BSIM3gbd = lc_gmin;
      BSIM3cbd = 0;
    end else if (ijth==0.0) begin
      evbd = exp(vbd/load_Nvtm);
      BSIM3gbd = load_DrainSatCurrent*evbd/load_Nvtm+lc_gmin;
      BSIM3cbd = load_DrainSatCurrent*(evbd-1.0)+lc_gmin*vbd;
    end else if (vbd<BSIM3vjdm) begin
      evbd = exp(vbd/load_Nvtm);
      BSIM3gbd = load_DrainSatCurrent*evbd/load_Nvtm+lc_gmin;
      BSIM3cbd = load_DrainSatCurrent*(evbd-1.0)+lc_gmin*vbd;
    end else begin
      load_T0 = BSIM3IsEvjdm/load_Nvtm;
      BSIM3gbd = load_T0+lc_gmin;
      BSIM3cbd = BSIM3IsEvjdm-load_DrainSatCurrent+load_T0*(vbd-BSIM3vjdm)+lc_gmin*vbd;
    end
    if (load_vds>=0.0) begin
      BSIM3mode = 1;
      Vds = load_vds;
      Vgs = load_vgs;
      Vbs = load_vbs;
    end else begin
      BSIM3mode = -1;
      Vds = -load_vds;
      Vgs = vgd;
      Vbs = vbd;
    end
    load_T0 = Vbs-BSIM3vbsc-0.001;
    load_T1 = sqrt(load_T0*load_T0-0.004*BSIM3vbsc);
    Vbseff = BSIM3vbsc+0.5*(load_T0+load_T1);
    dVbseff_dVb = 0.5*(1.0+load_T0/load_T1);
    if (Vbseff<Vbs) begin
      Vbseff = Vbs;
    end
    if (Vbseff>0.0) begin
      load_T0 = BSIM3phi/(BSIM3phi+Vbseff);
      Phis = BSIM3phi*load_T0;
      dPhis_dVb = -load_T0*load_T0;
      sqrtPhis = BSIM3phis3/(BSIM3phi+0.5*Vbseff);
      dsqrtPhis_dVb = -0.5*sqrtPhis*sqrtPhis/BSIM3phis3;
    end else begin
      Phis = BSIM3phi-Vbseff;
      dPhis_dVb = -1.0;
      sqrtPhis = sqrt(Phis);
      dsqrtPhis_dVb = -0.5/sqrtPhis;
    end
    Xdep = BSIM3Xdep0*sqrtPhis/BSIM3sqrtPhi;
    dXdep_dVb = BSIM3Xdep0/BSIM3sqrtPhi*dsqrtPhis_dVb;
    Leff = BSIM3leff;
    Vtm = BSIM3vtm;
    load_T3 = sqrt(Xdep);
    V0 = BSIM3vbi-BSIM3phi;
    load_T0 = sd_BSIM3dvt2*Vbseff;
    if (load_T0>=-0.5) begin
      load_T1 = 1.0+load_T0;
      load_T2 = sd_BSIM3dvt2;
    end else begin
      load_T4 = 1.0/(3.0+8.0*load_T0);
      load_T1 = (1.0+3.0*load_T0)*load_T4;
      load_T2 = sd_BSIM3dvt2*load_T4*load_T4;
    end
    lt1 = BSIM3factor1*load_T3*load_T1;
    dlt1_dVb = BSIM3factor1*(0.5/load_T3*load_T1*dXdep_dVb+load_T3*load_T2);
    load_T0 = sd_BSIM3dvt2w*Vbseff;
    if (load_T0>=-0.5) begin
      load_T1 = 1.0+load_T0;
      load_T2 = sd_BSIM3dvt2w;
    end else begin
      load_T4 = 1.0/(3.0+8.0*load_T0);
      load_T1 = (1.0+3.0*load_T0)*load_T4;
      load_T2 = sd_BSIM3dvt2w*load_T4*load_T4;
    end
    ltw = BSIM3factor1*load_T3*load_T1;
    dltw_dVb = BSIM3factor1*(0.5/load_T3*load_T1*dXdep_dVb+load_T3*load_T2);
    load_T0 = -0.5*sd_BSIM3dvt1*Leff/lt1;
    if (load_T0>-34.0) begin
      load_T1 = exp(load_T0);
      Theta0 = load_T1*(1.0+2.0*load_T1);
      dT1_dVb = -load_T0/lt1*load_T1*dlt1_dVb;
      dTheta0_dVb = (1.0+4.0*load_T1)*dT1_dVb;
    end else begin
      load_T1 = 1.713908431e-15;
      Theta0 = load_T1*(1.0+2.0*load_T1);
      dTheta0_dVb = 0.0;
    end
    BSIM3thetavth = sd_BSIM3dvt0*Theta0;
    Delt_vth = BSIM3thetavth*V0;
    dDelt_vth_dVb = sd_BSIM3dvt0*dTheta0_dVb*V0;
    load_T0 = -0.5*sd_BSIM3dvt1w*BSIM3weff*Leff/ltw;
    if (load_T0>-34.0) begin
      load_T1 = exp(load_T0);
      load_T2 = load_T1*(1.0+2.0*load_T1);
      dT1_dVb = -load_T0/ltw*load_T1*dltw_dVb;
      dT2_dVb = (1.0+4.0*load_T1)*dT1_dVb;
    end else begin
      load_T1 = 1.713908431e-15;
      load_T2 = load_T1*(1.0+2.0*load_T1);
      dT2_dVb = 0.0;
    end
    load_T0 = sd_BSIM3dvt0w*load_T2;
    load_T2 = load_T0*V0;
    dT2_dVb = sd_BSIM3dvt0w*dT2_dVb*V0;
    TempRatio = $temperature/BSIM3tnom-1.0;
    load_T0 = sqrt(1.0+sd_BSIM3nlx/Leff);
    load_T1 = BSIM3k1ox*(load_T0-1.0)*BSIM3sqrtPhi+(sd_BSIM3kt1+sd_BSIM3kt1l/Leff+sd_BSIM3kt2*Vbseff)*TempRatio;
    load_tmp2 = tox*BSIM3phi/(BSIM3weff+sd_BSIM3w0);
    load_T3 = sd_BSIM3eta0+sd_BSIM3etab*Vbseff;
    if (load_T3<1.0e-4) begin
      T9 = 1.0/(3.0-2.0e4*load_T3);
      load_T3 = (2.0e-4-load_T3)*T9;
      load_T4 = T9*T9;
    end else begin
      load_T4 = 1.0;
    end
    dDIBL_Sft_dVd = load_T3*BSIM3theta0vb0;
    DIBL_Sft = dDIBL_Sft_dVd*Vds;
    Vth = BSIM3type*i_BSIM3vth0-sd_BSIM3k1*BSIM3sqrtPhi+BSIM3k1ox*sqrtPhis-BSIM3k2ox*Vbseff-Delt_vth-load_T2+(sd_BSIM3k3+sd_BSIM3k3b*Vbseff)*load_tmp2+load_T1-DIBL_Sft;
    BSIM3von = Vth;
    dVth_dVb = BSIM3k1ox*dsqrtPhis_dVb-BSIM3k2ox-dDelt_vth_dVb-dT2_dVb+sd_BSIM3k3b*load_tmp2-sd_BSIM3etab*Vds*BSIM3theta0vb0*load_T4+sd_BSIM3kt2*TempRatio;
    dVth_dVd = -dDIBL_Sft_dVd;
    load_tmp2 = sd_BSIM3nfactor*1.03594e-10/Xdep;
    load_tmp3 = sd_BSIM3cdsc+sd_BSIM3cdscb*Vbseff+sd_BSIM3cdscd*Vds;
    tmp4 = (load_tmp2+load_tmp3*Theta0+sd_BSIM3cit)/BSIM3cox;
    if (tmp4>=-0.5) begin
      n = 1.0+tmp4;
      dn_dVb = (-load_tmp2/Xdep*dXdep_dVb+load_tmp3*dTheta0_dVb+sd_BSIM3cdscb*Theta0)/BSIM3cox;
      dn_dVd = sd_BSIM3cdscd*Theta0/BSIM3cox;
    end else begin
      load_T0 = 1.0/(3.0+8.0*tmp4);
      n = (1.0+3.0*tmp4)*load_T0;
      load_T0 = load_T0 * (load_T0);
      dn_dVb = (-load_tmp2/Xdep*dXdep_dVb+load_tmp3*dTheta0_dVb+sd_BSIM3cdscb*Theta0)/BSIM3cox*load_T0;
      dn_dVd = sd_BSIM3cdscd*Theta0/BSIM3cox*load_T0;
    end
    load_T0 = i_BSIM3vfb+BSIM3phi;
    if (sd_BSIM3ngate>1.0e18&&sd_BSIM3ngate<1.0e25&&Vgs>load_T0) begin
      load_T1 = 1.0e6*1.60219e-19*1.03594e-10*sd_BSIM3ngate/(BSIM3cox*BSIM3cox);
      load_T4 = sqrt(1.0+2.0*(Vgs-load_T0)/load_T1);
      load_T2 = load_T1*(load_T4-1.0);
      load_T3 = 0.5*load_T2*load_T2/load_T1;
      T7 = 1.12-load_T3-0.05;
      T6 = sqrt(T7*T7+0.224);
      load_T5 = 1.12-0.5*(T7+T6);
      Vgs_eff = Vgs-load_T5;
      dVgs_eff_dVg = 1.0-(0.5-0.5/load_T4)*(1.0+T7/T6);
    end else begin
      Vgs_eff = Vgs;
      dVgs_eff_dVg = 1.0;
    end
    Vgst = Vgs_eff-Vth;
    T10 = 2.0*n*Vtm;
    VgstNVt = Vgst/T10;
    ExpArg = (2.0*sd_BSIM3voff-Vgst)/T10;
    if (VgstNVt>34.0) begin
      Vgsteff = Vgst;
      dVgsteff_dVg = dVgs_eff_dVg;
      dVgsteff_dVd = -dVth_dVd;
      dVgsteff_dVb = -dVth_dVb;
    end else if (ExpArg>34.0) begin
      load_T0 = (Vgst-sd_BSIM3voff)/(n*Vtm);
      ExpVgst = exp(load_T0);
      Vgsteff = Vtm*BSIM3cdep0/BSIM3cox*ExpVgst;
      dVgsteff_dVg = Vgsteff/(n*Vtm);
      dVgsteff_dVd = -dVgsteff_dVg*(dVth_dVd+load_T0*Vtm*dn_dVd);
      dVgsteff_dVb = -dVgsteff_dVg*(dVth_dVb+load_T0*Vtm*dn_dVb);
      dVgsteff_dVg = dVgsteff_dVg * (dVgs_eff_dVg);
    end else begin
      ExpVgst = exp(VgstNVt);
      load_T1 = T10*ln(1.0+ExpVgst);
      dT1_dVg = ExpVgst/(1.0+ExpVgst);
      dT1_dVb = -dT1_dVg*(dVth_dVb+Vgst/n*dn_dVb)+load_T1/n*dn_dVb;
      dT1_dVd = -dT1_dVg*(dVth_dVd+Vgst/n*dn_dVd)+load_T1/n*dn_dVd;
      dT2_dVg = -BSIM3cox/(Vtm*BSIM3cdep0)*exp(ExpArg);
      load_T2 = 1.0-T10*dT2_dVg;
      dT2_dVd = -dT2_dVg*(dVth_dVd-2.0*Vtm*ExpArg*dn_dVd)+(load_T2-1.0)/n*dn_dVd;
      dT2_dVb = -dT2_dVg*(dVth_dVb-2.0*Vtm*ExpArg*dn_dVb)+(load_T2-1.0)/n*dn_dVb;
      Vgsteff = load_T1/load_T2;
      load_T3 = load_T2*load_T2;
      dVgsteff_dVg = (load_T2*dT1_dVg-load_T1*dT2_dVg)/load_T3*dVgs_eff_dVg;
      dVgsteff_dVd = (load_T2*dT1_dVd-load_T1*dT2_dVd)/load_T3;
      dVgsteff_dVb = (load_T2*dT1_dVb-load_T1*dT2_dVb)/load_T3;
    end
    BSIM3Vgsteff = Vgsteff;
    T9 = sqrtPhis-BSIM3sqrtPhi;
    Weff = BSIM3weff-2.0*(sd_BSIM3dwg*Vgsteff+sd_BSIM3dwb*T9);
    dWeff_dVg = -2.0*sd_BSIM3dwg;
    dWeff_dVb = -2.0*sd_BSIM3dwb*dsqrtPhis_dVb;
    if (Weff<2.0e-8) begin
      load_T0 = 1.0/(6.0e-8-2.0*Weff);
      Weff = 2.0e-8*(4.0e-8-Weff)*load_T0;
      load_T0 = load_T0 * (load_T0*4.0e-16);
      dWeff_dVg = dWeff_dVg * (load_T0);
      dWeff_dVb = dWeff_dVb * (load_T0);
    end
    load_T0 = sd_BSIM3prwg*Vgsteff+sd_BSIM3prwb*T9;
    if (load_T0>=-0.9) begin
      Rds = BSIM3rds0*(1.0+load_T0);
      dRds_dVg = BSIM3rds0*sd_BSIM3prwg;
      dRds_dVb = BSIM3rds0*sd_BSIM3prwb*dsqrtPhis_dVb;
    end else begin
      load_T1 = 1.0/(17.0+20.0*load_T0);
      Rds = BSIM3rds0*(0.8+load_T0)*load_T1;
      load_T1 = load_T1 * (load_T1);
      dRds_dVg = BSIM3rds0*sd_BSIM3prwg*load_T1;
      dRds_dVb = BSIM3rds0*sd_BSIM3prwb*dsqrtPhis_dVb*load_T1;
    end
    BSIM3rds = Rds;
    load_T1 = 0.5*BSIM3k1ox/sqrtPhis;
    dT1_dVb = -load_T1/sqrtPhis*dsqrtPhis_dVb;
    T9 = sqrt(sd_BSIM3xj*Xdep);
    load_tmp1 = Leff+2.0*T9;
    load_T5 = Leff/load_tmp1;
    load_tmp2 = sd_BSIM3a0*load_T5;
    load_tmp3 = BSIM3weff+sd_BSIM3b1;
    tmp4 = sd_BSIM3b0/load_tmp3;
    load_T2 = load_tmp2+tmp4;
    dT2_dVb = -T9/load_tmp1/Xdep*dXdep_dVb;
    T6 = load_T5*load_T5;
    T7 = load_T5*T6;
    Abulk0 = 1.0+load_T1*load_T2;
    dAbulk0_dVb = load_T1*load_tmp2*dT2_dVb+load_T2*dT1_dVb;
    T8 = sd_BSIM3ags*sd_BSIM3a0*T7;
    dAbulk_dVg = -load_T1*T8;
    Abulk = Abulk0+dAbulk_dVg*Vgsteff;
    dAbulk_dVb = dAbulk0_dVb-T8*Vgsteff*(dT1_dVb+3.0*load_T1*dT2_dVb);
    if (Abulk0<0.1) begin
      T9 = 1.0/(3.0-20.0*Abulk0);
      Abulk0 = (0.2-Abulk0)*T9;
      dAbulk0_dVb = dAbulk0_dVb * (T9*T9);
    end
    if (Abulk<0.1) begin
      T9 = 1.0/(3.0-20.0*Abulk);
      Abulk = (0.2-Abulk)*T9;
      T10 = T9*T9;
      dAbulk_dVb = dAbulk_dVb * (T10);
      dAbulk_dVg = dAbulk_dVg * (T10);
    end
    BSIM3Abulk = Abulk;
    load_T2 = sd_BSIM3keta*Vbseff;
    if (load_T2>=-0.9) begin
      load_T0 = 1.0/(1.0+load_T2);
      dT0_dVb = -sd_BSIM3keta*load_T0*load_T0;
    end else begin
      load_T1 = 1.0/(0.8+load_T2);
      load_T0 = (17.0+20.0*load_T2)*load_T1;
      dT0_dVb = -sd_BSIM3keta*load_T1*load_T1;
    end
    dAbulk_dVg = dAbulk_dVg * (load_T0);
    dAbulk_dVb = dAbulk_dVb*load_T0+Abulk*dT0_dVb;
    dAbulk0_dVb = dAbulk0_dVb*load_T0+Abulk0*dT0_dVb;
    Abulk = Abulk * (load_T0);
    Abulk0 = Abulk0 * (load_T0);
    if (mobmod==1) begin
      load_T0 = Vgsteff+Vth+Vth;
      load_T2 = sd_BSIM3ua+sd_BSIM3uc*Vbseff;
      load_T3 = load_T0/tox;
      load_T5 = load_T3*(load_T2+sd_BSIM3ub*load_T3);
      dDenomi_dVg = (load_T2+2.0*sd_BSIM3ub*load_T3)/tox;
      dDenomi_dVd = dDenomi_dVg*2.0*dVth_dVd;
      dDenomi_dVb = dDenomi_dVg*2.0*dVth_dVb+sd_BSIM3uc*load_T3;
    end else if (mobmod==2) begin
      load_T5 = Vgsteff/tox*(sd_BSIM3ua+sd_BSIM3uc*Vbseff+sd_BSIM3ub*Vgsteff/tox);
      dDenomi_dVg = (sd_BSIM3ua+sd_BSIM3uc*Vbseff+2.0*sd_BSIM3ub*Vgsteff/tox)/tox;
      dDenomi_dVd = 0.0;
      dDenomi_dVb = Vgsteff*sd_BSIM3uc/tox;
    end else begin
      load_T0 = Vgsteff+Vth+Vth;
      load_T2 = 1.0+sd_BSIM3uc*Vbseff;
      load_T3 = load_T0/tox;
      load_T4 = load_T3*(sd_BSIM3ua+sd_BSIM3ub*load_T3);
      load_T5 = load_T4*load_T2;
      dDenomi_dVg = (sd_BSIM3ua+2.0*sd_BSIM3ub*load_T3)*load_T2/tox;
      dDenomi_dVd = dDenomi_dVg*2.0*dVth_dVd;
      dDenomi_dVb = dDenomi_dVg*2.0*dVth_dVb+sd_BSIM3uc*load_T4;
    end
    if (load_T5>=-0.8) begin
      Denomi = 1.0+load_T5;
    end else begin
      T9 = 1.0/(7.0+10.0*load_T5);
      Denomi = (0.6+load_T5)*T9;
      T9 = T9 * (T9);
      dDenomi_dVg = dDenomi_dVg * (T9);
      dDenomi_dVd = dDenomi_dVd * (T9);
      dDenomi_dVb = dDenomi_dVb * (T9);
    end
    ueff = BSIM3u0temp/Denomi;
    BSIM3ueff = ueff;
    T9 = -ueff/Denomi;
    dueff_dVg = T9*dDenomi_dVg;
    dueff_dVd = T9*dDenomi_dVd;
    dueff_dVb = T9*dDenomi_dVb;
    WVCox = Weff*BSIM3vsattemp*BSIM3cox;
    WVCoxRds = WVCox*Rds;
    Esat = 2.0*BSIM3vsattemp/ueff;
    EsatL = Esat*Leff;
    load_T0 = -EsatL/ueff;
    dEsatL_dVg = load_T0*dueff_dVg;
    dEsatL_dVd = load_T0*dueff_dVd;
    dEsatL_dVb = load_T0*dueff_dVb;
    load_a1 = sd_BSIM3a1;
    if (load_a1==0.0) begin
      Lambda = sd_BSIM3a2;
      dLambda_dVg = 0.0;
    end else if (load_a1>0.0) begin
      load_T0 = 1.0-sd_BSIM3a2;
      load_T1 = load_T0-sd_BSIM3a1*Vgsteff-0.0001;
      load_T2 = sqrt(load_T1*load_T1+0.0004*load_T0);
      Lambda = sd_BSIM3a2+load_T0-0.5*(load_T1+load_T2);
      dLambda_dVg = 0.5*sd_BSIM3a1*(1.0+load_T1/load_T2);
    end else begin
      load_T1 = sd_BSIM3a2+sd_BSIM3a1*Vgsteff-0.0001;
      load_T2 = sqrt(load_T1*load_T1+0.0004*sd_BSIM3a2);
      Lambda = 0.5*(load_T1+load_T2);
      dLambda_dVg = 0.5*sd_BSIM3a1*(1.0+load_T1/load_T2);
    end
    Vgst2Vtm = Vgsteff+2.0*Vtm;
    BSIM3AbovVgst2Vtm = Abulk/Vgst2Vtm;
    if (Rds>0) begin
      load_tmp2 = dRds_dVg/Rds+dWeff_dVg/Weff;
      load_tmp3 = dRds_dVb/Rds+dWeff_dVb/Weff;
    end else begin
      load_tmp2 = dWeff_dVg/Weff;
      load_tmp3 = dWeff_dVb/Weff;
    end
    if (Rds==0.0&&Lambda==1.0) begin
      load_T0 = 1.0/(Abulk*EsatL+Vgst2Vtm);
      load_tmp1 = 0.0;
      load_T1 = load_T0*load_T0;
      load_T2 = Vgst2Vtm*load_T0;
      load_T3 = EsatL*Vgst2Vtm;
      Vdsat = load_T3*load_T0;
      dT0_dVg = -(Abulk*dEsatL_dVg+EsatL*dAbulk_dVg+1.0)*load_T1;
      dT0_dVd = -(Abulk*dEsatL_dVd)*load_T1;
      dT0_dVb = -(Abulk*dEsatL_dVb+dAbulk_dVb*EsatL)*load_T1;
      dVdsat_dVg = load_T3*dT0_dVg+load_T2*dEsatL_dVg+EsatL*load_T0;
      dVdsat_dVd = load_T3*dT0_dVd+load_T2*dEsatL_dVd;
      dVdsat_dVb = load_T3*dT0_dVb+load_T2*dEsatL_dVb;
    end else begin
      load_tmp1 = dLambda_dVg/(Lambda*Lambda);
      T9 = Abulk*WVCoxRds;
      T8 = Abulk*T9;
      T7 = Vgst2Vtm*T9;
      T6 = Vgst2Vtm*WVCoxRds;
      load_T0 = 2.0*Abulk*(T9-1.0+1.0/Lambda);
      dT0_dVg = 2.0*(T8*load_tmp2-Abulk*load_tmp1+(2.0*T9+1.0/Lambda-1.0)*dAbulk_dVg);
      dT0_dVb = 2.0*(T8*(2.0/Abulk*dAbulk_dVb+load_tmp3)+(1.0/Lambda-1.0)*dAbulk_dVb);
      dT0_dVd = 0.0;
      load_T1 = Vgst2Vtm*(2.0/Lambda-1.0)+Abulk*EsatL+3.0*T7;
      dT1_dVg = 2.0/Lambda-1.0-2.0*Vgst2Vtm*load_tmp1+Abulk*dEsatL_dVg+EsatL*dAbulk_dVg+3.0*(T9+T7*load_tmp2+T6*dAbulk_dVg);
      dT1_dVb = Abulk*dEsatL_dVb+EsatL*dAbulk_dVb+3.0*(T6*dAbulk_dVb+T7*load_tmp3);
      dT1_dVd = Abulk*dEsatL_dVd;
      load_T2 = Vgst2Vtm*(EsatL+2.0*T6);
      dT2_dVg = EsatL+Vgst2Vtm*dEsatL_dVg+T6*(4.0+2.0*Vgst2Vtm*load_tmp2);
      dT2_dVb = Vgst2Vtm*(dEsatL_dVb+2.0*T6*load_tmp3);
      dT2_dVd = Vgst2Vtm*dEsatL_dVd;
      load_T3 = sqrt(load_T1*load_T1-2.0*load_T0*load_T2);
      Vdsat = (load_T1-load_T3)/load_T0;
      dT3_dVg = (load_T1*dT1_dVg-2.0*(load_T0*dT2_dVg+load_T2*dT0_dVg))/load_T3;
      dT3_dVd = (load_T1*dT1_dVd-2.0*(load_T0*dT2_dVd+load_T2*dT0_dVd))/load_T3;
      dT3_dVb = (load_T1*dT1_dVb-2.0*(load_T0*dT2_dVb+load_T2*dT0_dVb))/load_T3;
      dVdsat_dVg = (dT1_dVg-(load_T1*dT1_dVg-dT0_dVg*load_T2-load_T0*dT2_dVg)/load_T3-Vdsat*dT0_dVg)/load_T0;
      dVdsat_dVb = (dT1_dVb-(load_T1*dT1_dVb-dT0_dVb*load_T2-load_T0*dT2_dVb)/load_T3-Vdsat*dT0_dVb)/load_T0;
      dVdsat_dVd = (dT1_dVd-(load_T1*dT1_dVd-load_T0*dT2_dVd)/load_T3)/load_T0;
    end
    BSIM3vdsat = Vdsat;
    load_T1 = Vdsat-Vds-sd_BSIM3delta;
    dT1_dVg = dVdsat_dVg;
    dT1_dVd = dVdsat_dVd-1.0;
    dT1_dVb = dVdsat_dVb;
    load_T2 = sqrt(load_T1*load_T1+4.0*sd_BSIM3delta*Vdsat);
    load_T0 = load_T1/load_T2;
    load_T3 = 2.0*sd_BSIM3delta/load_T2;
    dT2_dVg = load_T0*dT1_dVg+load_T3*dVdsat_dVg;
    dT2_dVd = load_T0*dT1_dVd+load_T3*dVdsat_dVd;
    dT2_dVb = load_T0*dT1_dVb+load_T3*dVdsat_dVb;
    Vdseff = Vdsat-0.5*(load_T1+load_T2);
    dVdseff_dVg = dVdsat_dVg-0.5*(dT1_dVg+dT2_dVg);
    dVdseff_dVd = dVdsat_dVd-0.5*(dT1_dVd+dT2_dVd);
    dVdseff_dVb = dVdsat_dVb-0.5*(dT1_dVb+dT2_dVb);
    if (Vds==0.0) begin
      Vdseff = 0.0;
      dVdseff_dVg = 0.0;
      dVdseff_dVb = 0.0;
    end
    tmp4 = 1.0-0.5*Abulk*Vdsat/Vgst2Vtm;
    T9 = WVCoxRds*Vgsteff;
    T8 = T9/Vgst2Vtm;
    load_T0 = EsatL+Vdsat+2.0*T9*tmp4;
    T7 = 2.0*WVCoxRds*tmp4;
    dT0_dVg = dEsatL_dVg+dVdsat_dVg+T7*(1.0+load_tmp2*Vgsteff)-T8*(Abulk*dVdsat_dVg-Abulk*Vdsat/Vgst2Vtm+Vdsat*dAbulk_dVg);
    dT0_dVb = dEsatL_dVb+dVdsat_dVb+T7*load_tmp3*Vgsteff-T8*(dAbulk_dVb*Vdsat+Abulk*dVdsat_dVb);
    dT0_dVd = dEsatL_dVd+dVdsat_dVd-T8*Abulk*dVdsat_dVd;
    T9 = WVCoxRds*Abulk;
    load_T1 = 2.0/Lambda-1.0+T9;
    dT1_dVg = -2.0*load_tmp1+WVCoxRds*(Abulk*load_tmp2+dAbulk_dVg);
    dT1_dVb = dAbulk_dVb*WVCoxRds+T9*load_tmp3;
    Vasat = load_T0/load_T1;
    dVasat_dVg = (dT0_dVg-Vasat*dT1_dVg)/load_T1;
    dVasat_dVb = (dT0_dVb-Vasat*dT1_dVb)/load_T1;
    dVasat_dVd = dT0_dVd/load_T1;
    if (Vdseff>Vds) begin
      Vdseff = Vds;
    end
    diffVds = Vds-Vdseff;
    BSIM3Vdseff = Vdseff;
    if (sd_BSIM3pclm>0.0&&diffVds>1.0e-10) begin
      load_T0 = 1.0/(sd_BSIM3pclm*Abulk*BSIM3litl);
      dT0_dVb = -load_T0/Abulk*dAbulk_dVb;
      dT0_dVg = -load_T0/Abulk*dAbulk_dVg;
      load_T2 = Vgsteff/EsatL;
      load_T1 = Leff*(Abulk+load_T2);
      dT1_dVg = Leff*((1.0-load_T2*dEsatL_dVg)/EsatL+dAbulk_dVg);
      dT1_dVb = Leff*(dAbulk_dVb-load_T2*dEsatL_dVb/EsatL);
      dT1_dVd = -load_T2*dEsatL_dVd/Esat;
      T9 = load_T0*load_T1;
      VACLM = T9*diffVds;
      dVACLM_dVg = load_T0*dT1_dVg*diffVds-T9*dVdseff_dVg+load_T1*diffVds*dT0_dVg;
      dVACLM_dVb = (dT0_dVb*load_T1+load_T0*dT1_dVb)*diffVds-T9*dVdseff_dVb;
      dVACLM_dVd = load_T0*dT1_dVd*diffVds+T9*(1.0-dVdseff_dVd);
    end else begin
      VACLM = 5.834617425e14;
      dVACLM_dVb = 0.0;
      dVACLM_dVg = dVACLM_dVb;
      dVACLM_dVd = dVACLM_dVg;
    end
    if (BSIM3thetaRout>0.0) begin
      T8 = Abulk*Vdsat;
      load_T0 = Vgst2Vtm*T8;
      dT0_dVg = Vgst2Vtm*Abulk*dVdsat_dVg+T8+Vgst2Vtm*Vdsat*dAbulk_dVg;
      dT0_dVb = Vgst2Vtm*(dAbulk_dVb*Vdsat+Abulk*dVdsat_dVb);
      dT0_dVd = Vgst2Vtm*Abulk*dVdsat_dVd;
      load_T1 = Vgst2Vtm+T8;
      dT1_dVg = 1.0+Abulk*dVdsat_dVg+Vdsat*dAbulk_dVg;
      dT1_dVb = Abulk*dVdsat_dVb+dAbulk_dVb*Vdsat;
      dT1_dVd = Abulk*dVdsat_dVd;
      T9 = load_T1*load_T1;
      load_T2 = BSIM3thetaRout;
      VADIBL = (Vgst2Vtm-load_T0/load_T1)/load_T2;
      dVADIBL_dVg = (1.0-dT0_dVg/load_T1+load_T0*dT1_dVg/T9)/load_T2;
      dVADIBL_dVb = (-dT0_dVb/load_T1+load_T0*dT1_dVb/T9)/load_T2;
      dVADIBL_dVd = (-dT0_dVd/load_T1+load_T0*dT1_dVd/T9)/load_T2;
      T7 = sd_BSIM3pdiblb*Vbseff;
      if (T7>=-0.9) begin
        load_T3 = 1.0/(1.0+T7);
        VADIBL = VADIBL * (load_T3);
        dVADIBL_dVg = dVADIBL_dVg * (load_T3);
        dVADIBL_dVb = (dVADIBL_dVb-VADIBL*sd_BSIM3pdiblb)*load_T3;
        dVADIBL_dVd = dVADIBL_dVd * (load_T3);
      end else begin
        load_T4 = 1.0/(0.8+T7);
        load_T3 = (17.0+20.0*T7)*load_T4;
        dVADIBL_dVg = dVADIBL_dVg * (load_T3);
        dVADIBL_dVb = dVADIBL_dVb*load_T3-VADIBL*sd_BSIM3pdiblb*load_T4*load_T4;
        dVADIBL_dVd = dVADIBL_dVd * (load_T3);
        VADIBL = VADIBL * (load_T3);
      end
    end else begin
      VADIBL = 5.834617425e14;
      dVADIBL_dVb = 0.0;
      dVADIBL_dVg = dVADIBL_dVb;
      dVADIBL_dVd = dVADIBL_dVg;
    end
    T8 = sd_BSIM3pvag/EsatL;
    T9 = T8*Vgsteff;
    if (T9>-0.9) begin
      load_T0 = 1.0+T9;
      dT0_dVg = T8*(1.0-Vgsteff*dEsatL_dVg/EsatL);
      dT0_dVb = -T9*dEsatL_dVb/EsatL;
      dT0_dVd = -T9*dEsatL_dVd/EsatL;
    end else begin
      load_T1 = 1.0/(17.0+20.0*T9);
      load_T0 = (0.8+T9)*load_T1;
      load_T1 = load_T1 * (load_T1);
      dT0_dVg = T8*(1.0-Vgsteff*dEsatL_dVg/EsatL)*load_T1;
      T9 = T9 * (load_T1/EsatL);
      dT0_dVb = -T9*dEsatL_dVb;
      dT0_dVd = -T9*dEsatL_dVd;
    end
    load_tmp1 = VACLM*VACLM;
    load_tmp2 = VADIBL*VADIBL;
    load_tmp3 = VACLM+VADIBL;
    load_T1 = VACLM*VADIBL/load_tmp3;
    load_tmp3 = load_tmp3 * (load_tmp3);
    dT1_dVg = (load_tmp1*dVADIBL_dVg+load_tmp2*dVACLM_dVg)/load_tmp3;
    dT1_dVd = (load_tmp1*dVADIBL_dVd+load_tmp2*dVACLM_dVd)/load_tmp3;
    dT1_dVb = (load_tmp1*dVADIBL_dVb+load_tmp2*dVACLM_dVb)/load_tmp3;
    Va = Vasat+load_T0*load_T1;
    dVa_dVg = dVasat_dVg+load_T1*dT0_dVg+load_T0*dT1_dVg;
    dVa_dVd = dVasat_dVd+load_T1*dT0_dVd+load_T0*dT1_dVd;
    dVa_dVb = dVasat_dVb+load_T1*dT0_dVb+load_T0*dT1_dVb;
    if (sd_BSIM3pscbe2>0.0) begin
      if (diffVds>sd_BSIM3pscbe1*BSIM3litl/34.0) begin
        load_T0 = sd_BSIM3pscbe1*BSIM3litl/diffVds;
        VASCBE = Leff*exp(load_T0)/sd_BSIM3pscbe2;
        load_T1 = load_T0*VASCBE/diffVds;
        dVASCBE_dVg = load_T1*dVdseff_dVg;
        dVASCBE_dVd = -load_T1*(1.0-dVdseff_dVd);
        dVASCBE_dVb = load_T1*dVdseff_dVb;
      end else begin
        VASCBE = 5.834617425e14*Leff/sd_BSIM3pscbe2;
        dVASCBE_dVb = 0.0;
        dVASCBE_dVd = dVASCBE_dVb;
        dVASCBE_dVg = dVASCBE_dVd;
      end
    end else begin
      VASCBE = 5.834617425e14;
      dVASCBE_dVb = 0.0;
      dVASCBE_dVd = dVASCBE_dVb;
      dVASCBE_dVg = dVASCBE_dVd;
    end
    CoxWovL = BSIM3cox*Weff/Leff;
    beta = ueff*CoxWovL;
    dbeta_dVg = CoxWovL*dueff_dVg+beta*dWeff_dVg/Weff;
    dbeta_dVd = CoxWovL*dueff_dVd;
    dbeta_dVb = CoxWovL*dueff_dVb+beta*dWeff_dVb/Weff;
    load_T0 = 1.0-0.5*Abulk*Vdseff/Vgst2Vtm;
    dT0_dVg = -0.5*(Abulk*dVdseff_dVg-Abulk*Vdseff/Vgst2Vtm+Vdseff*dAbulk_dVg)/Vgst2Vtm;
    dT0_dVd = -0.5*Abulk*dVdseff_dVd/Vgst2Vtm;
    dT0_dVb = -0.5*(Abulk*dVdseff_dVb+dAbulk_dVb*Vdseff)/Vgst2Vtm;
    fgche1 = Vgsteff*load_T0;
    dfgche1_dVg = Vgsteff*dT0_dVg+load_T0;
    dfgche1_dVd = Vgsteff*dT0_dVd;
    dfgche1_dVb = Vgsteff*dT0_dVb;
    T9 = Vdseff/EsatL;
    fgche2 = 1.0+T9;
    dfgche2_dVg = (dVdseff_dVg-T9*dEsatL_dVg)/EsatL;
    dfgche2_dVd = (dVdseff_dVd-T9*dEsatL_dVd)/EsatL;
    dfgche2_dVb = (dVdseff_dVb-T9*dEsatL_dVb)/EsatL;
    gche = beta*fgche1/fgche2;
    dgche_dVg = (beta*dfgche1_dVg+fgche1*dbeta_dVg-gche*dfgche2_dVg)/fgche2;
    dgche_dVd = (beta*dfgche1_dVd+fgche1*dbeta_dVd-gche*dfgche2_dVd)/fgche2;
    dgche_dVb = (beta*dfgche1_dVb+fgche1*dbeta_dVb-gche*dfgche2_dVb)/fgche2;
    load_T0 = 1.0+gche*Rds;
    T9 = Vdseff/load_T0;
    Idl = gche*T9;
    dIdl_dVg = (gche*dVdseff_dVg+T9*dgche_dVg)/load_T0-Idl*gche/load_T0*dRds_dVg;
    dIdl_dVd = (gche*dVdseff_dVd+T9*dgche_dVd)/load_T0;
    dIdl_dVb = (gche*dVdseff_dVb+T9*dgche_dVb-Idl*dRds_dVb*gche)/load_T0;
    T9 = diffVds/Va;
    load_T0 = 1.0+T9;
    Idsa = Idl*load_T0;
    dIdsa_dVg = load_T0*dIdl_dVg-Idl*(dVdseff_dVg+T9*dVa_dVg)/Va;
    dIdsa_dVd = load_T0*dIdl_dVd+Idl*(1.0-dVdseff_dVd-T9*dVa_dVd)/Va;
    dIdsa_dVb = load_T0*dIdl_dVb-Idl*(dVdseff_dVb+T9*dVa_dVb)/Va;
    T9 = diffVds/VASCBE;
    load_T0 = 1.0+T9;
    Ids = Idsa*load_T0;
    Gm = load_T0*dIdsa_dVg-Idsa*(dVdseff_dVg+T9*dVASCBE_dVg)/VASCBE;
    Gds = load_T0*dIdsa_dVd+Idsa*(1.0-dVdseff_dVd-T9*dVASCBE_dVd)/VASCBE;
    Gmb = load_T0*dIdsa_dVb-Idsa*(dVdseff_dVb+T9*dVASCBE_dVb)/VASCBE;
    Gds = Gds + (Gm*dVgsteff_dVd);
    Gmb = Gmb + (Gm*dVgsteff_dVb);
    Gm = Gm * (dVgsteff_dVg);
    Gmb = Gmb * (dVbseff_dVb);
    load_tmp = sd_BSIM3alpha0+sd_BSIM3alpha1*Leff;
    if (load_tmp<=0.0||sd_BSIM3beta0<=0.0) begin
      Gbg = 0.0;
      Gbb = Gbg;
      Gbd = Gbb;
      Isub = Gbd;
    end else begin
      load_T2 = load_tmp/Leff;
      if (diffVds>sd_BSIM3beta0/34.0) begin
        load_T0 = -sd_BSIM3beta0/diffVds;
        load_T1 = load_T2*diffVds*exp(load_T0);
        load_T3 = load_T1/diffVds*(load_T0-1.0);
        dT1_dVg = load_T3*dVdseff_dVg;
        dT1_dVd = load_T3*(dVdseff_dVd-1.0);
        dT1_dVb = load_T3*dVdseff_dVb;
      end else begin
        load_T3 = load_T2*1.713908431e-15;
        load_T1 = load_T3*diffVds;
        dT1_dVg = -load_T3*dVdseff_dVg;
        dT1_dVd = load_T3*(1.0-dVdseff_dVd);
        dT1_dVb = -load_T3*dVdseff_dVb;
      end
      Isub = load_T1*Idsa;
      Gbg = load_T1*dIdsa_dVg+Idsa*dT1_dVg;
      Gbd = load_T1*dIdsa_dVd+Idsa*dT1_dVd;
      Gbb = load_T1*dIdsa_dVb+Idsa*dT1_dVb;
      Gbd = Gbd + (Gbg*dVgsteff_dVd);
      Gbb = Gbb + (Gbg*dVgsteff_dVb);
      Gbg = Gbg * (dVgsteff_dVg);
      Gbb = Gbb * (dVbseff_dVb);
    end
    cdrain = Ids;
    BSIM3gds = Gds;
    BSIM3gm = Gm;
    BSIM3gmbs = Gmb;
    BSIM3gbbs = Gbb;
    BSIM3gbgs = Gbg;
    BSIM3gbds = Gbd;
    BSIM3csub = Isub;
    if (xpart<0||!1) begin
      qbulk = 0.0;
      qsrc = qbulk;
      qdrn = qsrc;
      qgate = qdrn;
      BSIM3cgdb = 0.0;
      BSIM3cgsb = BSIM3cgdb;
      BSIM3cggb = BSIM3cgsb;
      BSIM3cddb = 0.0;
      BSIM3cdsb = BSIM3cddb;
      BSIM3cdgb = BSIM3cdsb;
      BSIM3cbdb = 0.0;
      BSIM3cbsb = BSIM3cbdb;
      BSIM3cbgb = BSIM3cbsb;
      BSIM3cqbb = 0.0;
      BSIM3cqgb = BSIM3cqbb;
      BSIM3cqsb = BSIM3cqgb;
      BSIM3cqdb = BSIM3cqsb;
      BSIM3gtau = 0.0;
    end else if (capmod==0) begin
      if (Vbseff<0.0) begin
        Vbseff = Vbs;
        dVbseff_dVb = 1.0;
      end else begin
        Vbseff = BSIM3phi-Phis;
        dVbseff_dVb = -dPhis_dVb;
      end
      Vfb = sd_BSIM3vfbcv;
      Vth = Vfb+BSIM3phi+BSIM3k1ox*sqrtPhis;
      Vgst = Vgs_eff-Vth;
      dVth_dVb = BSIM3k1ox*dsqrtPhis_dVb;
      dVgst_dVb = -dVth_dVb;
      dVgst_dVg = dVgs_eff_dVg;
      CoxWL = BSIM3cox*BSIM3weffCV*BSIM3leffCV;
      Arg1 = Vgs_eff-Vbseff-Vfb;
      if (Arg1<=0.0) begin
        qgate = CoxWL*Arg1;
        qbulk = -qgate;
        qdrn = 0.0;
        BSIM3cggb = CoxWL*dVgs_eff_dVg;
        BSIM3cgdb = 0.0;
        BSIM3cgsb = CoxWL*(dVbseff_dVb-dVgs_eff_dVg);
        BSIM3cdgb = 0.0;
        BSIM3cddb = 0.0;
        BSIM3cdsb = 0.0;
        BSIM3cbgb = -CoxWL*dVgs_eff_dVg;
        BSIM3cbdb = 0.0;
        BSIM3cbsb = -BSIM3cgsb;
        BSIM3qinv = 0.0;
      end else if (Vgst<=0.0) begin
        load_T1 = 0.5*BSIM3k1ox;
        load_T2 = sqrt(load_T1*load_T1+Arg1);
        qgate = CoxWL*BSIM3k1ox*(load_T2-load_T1);
        qbulk = -qgate;
        qdrn = 0.0;
        load_T0 = CoxWL*load_T1/load_T2;
        BSIM3cggb = load_T0*dVgs_eff_dVg;
        BSIM3cgdb = 0.0;
        BSIM3cgsb = load_T0*(dVbseff_dVb-dVgs_eff_dVg);
        BSIM3cdgb = 0.0;
        BSIM3cddb = 0.0;
        BSIM3cdsb = 0.0;
        BSIM3cbgb = -BSIM3cggb;
        BSIM3cbdb = 0.0;
        BSIM3cbsb = -BSIM3cgsb;
        BSIM3qinv = 0.0;
      end else begin
        One_Third_CoxWL = CoxWL/3.0;
        Two_Third_CoxWL = 2.0*One_Third_CoxWL;
        AbulkCV = Abulk0*BSIM3abulkCVfactor;
        dAbulkCV_dVb = BSIM3abulkCVfactor*dAbulk0_dVb;
        Vdsat = Vgst/AbulkCV;
        dVdsat_dVg = dVgs_eff_dVg/AbulkCV;
        dVdsat_dVb = -(Vdsat*dAbulkCV_dVb+dVth_dVb)/AbulkCV;
        if (xpart>0.5) begin
          if (Vdsat<=Vds) begin
            load_T1 = Vdsat/3.0;
            qgate = CoxWL*(Vgs_eff-Vfb-BSIM3phi-load_T1);
            load_T2 = -Two_Third_CoxWL*Vgst;
            qbulk = -(qgate+load_T2);
            qdrn = 0.0;
            BSIM3cggb = One_Third_CoxWL*(3.0-dVdsat_dVg)*dVgs_eff_dVg;
            load_T2 = -One_Third_CoxWL*dVdsat_dVb;
            BSIM3cgsb = -(BSIM3cggb+load_T2);
            BSIM3cgdb = 0.0;
            BSIM3cdgb = 0.0;
            BSIM3cddb = 0.0;
            BSIM3cdsb = 0.0;
            BSIM3cbgb = -(BSIM3cggb-Two_Third_CoxWL*dVgs_eff_dVg);
            load_T3 = -(load_T2+Two_Third_CoxWL*dVth_dVb);
            BSIM3cbsb = -(BSIM3cbgb+load_T3);
            BSIM3cbdb = 0.0;
            BSIM3qinv = -(qgate+qbulk);
          end else begin
            Alphaz = Vgst/Vdsat;
            load_T1 = 2.0*Vdsat-Vds;
            load_T2 = Vds/(3.0*load_T1);
            load_T3 = load_T2*Vds;
            T9 = 0.25*CoxWL;
            load_T4 = T9*Alphaz;
            T7 = 2.0*Vds-load_T1-3.0*load_T3;
            T8 = load_T3-load_T1-2.0*Vds;
            qgate = CoxWL*(Vgs_eff-Vfb-BSIM3phi-0.5*(Vds-load_T3));
            T10 = load_T4*T8;
            qdrn = load_T4*T7;
            qbulk = -(qgate+qdrn+T10);
            load_T5 = load_T3/load_T1;
            BSIM3cggb = CoxWL*(1.0-load_T5*dVdsat_dVg)*dVgs_eff_dVg;
            T11 = -CoxWL*load_T5*dVdsat_dVb;
            BSIM3cgdb = CoxWL*(load_T2-0.5+0.5*load_T5);
            BSIM3cgsb = -(BSIM3cggb+T11+BSIM3cgdb);
            T6 = 1.0/Vdsat;
            dAlphaz_dVg = T6*(1.0-Alphaz*dVdsat_dVg);
            dAlphaz_dVb = -T6*(dVth_dVb+Alphaz*dVdsat_dVb);
            T7 = T9*T7;
            T8 = T9*T8;
            T9 = 2.0*load_T4*(1.0-3.0*load_T5);
            BSIM3cdgb = (T7*dAlphaz_dVg-T9*dVdsat_dVg)*dVgs_eff_dVg;
            T12 = T7*dAlphaz_dVb-T9*dVdsat_dVb;
            BSIM3cddb = load_T4*(3.0-6.0*load_T2-3.0*load_T5);
            BSIM3cdsb = -(BSIM3cdgb+T12+BSIM3cddb);
            T9 = 2.0*load_T4*(1.0+load_T5);
            T10 = (T8*dAlphaz_dVg-T9*dVdsat_dVg)*dVgs_eff_dVg;
            T11 = T8*dAlphaz_dVb-T9*dVdsat_dVb;
            T12 = load_T4*(2.0*load_T2+load_T5-1.0);
            load_T0 = -(T10+T11+T12);
            BSIM3cbgb = -(BSIM3cggb+BSIM3cdgb+T10);
            BSIM3cbdb = -(BSIM3cgdb+BSIM3cddb+T12);
            BSIM3cbsb = -(BSIM3cgsb+BSIM3cdsb+load_T0);
            BSIM3qinv = -(qgate+qbulk);
          end
        end else if (xpart<0.5) begin
          if (Vds>=Vdsat) begin
            load_T1 = Vdsat/3.0;
            qgate = CoxWL*(Vgs_eff-Vfb-BSIM3phi-load_T1);
            load_T2 = -Two_Third_CoxWL*Vgst;
            qbulk = -(qgate+load_T2);
            qdrn = 0.4*load_T2;
            BSIM3cggb = One_Third_CoxWL*(3.0-dVdsat_dVg)*dVgs_eff_dVg;
            load_T2 = -One_Third_CoxWL*dVdsat_dVb;
            BSIM3cgsb = -(BSIM3cggb+load_T2);
            BSIM3cgdb = 0.0;
            load_T3 = 0.4*Two_Third_CoxWL;
            BSIM3cdgb = -load_T3*dVgs_eff_dVg;
            BSIM3cddb = 0.0;
            load_T4 = load_T3*dVth_dVb;
            BSIM3cdsb = -(load_T4+BSIM3cdgb);
            BSIM3cbgb = -(BSIM3cggb-Two_Third_CoxWL*dVgs_eff_dVg);
            load_T3 = -(load_T2+Two_Third_CoxWL*dVth_dVb);
            BSIM3cbsb = -(BSIM3cbgb+load_T3);
            BSIM3cbdb = 0.0;
            BSIM3qinv = -(qgate+qbulk);
          end else begin
            Alphaz = Vgst/Vdsat;
            load_T1 = 2.0*Vdsat-Vds;
            load_T2 = Vds/(3.0*load_T1);
            load_T3 = load_T2*Vds;
            T9 = 0.25*CoxWL;
            load_T4 = T9*Alphaz;
            qgate = CoxWL*(Vgs_eff-Vfb-BSIM3phi-0.5*(Vds-load_T3));
            load_T5 = load_T3/load_T1;
            BSIM3cggb = CoxWL*(1.0-load_T5*dVdsat_dVg)*dVgs_eff_dVg;
            load_tmp = -CoxWL*load_T5*dVdsat_dVb;
            BSIM3cgdb = CoxWL*(load_T2-0.5+0.5*load_T5);
            BSIM3cgsb = -(BSIM3cggb+BSIM3cgdb+load_tmp);
            T6 = 1.0/Vdsat;
            dAlphaz_dVg = T6*(1.0-Alphaz*dVdsat_dVg);
            dAlphaz_dVb = -T6*(dVth_dVb+Alphaz*dVdsat_dVb);
            T6 = 8.0*Vdsat*Vdsat-6.0*Vdsat*Vds+1.2*Vds*Vds;
            T8 = load_T2/load_T1;
            T7 = Vds-load_T1-T8*T6;
            qdrn = load_T4*T7;
            T7 = T7 * (T9);
            load_tmp = T8/load_T1;
            load_tmp1 = load_T4*(2.0-4.0*load_tmp*T6+T8*(16.0*Vdsat-6.0*Vds));
            BSIM3cdgb = (T7*dAlphaz_dVg-load_tmp1*dVdsat_dVg)*dVgs_eff_dVg;
            T10 = T7*dAlphaz_dVb-load_tmp1*dVdsat_dVb;
            BSIM3cddb = load_T4*(2.0-(1.0/(3.0*load_T1*load_T1)+2.0*load_tmp)*T6+T8*(6.0*Vdsat-2.4*Vds));
            BSIM3cdsb = -(BSIM3cdgb+T10+BSIM3cddb);
            T7 = 2.0*(load_T1+load_T3);
            qbulk = -(qgate-load_T4*T7);
            T7 = T7 * (T9);
            load_T0 = 4.0*load_T4*(1.0-load_T5);
            T12 = (-T7*dAlphaz_dVg-BSIM3cdgb-load_T0*dVdsat_dVg)*dVgs_eff_dVg;
            T11 = -T7*dAlphaz_dVb-T10-load_T0*dVdsat_dVb;
            T10 = -4.0*load_T4*(load_T2-0.5+0.5*load_T5)-BSIM3cddb;
            load_tmp = -(T10+T11+T12);
            BSIM3cbgb = -(BSIM3cggb+BSIM3cdgb+T12);
            BSIM3cbdb = -(BSIM3cgdb+BSIM3cddb+T10);
            BSIM3cbsb = -(BSIM3cgsb+BSIM3cdsb+load_tmp);
            BSIM3qinv = -(qgate+qbulk);
          end
        end else if (Vds>=Vdsat) begin
          load_T1 = Vdsat/3.0;
          qgate = CoxWL*(Vgs_eff-Vfb-BSIM3phi-load_T1);
          load_T2 = -Two_Third_CoxWL*Vgst;
          qbulk = -(qgate+load_T2);
          qdrn = 0.5*load_T2;
          BSIM3cggb = One_Third_CoxWL*(3.0-dVdsat_dVg)*dVgs_eff_dVg;
          load_T2 = -One_Third_CoxWL*dVdsat_dVb;
          BSIM3cgsb = -(BSIM3cggb+load_T2);
          BSIM3cgdb = 0.0;
          BSIM3cdgb = -One_Third_CoxWL*dVgs_eff_dVg;
          BSIM3cddb = 0.0;
          load_T4 = One_Third_CoxWL*dVth_dVb;
          BSIM3cdsb = -(load_T4+BSIM3cdgb);
          BSIM3cbgb = -(BSIM3cggb-Two_Third_CoxWL*dVgs_eff_dVg);
          load_T3 = -(load_T2+Two_Third_CoxWL*dVth_dVb);
          BSIM3cbsb = -(BSIM3cbgb+load_T3);
          BSIM3cbdb = 0.0;
          BSIM3qinv = -(qgate+qbulk);
        end else begin
          Alphaz = Vgst/Vdsat;
          load_T1 = 2.0*Vdsat-Vds;
          load_T2 = Vds/(3.0*load_T1);
          load_T3 = load_T2*Vds;
          T9 = 0.25*CoxWL;
          load_T4 = T9*Alphaz;
          qgate = CoxWL*(Vgs_eff-Vfb-BSIM3phi-0.5*(Vds-load_T3));
          load_T5 = load_T3/load_T1;
          BSIM3cggb = CoxWL*(1.0-load_T5*dVdsat_dVg)*dVgs_eff_dVg;
          load_tmp = -CoxWL*load_T5*dVdsat_dVb;
          BSIM3cgdb = CoxWL*(load_T2-0.5+0.5*load_T5);
          BSIM3cgsb = -(BSIM3cggb+BSIM3cgdb+load_tmp);
          T6 = 1.0/Vdsat;
          dAlphaz_dVg = T6*(1.0-Alphaz*dVdsat_dVg);
          dAlphaz_dVb = -T6*(dVth_dVb+Alphaz*dVdsat_dVb);
          T7 = load_T1+load_T3;
          qdrn = -load_T4*T7;
          qbulk = -(qgate+qdrn+qdrn);
          T7 = T7 * (T9);
          load_T0 = load_T4*(2.0*load_T5-2.0);
          BSIM3cdgb = (load_T0*dVdsat_dVg-T7*dAlphaz_dVg)*dVgs_eff_dVg;
          T12 = load_T0*dVdsat_dVb-T7*dAlphaz_dVb;
          BSIM3cddb = load_T4*(1.0-2.0*load_T2-load_T5);
          BSIM3cdsb = -(BSIM3cdgb+T12+BSIM3cddb);
          BSIM3cbgb = -(BSIM3cggb+2.0*BSIM3cdgb);
          BSIM3cbdb = -(BSIM3cgdb+2.0*BSIM3cddb);
          BSIM3cbsb = -(BSIM3cgsb+2.0*BSIM3cdsb);
          BSIM3qinv = -(qgate+qbulk);
        end
      end
    end else begin
      if (Vbseff<0.0) begin
        VbseffCV = Vbseff;
        dVbseffCV_dVb = 1.0;
      end else begin
        VbseffCV = BSIM3phi-Phis;
        dVbseffCV_dVb = -dPhis_dVb;
      end
      CoxWL = BSIM3cox*BSIM3weffCV*BSIM3leffCV;
      load_noff = n*sd_BSIM3noff;
      dnoff_dVd = sd_BSIM3noff*dn_dVd;
      dnoff_dVb = sd_BSIM3noff*dn_dVb;
      load_T0 = Vtm*load_noff;
      load_voffcv = sd_BSIM3voffcv;
      VgstNVt = (Vgst-load_voffcv)/load_T0;
      if (VgstNVt>34.0) begin
        Vgsteff = Vgst-load_voffcv;
        dVgsteff_dVg = dVgs_eff_dVg;
        dVgsteff_dVd = -dVth_dVd;
        dVgsteff_dVb = -dVth_dVb;
      end else if (VgstNVt<-34.0) begin
        Vgsteff = load_T0*ln(1.0+1.713908431e-15);
        dVgsteff_dVg = 0.0;
        dVgsteff_dVd = Vgsteff/load_noff;
        dVgsteff_dVb = dVgsteff_dVd*dnoff_dVb;
        dVgsteff_dVd = dVgsteff_dVd * (dnoff_dVd);
      end else begin
        ExpVgst = exp(VgstNVt);
        Vgsteff = load_T0*ln(1.0+ExpVgst);
        dVgsteff_dVg = ExpVgst/(1.0+ExpVgst);
        dVgsteff_dVd = -dVgsteff_dVg*(dVth_dVd+(Vgst-load_voffcv)/load_noff*dnoff_dVd)+Vgsteff/load_noff*dnoff_dVd;
        dVgsteff_dVb = -dVgsteff_dVg*(dVth_dVb+(Vgst-load_voffcv)/load_noff*dnoff_dVb)+Vgsteff/load_noff*dnoff_dVb;
        dVgsteff_dVg = dVgsteff_dVg * (dVgs_eff_dVg);
      end
      if (capmod==1) begin
        Vfb = BSIM3vfbzb;
        Arg1 = Vgs_eff-VbseffCV-Vfb-Vgsteff;
        if (Arg1<=0.0) begin
          qgate = CoxWL*Arg1;
          Cgg = CoxWL*(dVgs_eff_dVg-dVgsteff_dVg);
          Cgd = -CoxWL*dVgsteff_dVd;
          Cgb = -CoxWL*(dVbseffCV_dVb+dVgsteff_dVb);
        end else begin
          load_T0 = 0.5*BSIM3k1ox;
          load_T1 = sqrt(load_T0*load_T0+Arg1);
          load_T2 = CoxWL*load_T0/load_T1;
          qgate = CoxWL*BSIM3k1ox*(load_T1-load_T0);
          Cgg = load_T2*(dVgs_eff_dVg-dVgsteff_dVg);
          Cgd = -load_T2*dVgsteff_dVd;
          Cgb = -load_T2*(dVbseffCV_dVb+dVgsteff_dVb);
        end
        qbulk = -qgate;
        Cbg = -Cgg;
        Cbd = -Cgd;
        Cbb = -Cgb;
        One_Third_CoxWL = CoxWL/3.0;
        Two_Third_CoxWL = 2.0*One_Third_CoxWL;
        AbulkCV = Abulk0*BSIM3abulkCVfactor;
        dAbulkCV_dVb = BSIM3abulkCVfactor*dAbulk0_dVb;
        VdsatCV = Vgsteff/AbulkCV;
        if (VdsatCV<Vds) begin
          dVdsatCV_dVg = 1.0/AbulkCV;
          dVdsatCV_dVb = -VdsatCV*dAbulkCV_dVb/AbulkCV;
          load_T0 = Vgsteff-VdsatCV/3.0;
          dT0_dVg = 1.0-dVdsatCV_dVg/3.0;
          dT0_dVb = -dVdsatCV_dVb/3.0;
          qgate = qgate + (CoxWL*load_T0);
          Cgg1 = CoxWL*dT0_dVg;
          Cgb1 = CoxWL*dT0_dVb+Cgg1*dVgsteff_dVb;
          Cgd1 = Cgg1*dVgsteff_dVd;
          Cgg1 = Cgg1 * (dVgsteff_dVg);
          Cgg = Cgg + (Cgg1);
          Cgb = Cgb + (Cgb1);
          Cgd = Cgd + (Cgd1);
          load_T0 = VdsatCV-Vgsteff;
          dT0_dVg = dVdsatCV_dVg-1.0;
          dT0_dVb = dVdsatCV_dVb;
          qbulk = qbulk + (One_Third_CoxWL*load_T0);
          Cbg1 = One_Third_CoxWL*dT0_dVg;
          Cbb1 = One_Third_CoxWL*dT0_dVb+Cbg1*dVgsteff_dVb;
          Cbd1 = Cbg1*dVgsteff_dVd;
          Cbg1 = Cbg1 * (dVgsteff_dVg);
          Cbg = Cbg + (Cbg1);
          Cbb = Cbb + (Cbb1);
          Cbd = Cbd + (Cbd1);
          if (xpart>0.5) begin
            load_T0 = -Two_Third_CoxWL;
          end else if (xpart<0.5) begin
            load_T0 = -0.4*CoxWL;
          end else begin
            load_T0 = -One_Third_CoxWL;
          end
          qsrc = load_T0*Vgsteff;
          Csg = load_T0*dVgsteff_dVg;
          Csb = load_T0*dVgsteff_dVb;
          Csd = load_T0*dVgsteff_dVd;
          Cgb = Cgb * (dVbseff_dVb);
          Cbb = Cbb * (dVbseff_dVb);
          Csb = Csb * (dVbseff_dVb);
        end else begin
          load_T0 = AbulkCV*Vds;
          load_T1 = 12.0*(Vgsteff-0.5*load_T0+1.0e-20);
          load_T2 = Vds/load_T1;
          load_T3 = load_T0*load_T2;
          dT3_dVg = -12.0*load_T2*load_T2*AbulkCV;
          dT3_dVd = 6.0*load_T0*(4.0*Vgsteff-load_T0)/load_T1/load_T1-0.5;
          dT3_dVb = 12.0*load_T2*load_T2*dAbulkCV_dVb*Vgsteff;
          qgate = qgate + (CoxWL*(Vgsteff-0.5*Vds+load_T3));
          Cgg1 = CoxWL*(1.0+dT3_dVg);
          Cgb1 = CoxWL*dT3_dVb+Cgg1*dVgsteff_dVb;
          Cgd1 = CoxWL*dT3_dVd+Cgg1*dVgsteff_dVd;
          Cgg1 = Cgg1 * (dVgsteff_dVg);
          Cgg = Cgg + (Cgg1);
          Cgb = Cgb + (Cgb1);
          Cgd = Cgd + (Cgd1);
          qbulk = qbulk + (CoxWL*(1.0-AbulkCV)*(0.5*Vds-load_T3));
          Cbg1 = -CoxWL*((1.0-AbulkCV)*dT3_dVg);
          Cbb1 = -CoxWL*((1.0-AbulkCV)*dT3_dVb+(0.5*Vds-load_T3)*dAbulkCV_dVb)+Cbg1*dVgsteff_dVb;
          Cbd1 = -CoxWL*(1.0-AbulkCV)*dT3_dVd+Cbg1*dVgsteff_dVd;
          Cbg1 = Cbg1 * (dVgsteff_dVg);
          Cbg = Cbg + (Cbg1);
          Cbb = Cbb + (Cbb1);
          Cbd = Cbd + (Cbd1);
          if (xpart>0.5) begin
            load_T1 = load_T1+load_T1;
            qsrc = -CoxWL*(0.5*Vgsteff+0.25*load_T0-load_T0*load_T0/load_T1);
            Csg = -CoxWL*(0.5+24.0*load_T0*Vds/load_T1/load_T1*AbulkCV);
            Csb = -CoxWL*(0.25*Vds*dAbulkCV_dVb-12.0*load_T0*Vds/load_T1/load_T1*(4.0*Vgsteff-load_T0)*dAbulkCV_dVb)+Csg*dVgsteff_dVb;
            Csd = -CoxWL*(0.25*AbulkCV-12.0*AbulkCV*load_T0/load_T1/load_T1*(4.0*Vgsteff-load_T0))+Csg*dVgsteff_dVd;
            Csg = Csg * (dVgsteff_dVg);
          end else if (xpart<0.5) begin
            load_T1 = load_T1/12.0;
            load_T2 = 0.5*CoxWL/(load_T1*load_T1);
            load_T3 = Vgsteff*(2.0*load_T0*load_T0/3.0+Vgsteff*(Vgsteff-4.0*load_T0/3.0))-2.0*load_T0*load_T0*load_T0/15.0;
            qsrc = -load_T2*load_T3;
            load_T4 = 4.0/3.0*Vgsteff*(Vgsteff-load_T0)+0.4*load_T0*load_T0;
            Csg = -2.0*qsrc/load_T1-load_T2*(Vgsteff*(3.0*Vgsteff-8.0*load_T0/3.0)+2.0*load_T0*load_T0/3.0);
            Csb = (qsrc/load_T1*Vds+load_T2*load_T4*Vds)*dAbulkCV_dVb+Csg*dVgsteff_dVb;
            Csd = (qsrc/load_T1+load_T2*load_T4)*AbulkCV+Csg*dVgsteff_dVd;
            Csg = Csg * (dVgsteff_dVg);
          end else begin
            qsrc = -0.5*(qgate+qbulk);
            Csg = -0.5*(Cgg1+Cbg1);
            Csb = -0.5*(Cgb1+Cbb1);
            Csd = -0.5*(Cgd1+Cbd1);
          end
          Cgb = Cgb * (dVbseff_dVb);
          Cbb = Cbb * (dVbseff_dVb);
          Csb = Csb * (dVbseff_dVb);
        end
        qdrn = -(qgate+qbulk+qsrc);
        BSIM3cggb = Cgg;
        BSIM3cgsb = -(Cgg+Cgd+Cgb);
        BSIM3cgdb = Cgd;
        BSIM3cdgb = -(Cgg+Cbg+Csg);
        BSIM3cdsb = Cgg+Cgd+Cgb+Cbg+Cbd+Cbb+Csg+Csd+Csb;
        BSIM3cddb = -(Cgd+Cbd+Csd);
        BSIM3cbgb = Cbg;
        BSIM3cbsb = -(Cbg+Cbd+Cbb);
        BSIM3cbdb = Cbd;
        BSIM3qinv = -(qgate+qbulk);
      end else if (capmod==2) begin
        Vfb = BSIM3vfbzb;
        V3 = Vfb-Vgs_eff+VbseffCV-0.02;
        if (Vfb<=0.0) begin
          load_T0 = sqrt(V3*V3-4.0*0.02*Vfb);
          load_T2 = -0.02/load_T0;
        end else begin
          load_T0 = sqrt(V3*V3+4.0*0.02*Vfb);
          load_T2 = 0.02/load_T0;
        end
        load_T1 = 0.5*(1.0+V3/load_T0);
        Vfbeff = Vfb-0.5*(V3+load_T0);
        dVfbeff_dVg = load_T1*dVgs_eff_dVg;
        dVfbeff_dVb = -load_T1*dVbseffCV_dVb;
        Qac0 = CoxWL*(Vfbeff-Vfb);
        dQac0_dVg = CoxWL*dVfbeff_dVg;
        dQac0_dVb = CoxWL*dVfbeff_dVb;
        load_T0 = 0.5*BSIM3k1ox;
        load_T3 = Vgs_eff-Vfbeff-VbseffCV-Vgsteff;
        if (BSIM3k1ox==0.0) begin
          load_T1 = 0.0;
          load_T2 = 0.0;
        end else if (load_T3<0.0) begin
          load_T1 = load_T0+load_T3/BSIM3k1ox;
          load_T2 = CoxWL;
        end else begin
          load_T1 = sqrt(load_T0*load_T0+load_T3);
          load_T2 = CoxWL*load_T0/load_T1;
        end
        Qsub0 = CoxWL*BSIM3k1ox*(load_T1-load_T0);
        dQsub0_dVg = load_T2*(dVgs_eff_dVg-dVfbeff_dVg-dVgsteff_dVg);
        dQsub0_dVd = -load_T2*dVgsteff_dVd;
        dQsub0_dVb = -load_T2*(dVfbeff_dVb+dVbseffCV_dVb+dVgsteff_dVb);
        AbulkCV = Abulk0*BSIM3abulkCVfactor;
        dAbulkCV_dVb = BSIM3abulkCVfactor*dAbulk0_dVb;
        VdsatCV = Vgsteff/AbulkCV;
        V4 = VdsatCV-Vds-0.02;
        load_T0 = sqrt(V4*V4+4.0*0.02*VdsatCV);
        VdseffCV = VdsatCV-0.5*(V4+load_T0);
        load_T1 = 0.5*(1.0+V4/load_T0);
        load_T2 = 0.02/load_T0;
        load_T3 = (1.0-load_T1-load_T2)/AbulkCV;
        dVdseffCV_dVg = load_T3;
        dVdseffCV_dVd = load_T1;
        dVdseffCV_dVb = -load_T3*VdsatCV*dAbulkCV_dVb;
        if (Vds==0.0) begin
          VdseffCV = 0.0;
          dVdseffCV_dVg = 0.0;
          dVdseffCV_dVb = 0.0;
        end
        load_T0 = AbulkCV*VdseffCV;
        load_T1 = 12.0*(Vgsteff-0.5*load_T0+1e-20);
        load_T2 = VdseffCV/load_T1;
        load_T3 = load_T0*load_T2;
        load_T4 = 1.0-12.0*load_T2*load_T2*AbulkCV;
        load_T5 = 6.0*load_T0*(4.0*Vgsteff-load_T0)/(load_T1*load_T1)-0.5;
        T6 = 12.0*load_T2*load_T2*Vgsteff;
        qinoi = -CoxWL*(Vgsteff-0.5*load_T0+AbulkCV*load_T3);
        qgate = CoxWL*(Vgsteff-0.5*VdseffCV+load_T3);
        Cgg1 = CoxWL*(load_T4+load_T5*dVdseffCV_dVg);
        Cgd1 = CoxWL*load_T5*dVdseffCV_dVd+Cgg1*dVgsteff_dVd;
        Cgb1 = CoxWL*(load_T5*dVdseffCV_dVb+T6*dAbulkCV_dVb)+Cgg1*dVgsteff_dVb;
        Cgg1 = Cgg1 * (dVgsteff_dVg);
        T7 = 1.0-AbulkCV;
        qbulk = CoxWL*T7*(0.5*VdseffCV-load_T3);
        load_T4 = -T7*(load_T4-1.0);
        load_T5 = -T7*load_T5;
        T6 = -(T7*T6+(0.5*VdseffCV-load_T3));
        Cbg1 = CoxWL*(load_T4+load_T5*dVdseffCV_dVg);
        Cbd1 = CoxWL*load_T5*dVdseffCV_dVd+Cbg1*dVgsteff_dVd;
        Cbb1 = CoxWL*(load_T5*dVdseffCV_dVb+T6*dAbulkCV_dVb)+Cbg1*dVgsteff_dVb;
        Cbg1 = Cbg1 * (dVgsteff_dVg);
        if (xpart>0.5) begin
          load_T1 = load_T1+load_T1;
          qsrc = -CoxWL*(0.5*Vgsteff+0.25*load_T0-load_T0*load_T0/load_T1);
          T7 = (4.0*Vgsteff-load_T0)/(load_T1*load_T1);
          load_T4 = -(0.5+24.0*load_T0*load_T0/(load_T1*load_T1));
          load_T5 = -(0.25*AbulkCV-12.0*AbulkCV*load_T0*T7);
          T6 = -(0.25*VdseffCV-12.0*load_T0*VdseffCV*T7);
          Csg = CoxWL*(load_T4+load_T5*dVdseffCV_dVg);
          Csd = CoxWL*load_T5*dVdseffCV_dVd+Csg*dVgsteff_dVd;
          Csb = CoxWL*(load_T5*dVdseffCV_dVb+T6*dAbulkCV_dVb)+Csg*dVgsteff_dVb;
          Csg = Csg * (dVgsteff_dVg);
        end else if (xpart<0.5) begin
          load_T1 = load_T1/12.0;
          load_T2 = 0.5*CoxWL/(load_T1*load_T1);
          load_T3 = Vgsteff*(2.0*load_T0*load_T0/3.0+Vgsteff*(Vgsteff-4.0*load_T0/3.0))-2.0*load_T0*load_T0*load_T0/15.0;
          qsrc = -load_T2*load_T3;
          T7 = 4.0/3.0*Vgsteff*(Vgsteff-load_T0)+0.4*load_T0*load_T0;
          load_T4 = -2.0*qsrc/load_T1-load_T2*(Vgsteff*(3.0*Vgsteff-8.0*load_T0/3.0)+2.0*load_T0*load_T0/3.0);
          load_T5 = (qsrc/load_T1+load_T2*T7)*AbulkCV;
          T6 = qsrc/load_T1*VdseffCV+load_T2*T7*VdseffCV;
          Csg = load_T4+load_T5*dVdseffCV_dVg;
          Csd = load_T5*dVdseffCV_dVd+Csg*dVgsteff_dVd;
          Csb = load_T5*dVdseffCV_dVb+T6*dAbulkCV_dVb+Csg*dVgsteff_dVb;
          Csg = Csg * (dVgsteff_dVg);
        end else begin
          qsrc = -0.5*(qgate+qbulk);
          Csg = -0.5*(Cgg1+Cbg1);
          Csb = -0.5*(Cgb1+Cbb1);
          Csd = -0.5*(Cgd1+Cbd1);
        end
        qgate = qgate + (Qac0+Qsub0);
        qbulk = qbulk - (Qac0+Qsub0);
        qdrn = -(qgate+qbulk+qsrc);
        Cgg = dQac0_dVg+dQsub0_dVg+Cgg1;
        Cgd = dQsub0_dVd+Cgd1;
        Cgb = dQac0_dVb+dQsub0_dVb+Cgb1;
        Cbg = Cbg1-dQac0_dVg-dQsub0_dVg;
        Cbd = Cbd1-dQsub0_dVd;
        Cbb = Cbb1-dQac0_dVb-dQsub0_dVb;
        Cgb = Cgb * (dVbseff_dVb);
        Cbb = Cbb * (dVbseff_dVb);
        Csb = Csb * (dVbseff_dVb);
        BSIM3cggb = Cgg;
        BSIM3cgsb = -(Cgg+Cgd+Cgb);
        BSIM3cgdb = Cgd;
        BSIM3cdgb = -(Cgg+Cbg+Csg);
        BSIM3cdsb = Cgg+Cgd+Cgb+Cbg+Cbd+Cbb+Csg+Csd+Csb;
        BSIM3cddb = -(Cgd+Cbd+Csd);
        BSIM3cbgb = Cbg;
        BSIM3cbsb = -(Cbg+Cbd+Cbb);
        BSIM3cbdb = Cbd;
        BSIM3qinv = qinoi;
      end else if (capmod==3) begin
        V3 = BSIM3vfbzb-Vgs_eff+VbseffCV-0.02;
        if (BSIM3vfbzb<=0.0) begin
          load_T0 = sqrt(V3*V3-4.0*0.02*BSIM3vfbzb);
          load_T2 = -0.02/load_T0;
        end else begin
          load_T0 = sqrt(V3*V3+4.0*0.02*BSIM3vfbzb);
          load_T2 = 0.02/load_T0;
        end
        load_T1 = 0.5*(1.0+V3/load_T0);
        Vfbeff = BSIM3vfbzb-0.5*(V3+load_T0);
        dVfbeff_dVg = load_T1*dVgs_eff_dVg;
        dVfbeff_dVb = -load_T1*dVbseffCV_dVb;
        Cox = BSIM3cox;
        Tox = 1.0e8*tox;
        load_T0 = (Vgs_eff-VbseffCV-BSIM3vfbzb)/Tox;
        dT0_dVg = dVgs_eff_dVg/Tox;
        dT0_dVb = -dVbseffCV_dVb/Tox;
        load_tmp = load_T0*sd_BSIM3acde;
        if (-34.0<load_tmp&&load_tmp<34.0) begin
          Tcen = BSIM3ldeb*exp(load_tmp);
          dTcen_dVg = sd_BSIM3acde*Tcen;
          dTcen_dVb = dTcen_dVg*dT0_dVb;
          dTcen_dVg = dTcen_dVg * (dT0_dVg);
        end else if (load_tmp<=-34.0) begin
          Tcen = BSIM3ldeb*1.713908431e-15;
          dTcen_dVb = 0.0;
          dTcen_dVg = dTcen_dVb;
        end else begin
          Tcen = BSIM3ldeb*5.834617425e14;
          dTcen_dVb = 0.0;
          dTcen_dVg = dTcen_dVb;
        end
        LINK = 1.0e-3*tox;
        V3 = BSIM3ldeb-Tcen-LINK;
        V4 = sqrt(V3*V3+4.0*LINK*BSIM3ldeb);
        Tcen = BSIM3ldeb-0.5*(V3+V4);
        load_T1 = 0.5*(1.0+V3/V4);
        dTcen_dVg = dTcen_dVg * (load_T1);
        dTcen_dVb = dTcen_dVb * (load_T1);
        Ccen = 1.03594e-10/Tcen;
        load_T2 = Cox/(Cox+Ccen);
        Coxeff = load_T2*Ccen;
        load_T3 = -Ccen/Tcen;
        dCoxeff_dVg = load_T2*load_T2*load_T3;
        dCoxeff_dVb = dCoxeff_dVg*dTcen_dVb;
        dCoxeff_dVg = dCoxeff_dVg * (dTcen_dVg);
        CoxWLcen = CoxWL*Coxeff/Cox;
        Qac0 = CoxWLcen*(Vfbeff-BSIM3vfbzb);
        QovCox = Qac0/Coxeff;
        dQac0_dVg = CoxWLcen*dVfbeff_dVg+QovCox*dCoxeff_dVg;
        dQac0_dVb = CoxWLcen*dVfbeff_dVb+QovCox*dCoxeff_dVb;
        load_T0 = 0.5*BSIM3k1ox;
        load_T3 = Vgs_eff-Vfbeff-VbseffCV-Vgsteff;
        if (BSIM3k1ox==0.0) begin
          load_T1 = 0.0;
          load_T2 = 0.0;
        end else if (load_T3<0.0) begin
          load_T1 = load_T0+load_T3/BSIM3k1ox;
          load_T2 = CoxWLcen;
        end else begin
          load_T1 = sqrt(load_T0*load_T0+load_T3);
          load_T2 = CoxWLcen*load_T0/load_T1;
        end
        Qsub0 = CoxWLcen*BSIM3k1ox*(load_T1-load_T0);
        QovCox = Qsub0/Coxeff;
        dQsub0_dVg = load_T2*(dVgs_eff_dVg-dVfbeff_dVg-dVgsteff_dVg)+QovCox*dCoxeff_dVg;
        dQsub0_dVd = -load_T2*dVgsteff_dVd;
        dQsub0_dVb = -load_T2*(dVfbeff_dVb+dVbseffCV_dVb+dVgsteff_dVb)+QovCox*dCoxeff_dVb;
        if (BSIM3k1ox<=0.0) begin
          Denomi = 0.25*sd_BSIM3moin*Vtm;
          load_T0 = 0.5*BSIM3sqrtPhi;
        end else begin
          Denomi = sd_BSIM3moin*Vtm*BSIM3k1ox*BSIM3k1ox;
          load_T0 = BSIM3k1ox*BSIM3sqrtPhi;
        end
        load_T1 = 2.0*load_T0+Vgsteff;
        DeltaPhi = Vtm*ln(1.0+load_T1*Vgsteff/Denomi);
        dDeltaPhi_dVg = 2.0*Vtm*(load_T1-load_T0)/(Denomi+load_T1*Vgsteff);
        load_T0 = Vgsteff-DeltaPhi-0.001;
        dT0_dVg = 1.0-dDeltaPhi_dVg;
        load_T1 = sqrt(load_T0*load_T0+Vgsteff*0.004);
        VgDP = 0.5*(load_T0+load_T1);
        dVgDP_dVg = 0.5*(dT0_dVg+(load_T0*dT0_dVg+0.002)/load_T1);
        load_T3 = 4.0*(Vth-BSIM3vfbzb-BSIM3phi);
        Tox = Tox + (Tox);
        if (load_T3>=0.0) begin
          load_T0 = (Vgsteff+load_T3)/Tox;
          dT0_dVd = (dVgsteff_dVd+4.0*dVth_dVd)/Tox;
          dT0_dVb = (dVgsteff_dVb+4.0*dVth_dVb)/Tox;
        end else begin
          load_T0 = (Vgsteff+1.0e-20)/Tox;
          dT0_dVd = dVgsteff_dVd/Tox;
          dT0_dVb = dVgsteff_dVb/Tox;
        end
        load_tmp = exp(0.7*ln(load_T0));
        load_T1 = 1.0+load_tmp;
        load_T2 = 0.7*load_tmp/(load_T0*Tox);
        Tcen = 1.9e-9/load_T1;
        dTcen_dVg = -1.9e-9*load_T2/load_T1/load_T1;
        dTcen_dVd = Tox*dTcen_dVg;
        dTcen_dVb = dTcen_dVd*dT0_dVb;
        dTcen_dVd = dTcen_dVd * (dT0_dVd);
        dTcen_dVg = dTcen_dVg * (dVgsteff_dVg);
        Ccen = 1.03594e-10/Tcen;
        load_T0 = Cox/(Cox+Ccen);
        Coxeff = load_T0*Ccen;
        load_T1 = -Ccen/Tcen;
        dCoxeff_dVg = load_T0*load_T0*load_T1;
        dCoxeff_dVd = dCoxeff_dVg*dTcen_dVd;
        dCoxeff_dVb = dCoxeff_dVg*dTcen_dVb;
        dCoxeff_dVg = dCoxeff_dVg * (dTcen_dVg);
        CoxWLcen = CoxWL*Coxeff/Cox;
        AbulkCV = Abulk0*BSIM3abulkCVfactor;
        dAbulkCV_dVb = BSIM3abulkCVfactor*dAbulk0_dVb;
        VdsatCV = VgDP/AbulkCV;
        load_T0 = VdsatCV-Vds-0.02;
        dT0_dVg = dVgDP_dVg/AbulkCV;
        dT0_dVb = -VdsatCV*dAbulkCV_dVb/AbulkCV;
        load_T1 = sqrt(load_T0*load_T0+4.0*0.02*VdsatCV);
        dT1_dVg = (load_T0+0.02+0.02)/load_T1;
        dT1_dVd = -load_T0/load_T1;
        dT1_dVb = dT1_dVg*dT0_dVb;
        dT1_dVg = dT1_dVg * (dT0_dVg);
        if (load_T0>=0.0) begin
          VdseffCV = VdsatCV-0.5*(load_T0+load_T1);
          dVdseffCV_dVg = 0.5*(dT0_dVg-dT1_dVg);
          dVdseffCV_dVd = 0.5*(1.0-dT1_dVd);
          dVdseffCV_dVb = 0.5*(dT0_dVb-dT1_dVb);
        end else begin
          load_T3 = (0.02+0.02)/(load_T1-load_T0);
          load_T4 = 1.0-load_T3;
          load_T5 = VdsatCV*load_T3/(load_T1-load_T0);
          VdseffCV = VdsatCV*load_T4;
          dVdseffCV_dVg = dT0_dVg*load_T4+load_T5*(dT1_dVg-dT0_dVg);
          dVdseffCV_dVd = load_T5*(dT1_dVd+1.0);
          dVdseffCV_dVb = dT0_dVb*(1.0-load_T5)+load_T5*dT1_dVb;
        end
        if (Vds==0.0) begin
          VdseffCV = 0.0;
          dVdseffCV_dVg = 0.0;
          dVdseffCV_dVb = 0.0;
        end
        load_T0 = AbulkCV*VdseffCV;
        load_T1 = VgDP;
        load_T2 = 12.0*(load_T1-0.5*load_T0+1.0e-20);
        load_T3 = load_T0/load_T2;
        load_T4 = 1.0-12.0*load_T3*load_T3;
        load_T5 = AbulkCV*(6.0*load_T0*(4.0*load_T1-load_T0)/(load_T2*load_T2)-0.5);
        T6 = load_T5*VdseffCV/AbulkCV;
        qinoi = CoxWLcen*(load_T1-load_T0*(0.5-load_T3));
        qgate = qinoi;
        QovCox = qgate/Coxeff;
        Cgg1 = CoxWLcen*(load_T4*dVgDP_dVg+load_T5*dVdseffCV_dVg);
        Cgd1 = CoxWLcen*load_T5*dVdseffCV_dVd+Cgg1*dVgsteff_dVd+QovCox*dCoxeff_dVd;
        Cgb1 = CoxWLcen*(load_T5*dVdseffCV_dVb+T6*dAbulkCV_dVb)+Cgg1*dVgsteff_dVb+QovCox*dCoxeff_dVb;
        Cgg1 = Cgg1*dVgsteff_dVg+QovCox*dCoxeff_dVg;
        T7 = 1.0-AbulkCV;
        T8 = load_T2*load_T2;
        T9 = 12.0*T7*load_T0*load_T0/(T8*AbulkCV);
        T10 = T9*dVgDP_dVg;
        T11 = -T7*load_T5/AbulkCV;
        T12 = -(T9*load_T1/AbulkCV+VdseffCV*(0.5-load_T0/load_T2));
        qbulk = CoxWLcen*T7*(0.5*VdseffCV-load_T0*VdseffCV/load_T2);
        QovCox = qbulk/Coxeff;
        Cbg1 = CoxWLcen*(T10+T11*dVdseffCV_dVg);
        Cbd1 = CoxWLcen*T11*dVdseffCV_dVd+Cbg1*dVgsteff_dVd+QovCox*dCoxeff_dVd;
        Cbb1 = CoxWLcen*(T11*dVdseffCV_dVb+T12*dAbulkCV_dVb)+Cbg1*dVgsteff_dVb+QovCox*dCoxeff_dVb;
        Cbg1 = Cbg1*dVgsteff_dVg+QovCox*dCoxeff_dVg;
        if (xpart>0.5) begin
          qsrc = -CoxWLcen*(load_T1/2.0+load_T0/4.0-0.5*load_T0*load_T0/load_T2);
          QovCox = qsrc/Coxeff;
          load_T2 = load_T2 + (load_T2);
          load_T3 = load_T2*load_T2;
          T7 = -(0.25-12.0*load_T0*(4.0*load_T1-load_T0)/load_T3);
          load_T4 = -(0.5+24.0*load_T0*load_T0/load_T3)*dVgDP_dVg;
          load_T5 = T7*AbulkCV;
          T6 = T7*VdseffCV;
          Csg = CoxWLcen*(load_T4+load_T5*dVdseffCV_dVg);
          Csd = CoxWLcen*load_T5*dVdseffCV_dVd+Csg*dVgsteff_dVd+QovCox*dCoxeff_dVd;
          Csb = CoxWLcen*(load_T5*dVdseffCV_dVb+T6*dAbulkCV_dVb)+Csg*dVgsteff_dVb+QovCox*dCoxeff_dVb;
          Csg = Csg*dVgsteff_dVg+QovCox*dCoxeff_dVg;
        end else if (xpart<0.5) begin
          load_T2 = load_T2/12.0;
          load_T3 = 0.5*CoxWLcen/(load_T2*load_T2);
          load_T4 = load_T1*(2.0*load_T0*load_T0/3.0+load_T1*(load_T1-4.0*load_T0/3.0))-2.0*load_T0*load_T0*load_T0/15.0;
          qsrc = -load_T3*load_T4;
          QovCox = qsrc/Coxeff;
          T8 = 4.0/3.0*load_T1*(load_T1-load_T0)+0.4*load_T0*load_T0;
          load_T5 = -2.0*qsrc/load_T2-load_T3*(load_T1*(3.0*load_T1-8.0*load_T0/3.0)+2.0*load_T0*load_T0/3.0);
          T6 = AbulkCV*(qsrc/load_T2+load_T3*T8);
          T7 = T6*VdseffCV/AbulkCV;
          Csg = load_T5*dVgDP_dVg+T6*dVdseffCV_dVg;
          Csd = Csg*dVgsteff_dVd+T6*dVdseffCV_dVd+QovCox*dCoxeff_dVd;
          Csb = Csg*dVgsteff_dVb+T6*dVdseffCV_dVb+T7*dAbulkCV_dVb+QovCox*dCoxeff_dVb;
          Csg = Csg*dVgsteff_dVg+QovCox*dCoxeff_dVg;
        end else begin
          qsrc = -0.5*qgate;
          Csg = -0.5*Cgg1;
          Csd = -0.5*Cgd1;
          Csb = -0.5*Cgb1;
        end
        qgate = qgate + (Qac0+Qsub0-qbulk);
        qbulk = qbulk - (Qac0+Qsub0);
        qdrn = -(qgate+qbulk+qsrc);
        Cbg = Cbg1-dQac0_dVg-dQsub0_dVg;
        Cbd = Cbd1-dQsub0_dVd;
        Cbb = Cbb1-dQac0_dVb-dQsub0_dVb;
        Cgg = Cgg1-Cbg;
        Cgd = Cgd1-Cbd;
        Cgb = Cgb1-Cbb;
        Cgb = Cgb * (dVbseff_dVb);
        Cbb = Cbb * (dVbseff_dVb);
        Csb = Csb * (dVbseff_dVb);
        BSIM3cggb = Cgg;
        BSIM3cgsb = -(Cgg+Cgd+Cgb);
        BSIM3cgdb = Cgd;
        BSIM3cdgb = -(Cgg+Cbg+Csg);
        BSIM3cdsb = Cgg+Cgd+Cgb+Cbg+Cbd+Cbb+Csg+Csd+Csb;
        BSIM3cddb = -(Cgd+Cbd+Csd);
        BSIM3cbgb = Cbg;
        BSIM3cbsb = -(Cbg+Cbd+Cbb);
        BSIM3cbdb = Cbd;
        BSIM3qinv = -qinoi;
      end
    end
    BSIM3qgate = qgate;
    BSIM3qbulk = qbulk;
    BSIM3qdrn = qdrn;
    BSIM3cd = cdrain;
    if (acm==0) begin
      czbd = BSIM3unitAreaTempJctCap*BSIM3drainArea;
      czbs = BSIM3unitAreaTempJctCap*BSIM3sourceArea;
      if (BSIM3drainPerimeter<BSIM3weff) begin
        czbdswg = BSIM3unitLengthGateSidewallTempJctCap*BSIM3drainPerimeter;
        czbdsw = 0.0;
      end else begin
        czbdsw = BSIM3unitLengthSidewallTempJctCap*(BSIM3drainPerimeter-BSIM3weff);
        czbdswg = BSIM3unitLengthGateSidewallTempJctCap*BSIM3weff;
      end
      if (BSIM3sourcePerimeter<BSIM3weff) begin
        czbssw = 0.0;
        czbsswg = BSIM3unitLengthGateSidewallTempJctCap*BSIM3sourcePerimeter;
      end else begin
        czbssw = BSIM3unitLengthSidewallTempJctCap*(BSIM3sourcePerimeter-BSIM3weff);
        czbsswg = BSIM3unitLengthGateSidewallTempJctCap*BSIM3weff;
      end
    end
    MJ = mj;
    MJSW = mjsw;
    MJSWG = BSIM3bulkJctGateSideGradingCoeff;
    if (load_vbs==0.0) begin
      BSIM3qbs = 0.0;
      BSIM3capbs = czbs+czbssw+czbsswg;
    end else if (load_vbs<0.0) begin
      if (czbs>0.0) begin
        arg = 1.0-load_vbs/BSIM3PhiB;
        if (MJ==0.5) begin
          sarg = 1.0/sqrt(arg);
        end else begin
          sarg = exp(-MJ*ln(arg));
        end
        BSIM3qbs = BSIM3PhiB*czbs*(1.0-arg*sarg)/(1.0-MJ);
        BSIM3capbs = czbs*sarg;
      end else begin
        BSIM3qbs = 0.0;
        BSIM3capbs = 0.0;
      end
      if (czbssw>0.0) begin
        arg = 1.0-load_vbs/BSIM3PhiBSW;
        if (MJSW==0.5) begin
          sarg = 1.0/sqrt(arg);
        end else begin
          sarg = exp(-MJSW*ln(arg));
        end
        BSIM3qbs = BSIM3qbs + (BSIM3PhiBSW*czbssw*(1.0-arg*sarg)/(1.0-MJSW));
        BSIM3capbs = BSIM3capbs + (czbssw*sarg);
      end
      if (czbsswg>0.0) begin
        arg = 1.0-load_vbs/BSIM3PhiBSWG;
        if (MJSWG==0.5) begin
          sarg = 1.0/sqrt(arg);
        end else begin
          sarg = exp(-MJSWG*ln(arg));
        end
        BSIM3qbs = BSIM3qbs + (BSIM3PhiBSWG*czbsswg*(1.0-arg*sarg)/(1.0-MJSWG));
        BSIM3capbs = BSIM3capbs + (czbsswg*sarg);
      end
    end else begin
      load_T0 = czbs+czbssw+czbsswg;
      load_T1 = load_vbs*(czbs*MJ/BSIM3PhiB+czbssw*MJSW/BSIM3PhiBSW+czbsswg*MJSWG/BSIM3PhiBSWG);
      BSIM3qbs = load_vbs*(load_T0+0.5*load_T1);
      BSIM3capbs = load_T0+load_T1;
    end
    if (vbd==0.0) begin
      BSIM3qbd = 0.0;
      BSIM3capbd = czbd+czbdsw+czbdswg;
    end else if (vbd<0.0) begin
      if (czbd>0.0) begin
        arg = 1.0-vbd/BSIM3PhiB;
        if (MJ==0.5) begin
          sarg = 1.0/sqrt(arg);
        end else begin
          sarg = exp(-MJ*ln(arg));
        end
        BSIM3qbd = BSIM3PhiB*czbd*(1.0-arg*sarg)/(1.0-MJ);
        BSIM3capbd = czbd*sarg;
      end else begin
        BSIM3qbd = 0.0;
        BSIM3capbd = 0.0;
      end
      if (czbdsw>0.0) begin
        arg = 1.0-vbd/BSIM3PhiBSW;
        if (MJSW==0.5) begin
          sarg = 1.0/sqrt(arg);
        end else begin
          sarg = exp(-MJSW*ln(arg));
        end
        BSIM3qbd = BSIM3qbd + (BSIM3PhiBSW*czbdsw*(1.0-arg*sarg)/(1.0-MJSW));
        BSIM3capbd = BSIM3capbd + (czbdsw*sarg);
      end
      if (czbdswg>0.0) begin
        arg = 1.0-vbd/BSIM3PhiBSWG;
        if (MJSWG==0.5) begin
          sarg = 1.0/sqrt(arg);
        end else begin
          sarg = exp(-MJSWG*ln(arg));
        end
        BSIM3qbd = BSIM3qbd + (BSIM3PhiBSWG*czbdswg*(1.0-arg*sarg)/(1.0-MJSWG));
        BSIM3capbd = BSIM3capbd + (czbdswg*sarg);
      end
    end else begin
      load_T0 = czbd+czbdsw+czbdswg;
      load_T1 = vbd*(czbd*MJ/BSIM3PhiB+czbdsw*MJSW/BSIM3PhiBSW+czbdswg*MJSWG/BSIM3PhiBSWG);
      BSIM3qbd = vbd*(load_T0+0.5*load_T1);
      BSIM3capbd = load_T0+load_T1;
    end
    BSIM3vbs = load_vbs;
    BSIM3vbd = vbd;
    BSIM3vgs = load_vgs;
    BSIM3vds = load_vds;
    BSIM3qdef = qdef;
    if (i_BSIM3nqsMod||i_BSIM3acnqsMod) begin
      qcheq = -(qbulk+qgate);
      BSIM3cqgb = -(BSIM3cggb+BSIM3cbgb);
      BSIM3cqdb = -(BSIM3cgdb+BSIM3cbdb);
      BSIM3cqsb = -(BSIM3cgsb+BSIM3cbsb);
      BSIM3cqbb = -(BSIM3cqgb+BSIM3cqdb+BSIM3cqsb);
      gtau_drift = abs(BSIM3tconst*qcheq)*ScalingFactor;
      load_T0 = BSIM3leffCV*BSIM3leffCV;
      gtau_diff = 16.0*BSIM3u0temp*BSIM3vtm/load_T0*ScalingFactor;
      BSIM3gtau = gtau_drift+gtau_diff;
      if (i_BSIM3acnqsMod) begin
        BSIM3taunet = ScalingFactor/BSIM3gtau;
      end
    end
    if (capmod==0) begin
      load_cgdo = sd_BSIM3cgdo;
      qgdo = sd_BSIM3cgdo*vgd;
      load_cgso = sd_BSIM3cgso;
      qgso = sd_BSIM3cgso*load_vgs;
    end else if (capmod==1) begin
      if (vgd<0.0) begin
        load_T1 = sqrt(1.0-4.0*vgd/sd_BSIM3ckappa);
        load_cgdo = sd_BSIM3cgdo+BSIM3weffCV*sd_BSIM3cgdl/load_T1;
        qgdo = sd_BSIM3cgdo*vgd-BSIM3weffCV*0.5*sd_BSIM3cgdl*sd_BSIM3ckappa*(load_T1-1.0);
      end else begin
        load_cgdo = sd_BSIM3cgdo+BSIM3weffCV*sd_BSIM3cgdl;
        qgdo = (BSIM3weffCV*sd_BSIM3cgdl+sd_BSIM3cgdo)*vgd;
      end
      if (load_vgs<0.0) begin
        load_T1 = sqrt(1.0-4.0*load_vgs/sd_BSIM3ckappa);
        load_cgso = sd_BSIM3cgso+BSIM3weffCV*sd_BSIM3cgsl/load_T1;
        qgso = sd_BSIM3cgso*load_vgs-BSIM3weffCV*0.5*sd_BSIM3cgsl*sd_BSIM3ckappa*(load_T1-1.0);
      end else begin
        load_cgso = sd_BSIM3cgso+BSIM3weffCV*sd_BSIM3cgsl;
        qgso = (BSIM3weffCV*sd_BSIM3cgsl+sd_BSIM3cgso)*load_vgs;
      end
    end else begin
      load_T0 = vgd+0.02;
      load_T1 = sqrt(load_T0*load_T0+4.0*0.02);
      load_T2 = 0.5*(load_T0-load_T1);
      load_T3 = BSIM3weffCV*sd_BSIM3cgdl;
      load_T4 = sqrt(1.0-4.0*load_T2/sd_BSIM3ckappa);
      load_cgdo = sd_BSIM3cgdo+load_T3-load_T3*(1.0-1.0/load_T4)*(0.5-0.5*load_T0/load_T1);
      qgdo = (sd_BSIM3cgdo+load_T3)*vgd-load_T3*(load_T2+0.5*sd_BSIM3ckappa*(load_T4-1.0));
      load_T0 = load_vgs+0.02;
      load_T1 = sqrt(load_T0*load_T0+4.0*0.02);
      load_T2 = 0.5*(load_T0-load_T1);
      load_T3 = BSIM3weffCV*sd_BSIM3cgsl;
      load_T4 = sqrt(1.0-4.0*load_T2/sd_BSIM3ckappa);
      load_cgso = sd_BSIM3cgso+load_T3-load_T3*(1.0-1.0/load_T4)*(0.5-0.5*load_T0/load_T1);
      qgso = (sd_BSIM3cgso+load_T3)*load_vgs-load_T3*(load_T2+0.5*sd_BSIM3ckappa*(load_T4-1.0));
    end
    i_BSIM3cgdo = load_cgdo;
    i_BSIM3cgso = load_cgso;
    if (BSIM3mode>0) begin
      if (i_BSIM3nqsMod==0) begin
        qgd = qgdo;
        qgs = qgso;
        qgb = sd_BSIM3cgbo*vgb;
        qgate = qgate + (qgd+qgs+qgb);
        qbulk = qbulk - (qgb);
        qdrn = qdrn - (qgd);
        qsrc = -(qgate+qbulk+qdrn);
        ggts = 0.0;
        ggtb = ggts;
        ggtd = ggtb;
        ggtg = ggtd;
        sxpart = 0.6;
        dxpart = 0.4;
        ddxpart_dVs = 0.0;
        ddxpart_dVb = ddxpart_dVs;
        ddxpart_dVg = ddxpart_dVb;
        ddxpart_dVd = ddxpart_dVg;
        dsxpart_dVs = 0.0;
        dsxpart_dVb = dsxpart_dVs;
        dsxpart_dVg = dsxpart_dVb;
        dsxpart_dVd = dsxpart_dVg;
      end else begin
        if (qcheq>0.0) begin
          load_T0 = BSIM3tconst*qdef*ScalingFactor;
        end else begin
          load_T0 = -BSIM3tconst*qdef*ScalingFactor;
        end
        BSIM3gtg = load_T0*BSIM3cqgb;
        ggtg = BSIM3gtg;
        BSIM3gtd = load_T0*BSIM3cqdb;
        ggtd = BSIM3gtd;
        BSIM3gts = load_T0*BSIM3cqsb;
        ggts = BSIM3gts;
        BSIM3gtb = load_T0*BSIM3cqbb;
        ggtb = BSIM3gtb;
        CoxWL = BSIM3cox*BSIM3weffCV*BSIM3leffCV;
        if (abs(qcheq)<=1.0e-5*CoxWL) begin
          if (xpart<0.5) begin
            dxpart = 0.4;
          end else if (xpart>0.5) begin
            dxpart = 0.0;
          end else begin
            dxpart = 0.5;
          end
          ddxpart_dVs = 0.0;
          ddxpart_dVb = ddxpart_dVs;
          ddxpart_dVg = ddxpart_dVb;
          ddxpart_dVd = ddxpart_dVg;
        end else begin
          dxpart = qdrn/qcheq;
          Cdd = BSIM3cddb;
          Csd = -(BSIM3cgdb+BSIM3cddb+BSIM3cbdb);
          ddxpart_dVd = (Cdd-dxpart*(Cdd+Csd))/qcheq;
          Cdg = BSIM3cdgb;
          Csg = -(BSIM3cggb+BSIM3cdgb+BSIM3cbgb);
          ddxpart_dVg = (Cdg-dxpart*(Cdg+Csg))/qcheq;
          Cds = BSIM3cdsb;
          Css = -(BSIM3cgsb+BSIM3cdsb+BSIM3cbsb);
          ddxpart_dVs = (Cds-dxpart*(Cds+Css))/qcheq;
          ddxpart_dVb = -(ddxpart_dVd+ddxpart_dVg+ddxpart_dVs);
        end
        sxpart = 1.0-dxpart;
        dsxpart_dVd = -ddxpart_dVd;
        dsxpart_dVg = -ddxpart_dVg;
        dsxpart_dVs = -ddxpart_dVs;
        dsxpart_dVb = -(dsxpart_dVd+dsxpart_dVg+dsxpart_dVs);
        qgd = qgdo;
        qgs = qgso;
        qgb = sd_BSIM3cgbo*vgb;
        qgate = qgd+qgs+qgb;
        qbulk = -qgb;
        qdrn = -qgd;
        qsrc = -(qgate+qbulk+qdrn);
      end
    end else if (i_BSIM3nqsMod==0) begin
      qgd = qgdo;
      qgs = qgso;
      qgb = sd_BSIM3cgbo*vgb;
      qgate = qgate + (qgd+qgs+qgb);
      qbulk = qbulk - (qgb);
      qsrc = qdrn-qgs;
      qdrn = -(qgate+qbulk+qsrc);
      ggts = 0.0;
      ggtb = ggts;
      ggtd = ggtb;
      ggtg = ggtd;
      sxpart = 0.4;
      dxpart = 0.6;
      ddxpart_dVs = 0.0;
      ddxpart_dVb = ddxpart_dVs;
      ddxpart_dVg = ddxpart_dVb;
      ddxpart_dVd = ddxpart_dVg;
      dsxpart_dVs = 0.0;
      dsxpart_dVb = dsxpart_dVs;
      dsxpart_dVg = dsxpart_dVb;
      dsxpart_dVd = dsxpart_dVg;
    end else begin
      if (qcheq>0.0) begin
        load_T0 = BSIM3tconst*qdef*ScalingFactor;
      end else begin
        load_T0 = -BSIM3tconst*qdef*ScalingFactor;
      end
      BSIM3gtg = load_T0*BSIM3cqgb;
      ggtg = BSIM3gtg;
      BSIM3gtd = load_T0*BSIM3cqdb;
      ggts = BSIM3gtd;
      BSIM3gts = load_T0*BSIM3cqsb;
      ggtd = BSIM3gts;
      BSIM3gtb = load_T0*BSIM3cqbb;
      ggtb = BSIM3gtb;
      CoxWL = BSIM3cox*BSIM3weffCV*BSIM3leffCV;
      if (abs(qcheq)<=1.0e-5*CoxWL) begin
        if (xpart<0.5) begin
          sxpart = 0.4;
        end else if (xpart>0.5) begin
          sxpart = 0.0;
        end else begin
          sxpart = 0.5;
        end
        dsxpart_dVs = 0.0;
        dsxpart_dVb = dsxpart_dVs;
        dsxpart_dVg = dsxpart_dVb;
        dsxpart_dVd = dsxpart_dVg;
      end else begin
        sxpart = qdrn/qcheq;
        Css = BSIM3cddb;
        Cds = -(BSIM3cgdb+BSIM3cddb+BSIM3cbdb);
        dsxpart_dVs = (Css-sxpart*(Css+Cds))/qcheq;
        Csg = BSIM3cdgb;
        Cdg = -(BSIM3cggb+BSIM3cdgb+BSIM3cbgb);
        dsxpart_dVg = (Csg-sxpart*(Csg+Cdg))/qcheq;
        Csd = BSIM3cdsb;
        Cdd = -(BSIM3cgsb+BSIM3cdsb+BSIM3cbsb);
        dsxpart_dVd = (Csd-sxpart*(Csd+Cdd))/qcheq;
        dsxpart_dVb = -(dsxpart_dVd+dsxpart_dVg+dsxpart_dVs);
      end
      dxpart = 1.0-sxpart;
      ddxpart_dVd = -dsxpart_dVd;
      ddxpart_dVg = -dsxpart_dVg;
      ddxpart_dVs = -dsxpart_dVs;
      ddxpart_dVb = -(ddxpart_dVd+ddxpart_dVg+ddxpart_dVs);
      qgd = qgdo;
      qgs = qgso;
      qgb = sd_BSIM3cgbo*vgb;
      qgate = qgd+qgs+qgb;
      qbulk = -qgb;
      qsrc = -qgs;
      qdrn = -(qgate+qbulk+qsrc);
    end
    cqcheq = 0.0;
    cqdef = cqcheq;
    BSIM3qg = qgate;
    BSIM3qd = qdrn-BSIM3qbd;
    BSIM3qb = qbulk+BSIM3qbd+BSIM3qbs;
    if (i_BSIM3nqsMod) begin
      BSIM3qcdump = qdef*ScalingFactor;
      BSIM3qcheq = qcheq;
    end else begin
      BSIM3qcdump = 0;
      BSIM3qcheq = 0;
    end
    geq = 0;
    BSIM3cqb = ddt(BSIM3qb);
    ceq = BSIM3cqb;
    geq = 0;
    BSIM3cqg = ddt(BSIM3qg);
    ceq = BSIM3cqg;
    geq = 0;
    BSIM3cqd = ddt(BSIM3qd);
    ceq = BSIM3cqd;
    geq = 0;
    BSIM3cqcdump = ddt(BSIM3qcdump);
    ceq = BSIM3cqcdump;
    geq = 0;
    BSIM3cqcheq = ddt(BSIM3qcheq);
    ceq = BSIM3cqcheq;
    cqgate = BSIM3cqg;
    cqbulk = BSIM3cqb;
    cqdrn = BSIM3cqd;
    ceqqg = cqgate-0*vgb+0*vbd+0*load_vbs;
    ceqqb = cqbulk-0*vgb+0*vbd+0*load_vbs;
    ceqqd = cqdrn-0*vgb+0*vbd+0*load_vbs;
    if (i_BSIM3nqsMod) begin
      load_T0 = 0;
      ceqqg = ceqqg + (load_T0);
      load_T1 = 0;
      ceqqd = ceqqd - (dxpart*load_T0);
      cqdef = BSIM3cqcdump-0*qdef;
      cqcheq = BSIM3cqcheq-(0*vgb-0*vbd-0*load_vbs)+load_T0;
    end
    if (BSIM3mode>=0) begin
      Gm = BSIM3gm;
      Gmbs = BSIM3gmbs;
      FwdSum = Gm+Gmbs;
      RevSum = 0.0;
      cdreq = BSIM3type*cdrain;
      ceqbd = -BSIM3type*(BSIM3csub-BSIM3gbds*load_vds);
      ceqbs = 0.0;
      gbbdp = -BSIM3gbds;
      gbbsp = BSIM3gbds+BSIM3gbgs+BSIM3gbbs;
      gbdpg = BSIM3gbgs;
      gbdpdp = BSIM3gbds;
      gbdpb = BSIM3gbbs;
      gbdpsp = -(gbdpg+gbdpdp+gbdpb);
      gbspg = 0.0;
      gbspdp = 0.0;
      gbspb = 0.0;
      gbspsp = 0.0;
    end else begin
      Gm = -BSIM3gm;
      Gmbs = -BSIM3gmbs;
      FwdSum = 0.0;
      RevSum = -(Gm+Gmbs);
      cdreq = -BSIM3type*cdrain;
      ceqbs = -BSIM3type*(BSIM3csub+BSIM3gbds*load_vds);
      ceqbd = 0.0;
      gbbsp = -BSIM3gbds;
      gbbdp = BSIM3gbds+BSIM3gbgs+BSIM3gbbs;
      gbdpg = 0.0;
      gbdpsp = 0.0;
      gbdpb = 0.0;
      gbdpdp = 0.0;
      gbspg = BSIM3gbgs;
      gbspsp = BSIM3gbds;
      gbspb = BSIM3gbbs;
      gbspdp = -(gbspg+gbspsp+gbspb);
    end
    if (BSIM3type>0) begin
      ceqbs = ceqbs + (BSIM3cbs);
      ceqbd = ceqbd + (BSIM3cbd);
    end else begin
      ceqbs = ceqbs - (BSIM3cbs);
      ceqbd = ceqbd - (BSIM3cbd);
      ceqqg = -ceqqg;
      ceqqb = -ceqqb;
      ceqqd = -ceqqd;
      cqdef = -cqdef;
      cqcheq = -cqcheq;
    end
    load_T1 = 0;
    
    // Residuals
    I(d) <+ BSIM3drainConductance*V(d, d_int);
    I(g) <+ ceqqg;
    I(s) <+ BSIM3sourceConductance*V(s, s_int);
    I(b) <+ ceqbs+ceqbd+ceqqb;
    I(d_int) <+ BSIM3drainConductance*V(d_int, d)+-(ceqbd-cdreq-ceqqd);
    I(s_int) <+ BSIM3sourceConductance*V(s_int, s)+-(cdreq+ceqbs+ceqqg+ceqqb+ceqqd);
    I(q_int) <+ -(cqcheq-cqdef);
    if (i_BSIM3nqsMod) begin
        I(q_int) <+ BSIM3gtau * V(q_int);
        I(d_int) <+ dxpart * BSIM3gtau * V(q_int);
        I(s_int) <+ sxpart * BSIM3gtau * V(q_int);
        I(g) <+ - BSIM3gtau * V(q_int);
    end

    // Tag: noise, function: BSIM3noise
    I(d_int, d) <+ white_noise(4*(VACONSTboltz*($temperature*BSIM3drainConductance)), "rd");
    I(s_int, s) <+ white_noise(4*(VACONSTboltz*($temperature*BSIM3sourceConductance)), "rs");
    case (noimod)
      1, 
      3: begin
        I(d_int, s_int) <+ white_noise(4*(VACONSTboltz*($temperature*(2.0*abs(BSIM3gm+BSIM3gds+BSIM3gmbs)/3.0))), "id");
      end
      5, 
      6: begin
        noise_vds = ((BSIM3vds<BSIM3vdsat) ? (BSIM3vds) : (BSIM3vdsat));
        I(d_int, s_int) <+ white_noise(4*(VACONSTboltz*($temperature*((3.0-noise_vds/BSIM3vdsat)*abs(BSIM3gm+BSIM3gds+BSIM3gmbs)/3.0))), "id");
      end
      2, 
      4: begin
        I(d_int, s_int) <+ white_noise(4*(VACONSTboltz*($temperature*(BSIM3ueff*abs(BSIM3qinv)/(BSIM3leff*BSIM3leff+BSIM3ueff*abs(BSIM3qinv)*BSIM3rds)))), "id");
      end
    endcase

    case (noimod)
      1, 
      4, 
      5: begin
        flicker_psd = kf*exp(af*ln(((abs(BSIM3cd)>1E-38) ? (abs(BSIM3cd)) : (1E-38))))/(BSIM3leff*BSIM3leff*BSIM3cox);
        flicker_exp = ef;
      end
      2, 
      3, 
      6: begin
        noise_vds = BSIM3vds;
        if (noise_vds<0.0) begin
          noise_vds = -noise_vds;
        end
        // inlined: StrongInversionNoiseEval(vds, model, here, data->freq, ckt->CKTtemp) -> sne_retval
        cd = abs(BSIM3cd);
        noise_Leff = BSIM3leff-2.0*lintnoi;
        Leffsq = noise_Leff*noise_Leff;
        esat = 2.0*BSIM3vsattemp/BSIM3ueff;
        if (em<=0.0) begin
          DelClm = 0.0;
        end else begin
          noise_T0 = ((noise_vds-BSIM3Vdseff)/BSIM3litl+em)/esat;
          DelClm = BSIM3litl*ln(((noise_T0>1E-38) ? (noise_T0) : (1E-38)));
          if (DelClm<0.0) begin
            DelClm = 0.0;
          end
        end
        noise1_T1 = 1.6021766208e-19*1.6021766208e-19*8.62e-5*cd*$temperature*BSIM3ueff;
        noise_T2 = 1.0e8*BSIM3Abulk*BSIM3cox*Leffsq;
        N0 = BSIM3cox*BSIM3Vgsteff/1.6021766208e-19;
        Nl = BSIM3cox*BSIM3Vgsteff*(1.0-BSIM3AbovVgst2Vtm*BSIM3Vdseff)/1.6021766208e-19;
        noise_T3 = BSIM3oxideTrapDensityA*ln((((N0+2.0e14)/(Nl+2.0e14)>1E-38) ? ((N0+2.0e14)/(Nl+2.0e14)) : (1E-38)));
        noise_T4 = BSIM3oxideTrapDensityB*(N0-Nl);
        noise_T5 = BSIM3oxideTrapDensityC*0.5*(N0*N0-Nl*Nl);
        noise_T6 = 8.62e-5*$temperature*cd*cd;
        noise_T7 = 1.0e8*Leffsq*BSIM3weff;
        noise_T8 = BSIM3oxideTrapDensityA+BSIM3oxideTrapDensityB*Nl+BSIM3oxideTrapDensityC*Nl*Nl;
        noise_T9 = (Nl+2.0e14)*(Nl+2.0e14);
        noise1_Ssi = noise1_T1/noise_T2*(noise_T3+noise_T4+noise_T5)+noise_T6/noise_T7*DelClm*noise_T8/noise_T9;
        sne_retval = noise1_Ssi;
        // end of inlined: StrongInversionNoiseEval(vds, model, here, data->freq, ckt->CKTtemp) -> sne_retval
        Ssi = sne_retval;
        noise_T10 = BSIM3oxideTrapDensityA*8.62e-5*$temperature;
        noise_T11 = BSIM3weff*BSIM3leff*4.0e36;
        Swi = noise_T10/noise_T11*BSIM3cd*BSIM3cd;
        noise_T1 = Swi+Ssi;
        if (noise_T1>0.0) begin
          flicker_psd = Ssi*Swi/noise_T1;
          flicker_exp = ef;
        end else begin
          flicker_psd = 0.0;
          flicker_exp = ef;
        end
      end
    endcase

    I(d_int, s_int) <+ flicker_noise(flicker_psd, flicker_exp, "flicker");

    // Instance output variable computation
    gmbs = BSIM3gmbs;
    gm = BSIM3gm;
    gds = BSIM3gds;
    vdsat = BSIM3vdsat;
    vth = BSIM3von;
    id = BSIM3cd;
    vbs = BSIM3vbs;
    vgs = BSIM3vgs;
    vds = BSIM3vds;
    ibd = BSIM3cbd;
    ibs = BSIM3cbs;
    gbd = BSIM3gbd;
    gbs = BSIM3gbs;
    qb = BSIM3qb;
    qg = BSIM3qg;
    qd = BSIM3qd;
    cgg = BSIM3cggb;
    cgd = BSIM3cgdb;
    cgs = BSIM3cgsb;
    cdg = BSIM3cdgb;
    cdd = BSIM3cddb;
    cds = BSIM3cdsb;
    cbg = BSIM3cbgb;
    cbd = BSIM3cbdb;
    cbs = BSIM3cbsb;
    capbd = BSIM3capbd;
    capbs = BSIM3capbs;

    // Model output variable computation

  end
endmodule
