// Model generated by Verilog-A Distiller.
// (c)2025 Arpad Buermen. All rights reserved.
// SPDX-License-Identifier: AGPL-3.0-or-later
// 
// SPICE flavour: ngspice
// Version      : ngspice-45-84-g7f75f09ec
// Origin       : https://sourceforge.net/u/arpadbuermen/ngspice/ci/vadng-pre-46/tree/
// Date         : 2025-11-21 10:56:26 UTC
// Module name  : sp_inductor
// Model variant: default
// 
// Notes:
//   Parameter m was replaced with builtin Verilog-A parameter $mfactor.
//
//   All parameters and output variables refer to a single parallel instance,
//   even if $mfactor>1.
//
//   Model parameters tc1, tc2, and nt were renamed to model_tc1, model_tc2, 
//   and model_nt due to name conflicts with instance parameters. 
//   
//   Alias l for instance parameter inductance was added. 
//   
//   Parameter ic was removed. Initial conditions should be set via the 
//   simulator's initial conditions mechanism.
//
// CKTcircuit member mapping
//   CKTnomTemp -> ('tnom', '($simparam("tnom", 27)+273.15)')
//      CKTtemp -> (None, '$temperature')
//
// Source files and copyright information:
//   ind/inddefs.h
//   ind/ind.c
//   ind/indparam.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//   ind/indmpar.c
//     Copyright 2003 Paolo Nenzi
//     Author: 2003 Paolo Nenzi
//   ind/indask.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//   ind/indmask.c
//     Copyright 2003 Paolo Nenzi
//     Author: 2003 Paolo Nenzi
//   ind/indsetup.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles
//   ind/indtemp.c
//     Copyright 2003 Paolo Nenzi
//     Author: 2003 Paolo Nenzi
//   ind/indload.c
//     Copyright 1990 Regents of the University of California.  All rights reserved.
//     Author: 1985 Thomas L. Quarles

`include "constants.vams"
`include "disciplines.vams"

module sp_inductor(pos, neg);
  inout pos, neg;
  electrical pos, neg;
  branch (pos, neg) br;

  // Instance parameters
  (* desc = "Inductance of inductor", type = "instance" *) parameter real inductance = 0;
  aliasparam l = inductance;
  (* desc = "Instance operating temperature", type = "instance" *) parameter real temp = 0;
  (* desc = "Instance temperature difference with the rest of the circuit", type = "instance" *) parameter real dtemp = 0.0;
  (* desc = "First order temp. coefficient", type = "instance" *) parameter real tc1 = 0;
  (* desc = "Second order temp. coefficient", type = "instance" *) parameter real tc2 = 0;
  (* desc = "Scale factor", type = "instance" *) parameter real scale = 1.0;
  (* desc = "Number of turns", type = "instance" *) parameter real nt = 0.0;

  // Model parameters
  (* desc = "Model inductance" *) parameter real ind = 0.0;
  (* desc = "First order temp. coefficient" *) parameter real model_tc1 = 0.0;
  (* desc = "Second order temp. coefficient" *) parameter real model_tc2 = 0.0;
  (* desc = "Parameter measurement temperature" *) parameter real tnom = 0;
  (* desc = "Inductor cross section" *) parameter real csect = 0.0;
  (* desc = "Inductor diameter" *) parameter real dia = 0.0;
  (* desc = "Inductor length" *) parameter real length = 0.0;
  (* desc = "Model number of turns" *) parameter real model_nt = 0.0;
  (* desc = "Relative magnetic permeability" *) parameter real mu = 1.0;

  // Instance output variables
  (* desc = "Flux through inductor" *) real flux;
  (* desc = "Current through the inductor" *) real i;

  // Model output variables

  // Instance fields
  real INDinduct = 0;
  real INDinductinst = 0;
  real INDtemp = 0;
  real INDdtemp = 0;
  integer INDtempGiven = 0;

  // Model fields
  real INDmInd = 0;
  real INDtnom = 0;
  real INDcsect = 0;
  real INDspecInd = 0;
  integer INDtnomGiven = 0;

  // States
  real INDflux = 0;
  real INDvolt = 0;

  // Model parameter access locals

  // Instance parameter access locals

  // Device setup locals

  // Device temperature dependence locals
  real difference = 0;
  real factor = 0;
  real temp_tc1 = 0;
  real temp_tc2 = 0;

  // Device load locals
  integer limited = 0;
  real veq = 0;
  real req = 0;
  real newmind = 0;

  // Device noise locals

  // Global constants
  real CONSTroot2 = sqrt(2.0);
  real CONSTvt0 = 1.38064852e-23*(27+273.15)/1.6021766208e-19;
  real CONSTKoverQ = 1.38064852e-23/1.6021766208e-19;
  real CONSTe = exp(1.0);
  real VACONSTcharge = 1.6021766208e-19;
  real VACONSTboltz = 1.38064852e-23;
  real VACONST_tnom = ($simparam("tnom", 27)+273.15);

  // Evaluation constants

  // Translated function definitions
  analog function real Lundin;
    input l, csec;
    real l;
    real csec;
    real num;
    real den;
    real kk;
    real x;
    real xx;
    real xxxx;
    begin
      if (csec<1e-12||l<1e-6) begin
        $warning("coil geometries too small (< 1um length dimensions),");
        $warning("    Lundin's correction factor will not be calculated");
        Lundin = 1;
      end else begin
        x = sqrt(csec/3.141592654)*2./l;
        xx = x*x;
        xxxx = xx*xx;
        if (x<1) begin
          num = 1+0.383901*xx+0.017108*xxxx;
          den = 1+0.258952*xx;
          Lundin = num/den-4*x/(3*3.141592654);
        end else begin
          num = (ln(4*x)-0.5)*(1+0.383901/xx+0.017108/xxxx);
          den = 1+0.258952/xx;
          kk = 0.093842/xx+0.002029/xxxx-0.000801/(xx*xxxx);
          Lundin = 2*(num/den+kk)/(3.141592654*x);
        end
      end
    end
  endfunction

  // Analog block
  analog begin

    // Instance field assignments
    if ($param_given(inductance)) begin
      INDinduct = inductance;
      INDinductinst = INDinduct;
    end
    if ($param_given(temp)) begin
      INDtemp = temp+273.15;
      INDtempGiven = 1;
    end
    if ($param_given(dtemp)) begin
      INDdtemp = dtemp;
    end

    // Model field assignments
    if ($param_given(ind)) begin
      INDmInd = ind;
    end
    if ($param_given(tnom)) begin
      INDtnom = tnom+273.15;
      INDtnomGiven = 1;
    end
    if ($param_given(csect)) begin
      INDcsect = csect;
    end

    // Evaluation constants

    // Tag: setup, function: INDsetup
    if (!$param_given(ind)) begin
      INDmInd = 0.0;
    end
    if (!INDtnomGiven) begin
      INDtnom = VACONST_tnom;
    end
    if (!$param_given(csect)) begin
      INDcsect = 0.0;
    end
    if ($param_given(dia)) begin
      INDcsect = 3.141592654*dia*dia/4.;
    end
    if ($param_given(length)&&length>0.0) begin
      INDspecInd = mu*(4.0*3.1415926535897932384626433832795*1E-7)*INDcsect/length;
    end else begin
      INDspecInd = 0.0;
    end
    if ($param_given(length)&&($param_given(dia)||$param_given(csect))) begin
      INDspecInd = INDspecInd * (Lundin(length, INDcsect));
    end
    if (!$param_given(ind)) begin
      INDmInd = model_nt*model_nt*INDspecInd;
    end

    // Tag: temp, function: INDtemp
    if (!INDtempGiven) begin
      INDtemp = $temperature;
      if (!$param_given(dtemp)) begin
        INDdtemp = 0.0;
      end
    end else begin
      INDdtemp = 0.0;
      if ($param_given(dtemp)) begin
        $warning("Instance temperature specified, dtemp ignored");
      end
    end
    if (!$param_given(inductance)) begin
      if ($param_given(nt)) begin
        INDinduct = INDspecInd*nt*nt;
      end else begin
        INDinduct = INDmInd;
      end
    end else begin
      INDinduct = INDinductinst;
    end
    difference = INDtemp+INDdtemp-INDtnom;
    if ($param_given(tc1)) begin
      temp_tc1 = tc1;
    end else begin
      temp_tc1 = model_tc1;
    end
    if ($param_given(tc2)) begin
      temp_tc2 = tc2;
    end else begin
      temp_tc2 = model_tc2;
    end
    factor = 1.0+temp_tc1*difference+temp_tc2*difference*difference;
    INDinduct = INDinduct*factor*scale;

    // Tag: load, function: INDload
    limited = 0;
    INDflux = INDinduct*I(br);
    newmind = INDinduct;
    req = 0;
    INDvolt = ddt(INDflux);
    veq = INDvolt;
    
    // Residuals
    V(br) <+ req*I(br)+veq;

    // Instance output variable computation
    flux = INDflux;
    i = I(br);

    // Model output variable computation

  end
endmodule
