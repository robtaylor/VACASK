{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"VACASK Documentation","text":"<p>VACASK (Verilog-A Circuit Analysis Kernel) is an analog circuit simulator written in C++20. It uses the OpenVAF-reloaded Verilog-A compiler to build device models as shared libraries, which are loaded at runtime via the OSDI 0.4 API.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Multiple analysis types: Operating Point, Transient, AC, Noise, Harmonic Balance</li> <li>Verilog-A device models via OpenVAF-reloaded compiler</li> <li>OSDI 0.4 API for device model interface</li> <li>KLU sparse matrix solver</li> <li>Variable-order integration methods (Adams-Moulton, BDF/Gear)</li> <li>Adaptive timestep control with LTE estimation</li> <li>Homotopy methods for convergence assistance</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Run a simulation\nvacask netlist.sim\n\n# Print search paths\nvacask -dp\n\n# Print file paths being loaded\nvacask -df netlist.sim\n</code></pre>"},{"location":"#analysis-types","title":"Analysis Types","text":"<p>VACASK supports the following analysis types:</p> Analysis Command Description op <code>op</code> Operating Point (DC bias point) tran <code>tran</code> Transient (time-domain) ac <code>ac</code> AC small-signal frequency response noise <code>noise</code> Small-signal noise analysis hb <code>hb</code> Harmonic Balance (steady-state periodic) dcinc <code>dcinc</code> DC incremental (small-signal at DC) dcxf <code>dcxf</code> DC transfer function acxf <code>acxf</code> AC transfer function <p>See Analysis Types for detailed information.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Analysis Types Overview - Overview of all supported analyses</li> <li>Operating Point Analysis - Detailed OP algorithm description</li> <li>Transient Analysis - Detailed transient algorithm description</li> </ul>"},{"location":"#building","title":"Building","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>C++20 compiler (GCC/Clang)</li> <li>CMake 3.18+</li> <li>Boost 1.88 (filesystem, process, system components)</li> <li>SuiteSparse (KLU library)</li> <li>toml++ library (version 3.4)</li> <li>Bison and Flex</li> <li>OpenVAF-reloaded compiler (openvaf-r)</li> </ul>"},{"location":"#build-commands","title":"Build Commands","text":"<pre><code># Configure with Ninja\ncmake -G Ninja -S . -B build -DCMAKE_BUILD_TYPE=Release \\\n    -DOPENVAF_DIR=&lt;path-to-openvaf-r&gt; \\\n    -DBoost_ROOT=&lt;boost-directory&gt;/stage\n\n# Build\ncmake --build build\n\n# Run tests\ncd build &amp;&amp; ctest\n</code></pre>"},{"location":"#environment-variables","title":"Environment Variables","text":"Variable Description <code>SIM_INCLUDE_PATH</code> Override include files search path <code>SIM_MODULE_PATH</code> Override compiled modules search path <code>SIM_OPENVAF</code> Override OpenVAF-reloaded compiler path"},{"location":"#configuration","title":"Configuration","text":"<p>TOML configuration files are read in order:</p> <ol> <li><code>/etc/vacask/vacaskrc.toml</code> (Linux) or <code>&lt;install&gt;/lib/vacaskrc.toml</code> (Windows)</li> <li><code>~/.vacaskrc.toml</code></li> <li><code>.vacaskrc.toml</code> in startup directory</li> <li><code>.vacaskrc.toml</code> in netlist directory</li> </ol>"},{"location":"#license","title":"License","text":"<p>See the repository for license information.</p>"},{"location":"analysis_types/","title":"VACASK Analysis Types","text":"<p>This document provides an overview of all analysis types supported by VACASK.</p>"},{"location":"analysis_types/#summary","title":"Summary","text":"Analysis Command Description op <code>op</code> Operating Point (DC bias point) tran <code>tran</code> Transient (time-domain) ac <code>ac</code> AC small-signal frequency response noise <code>noise</code> Small-signal noise analysis hb <code>hb</code> Harmonic Balance (steady-state periodic) dcinc <code>dcinc</code> DC incremental (small-signal at DC) dcxf <code>dcxf</code> DC transfer function acxf <code>acxf</code> AC transfer function"},{"location":"analysis_types/#analysis-hierarchy","title":"Analysis Hierarchy","text":"<pre><code>flowchart TB\n    subgraph DC[\"DC Analyses\"]\n        OP[\"Operating Point (op)&lt;br/&gt;Solves: f(x\u2080) = 0\"]\n    end\n\n    subgraph Linear[\"Small-Signal (Linear)\"]\n        subgraph DCLinear[\"DC Small-Signal\"]\n            DCINC[\"dcinc&lt;br/&gt;DC Incremental\"]\n            DCXF[\"dcxf&lt;br/&gt;DC Transfer Function\"]\n        end\n        subgraph ACLinear[\"AC Small-Signal\"]\n            AC[\"ac&lt;br/&gt;AC Response\"]\n            ACXF[\"acxf&lt;br/&gt;AC Transfer Function\"]\n            NOISE[\"noise&lt;br/&gt;Noise Analysis\"]\n        end\n    end\n\n    subgraph NonlinearTime[\"Nonlinear Time-Domain\"]\n        TRAN[\"tran&lt;br/&gt;Transient Analysis\"]\n    end\n\n    subgraph NonlinearFreq[\"Nonlinear Frequency-Domain\"]\n        HB[\"hb&lt;br/&gt;Harmonic Balance\"]\n    end\n\n    OP --&gt; DCINC\n    OP --&gt; DCXF\n    OP --&gt; AC\n    OP --&gt; ACXF\n    OP --&gt; NOISE\n    OP --&gt; TRAN\n\n    style OP fill:#e1f5fe\n    style TRAN fill:#fff3e0\n    style HB fill:#f3e5f5\n    style AC fill:#e8f5e9\n    style ACXF fill:#e8f5e9\n    style NOISE fill:#e8f5e9\n    style DCINC fill:#fce4ec\n    style DCXF fill:#fce4ec</code></pre>"},{"location":"analysis_types/#circuit-equations","title":"Circuit Equations","text":"<p>All analyses work with the fundamental circuit DAE:</p> <pre><code>f(x(t)) + d/dt q(x(t)) = 0\n</code></pre> <p>Where: - <code>x(t)</code> \u2014 circuit unknowns (node voltages, branch currents) - <code>f(x)</code> \u2014 resistive residual (conductance contributions) - <code>q(x)</code> \u2014 reactive residual (charge/flux contributions)</p>"},{"location":"analysis_types/#1-operating-point-op","title":"1. Operating Point (<code>op</code>)","text":"<p>Purpose: Find the DC steady-state solution.</p> <p>Equation: <code>f(x\u2080) = 0</code></p> <p>Method: Newton-Raphson iteration with the resistive Jacobian.</p> <p>Output: Node voltages and branch currents at the quiescent point.</p> <p>Usage: <pre><code>op myop ()\n</code></pre></p> <p>Parameters:</p> Parameter Description <code>nodeset</code> Initial guess for node voltages <code>store</code> Name to save solution for later use <code>write</code> Enable/disable output file <p>See operating_point.md for detailed algorithm description.</p>"},{"location":"analysis_types/#2-transient-tran","title":"2. Transient (<code>tran</code>)","text":"<p>Purpose: Time-domain simulation of circuit dynamics.</p> <p>Equation: <code>f(x) + dq/dt = 0</code> integrated over time.</p> <p>Method: Variable-order implicit integration (Adams-Moulton or BDF) with adaptive timestep control and Newton-Raphson at each timepoint.</p> <p>Output: Waveforms of voltages and currents vs. time.</p> <p>Usage: <pre><code>tran mytran (stop=1u, step=1n)\n</code></pre></p> <p>Parameters:</p> Parameter Description <code>step</code> Output/initial timestep <code>stop</code> Simulation end time <code>start</code> Time to begin recording output <code>maxstep</code> Maximum allowed timestep <code>icmode</code> Initial condition mode: <code>op</code> or <code>uic</code> <code>ic</code> Initial conditions specification <p>See transient.md for detailed algorithm description.</p>"},{"location":"analysis_types/#3-ac-small-signal-ac","title":"3. AC Small-Signal (<code>ac</code>)","text":"<p>Purpose: Compute frequency response around the operating point.</p> <p>Equation: <code>(Jr + j\u03c9Jc) X = U</code></p> <p>Where: - <code>Jr</code> \u2014 resistive Jacobian at operating point - <code>Jc</code> \u2014 reactive Jacobian at operating point - <code>\u03c9 = 2\u03c0f</code> \u2014 angular frequency - <code>U</code> \u2014 AC excitation phasors (from source <code>mag</code> and <code>phase</code> parameters) - <code>X</code> \u2014 response phasors</p> <p>Method: 1. Solve operating point 2. Compute linearized Jacobians 3. For each frequency, solve complex linear system</p> <p>Output: Complex phasors for all node voltages and branch currents.</p> <p>Usage: <pre><code>ac myac (from=1, to=1G, points=100, mode=dec)\n</code></pre></p> <p>Parameters:</p> Parameter Description <code>from</code> Start frequency <code>to</code> Stop frequency <code>step</code> Frequency step (linear sweep) <code>mode</code> Sweep mode: <code>lin</code>, <code>dec</code>, <code>oct</code> <code>points</code> Number of points (per decade/octave for log) <code>values</code> Explicit frequency list"},{"location":"analysis_types/#4-noise-noise","title":"4. Noise (<code>noise</code>)","text":"<p>Purpose: Compute output noise spectral density from all noise sources.</p> <p>Method: 1. Solve operating point 2. For each frequency:    - For each noise source, solve <code>(Jr + j\u03c9Jc) X = U</code> with unit excitation    - Compute contribution to output power spectral density 3. Also compute gain from input source to output</p> <p>Output: - Individual noise source contributions (V\u00b2/Hz or A\u00b2/Hz) - Per-instance total noise - Total output noise spectral density - Power gain from input to output - Equivalent input noise</p> <p>Usage: <pre><code>noise mynoise (out=\"vout\", in=vin, from=1, to=1G, points=100, mode=dec)\n</code></pre></p> <p>Parameters:</p> Parameter Description <code>out</code> Output node or node pair <code>in</code> Input source name <code>from</code>, <code>to</code>, <code>mode</code>, <code>points</code> Frequency sweep (same as AC)"},{"location":"analysis_types/#5-harmonic-balance-hb","title":"5. Harmonic Balance (<code>hb</code>)","text":"<p>Purpose: Find the periodic steady-state for circuits with multiple excitation tones.</p> <p>Method: - Solve in the frequency domain - Newton-Raphson on spectral coefficients - Almost-Periodic Fourier Transform (APFT) between time and frequency domains - Colocation in time domain for nonlinear device evaluation</p> <pre><code>flowchart LR\n    subgraph FreqDomain[\"Frequency Domain\"]\n        SPEC[\"Spectral Coefficients&lt;br/&gt;(Phasors at each harmonic)\"]\n    end\n\n    subgraph TimeDomain[\"Time Domain\"]\n        COLOC[\"Colocation Points&lt;br/&gt;(Device evaluation)\"]\n    end\n\n    SPEC --&gt;|IAPFT| COLOC\n    COLOC --&gt;|APFT| SPEC\n\n    SPEC --&gt;|\"NR Update\"| SPEC</code></pre> <p>Features: - Multiple fundamental frequencies (multi-tone) - Box or diamond truncation for harmonic selection - Intermodulation product handling - Oversampling in time domain</p> <p>Usage: <pre><code>hb myhb (freq=[1M, 1.01M], nharm=7, truncate=diamond)\n</code></pre></p> <p>Parameters:</p> Parameter Description <code>freq</code> Fundamental frequencies <code>nharm</code> Number of harmonics per fundamental <code>immax</code> Maximum intermodulation order <code>truncate</code> Truncation scheme: <code>box</code>, <code>diamond</code>, <code>raw</code> <code>samplefac</code> Time-domain oversampling factor"},{"location":"analysis_types/#6-dc-incremental-dcinc","title":"6. DC Incremental (<code>dcinc</code>)","text":"<p>Purpose: Small-signal response at DC (\u03c9=0).</p> <p>Equation: <code>Jr \u00b7 dx = du</code></p> <p>Where <code>du</code> contains incremental excitations from source <code>mag</code> parameters.</p> <p>Method: 1. Solve operating point 2. Compute resistive Jacobian 3. Solve linear system with combined excitation</p> <p>Output: Incremental changes in all node voltages and branch currents.</p> <p>Usage: <pre><code>dcinc mydcinc ()\n</code></pre></p>"},{"location":"analysis_types/#7-dc-transfer-function-dcxf","title":"7. DC Transfer Function (<code>dcxf</code>)","text":"<p>Purpose: Compute DC transfer functions from all sources to a specified output.</p> <p>Equation: <code>Jr \u00b7 dx = du</code> (solved for each source with unit excitation)</p> <p>Output (for each independent source): - Transfer function to output node(s) - Input impedance (Zin) - Input admittance (Yin)</p> <p>Usage: <pre><code>dcxf mydcxf (out=\"vout\")\n</code></pre></p> <p>Parameters:</p> Parameter Description <code>out</code> Output node or node pair"},{"location":"analysis_types/#8-ac-transfer-function-acxf","title":"8. AC Transfer Function (<code>acxf</code>)","text":"<p>Purpose: Compute AC transfer functions from all sources to a specified output across frequency.</p> <p>Equation: <code>(Jr + j\u03c9Jc) X = U</code> (solved for each source with unit phasor excitation)</p> <p>Output (for each source, at each frequency): - Complex transfer function to output - Complex input impedance - Complex input admittance</p> <p>Usage: <pre><code>acxf myacxf (out=\"vout\", from=1, to=1G, points=100, mode=dec)\n</code></pre></p> <p>Parameters:</p> Parameter Description <code>out</code> Output node or node pair <code>from</code>, <code>to</code>, <code>mode</code>, <code>points</code> Frequency sweep (same as AC)"},{"location":"analysis_types/#comparison","title":"Comparison","text":""},{"location":"analysis_types/#when-to-use-each-analysis","title":"When to Use Each Analysis","text":"Goal Analysis Find DC bias point <code>op</code> Time-domain waveforms <code>tran</code> Frequency response (Bode plot) <code>ac</code> Noise figure, noise contributors <code>noise</code> Steady-state with RF signals <code>hb</code> DC gain <code>dcinc</code> or <code>dcxf</code> Input/output impedance at DC <code>dcxf</code> Input/output impedance vs frequency <code>acxf</code>"},{"location":"analysis_types/#computational-complexity","title":"Computational Complexity","text":"<pre><code>graph LR\n    subgraph Fast[\"Faster\"]\n        OP[\"op\"]\n        DCINC[\"dcinc\"]\n        DCXF[\"dcxf\"]\n    end\n\n    subgraph Medium[\"Medium\"]\n        AC[\"ac\"]\n        ACXF[\"acxf\"]\n        NOISE[\"noise\"]\n    end\n\n    subgraph Slow[\"Slower\"]\n        TRAN[\"tran\"]\n        HB[\"hb\"]\n    end\n\n    Fast --&gt; Medium --&gt; Slow</code></pre> <ul> <li>op, dcinc, dcxf: Single linear solve (fast)</li> <li>ac, acxf, noise: Linear solve per frequency point</li> <li>tran: Nonlinear solve per timestep (many timesteps)</li> <li>hb: Large nonlinear system in frequency domain</li> </ul>"},{"location":"analysis_types/#source-files","title":"Source Files","text":"Analysis High-Level Core Implementation op <code>lib/anop.cpp</code> <code>lib/coreop.cpp</code> tran <code>lib/antran.cpp</code> <code>lib/coretran.cpp</code> ac <code>lib/anac.cpp</code> <code>lib/coreac.cpp</code> noise <code>lib/annoise.cpp</code> <code>lib/corenoise.cpp</code> hb <code>lib/anhb.cpp</code> <code>lib/corehb.cpp</code> dcinc <code>lib/andcinc.cpp</code> <code>lib/coredcinc.cpp</code> dcxf <code>lib/andcxf.cpp</code> <code>lib/coredcxf.cpp</code> acxf <code>lib/anacxf.cpp</code> <code>lib/coreacxf.cpp</code>"},{"location":"operating_point/","title":"VACASK Operating Point Analysis","text":"<p>This document describes the steps VACASK takes when performing operating point (DC bias) analysis.</p>"},{"location":"operating_point/#overview","title":"Overview","text":"<p>Operating point analysis finds the DC steady-state solution of the circuit by solving:</p> <pre><code>f(x) = 0\n</code></pre> <p>Where: - <code>x</code> \u2014 circuit unknowns (node voltages, branch currents) - <code>f(x)</code> \u2014 resistive residual (sum of currents at each node must be zero)</p> <p>This is the foundation for all other analyses. Small-signal analyses (AC, noise, transfer functions) linearize around this operating point, and transient analysis uses it as the initial condition.</p>"},{"location":"operating_point/#key-classes","title":"Key Classes","text":"Class File Description <code>OperatingPoint</code> <code>lib/anop.cpp</code> High-level analysis wrapper <code>OperatingPointCore</code> <code>lib/coreop.cpp</code> Core OP algorithm with homotopy <code>OpNRSolver</code> <code>lib/coreopnr.cpp</code> Newton-Raphson solver for OP <code>NRSolver</code> <code>lib/nrsolver.cpp</code> Base Newton-Raphson implementation <code>Homotopy</code> <code>lib/homotopy.cpp</code> Base class for convergence aids <code>GminStepping</code> <code>lib/hmtpgmin.cpp</code> Gmin/Gshunt stepping homotopy <code>SourceStepping</code> <code>lib/hmtpsrc.cpp</code> Source stepping homotopy"},{"location":"operating_point/#analysis-parameters","title":"Analysis Parameters","text":"<p>Defined in <code>OperatingPointParameters</code> (<code>include/coreop.h:37-45</code>):</p> Parameter Default Description <code>nodeset</code> \"\" Initial guess: solution name or list of node values <code>store</code> \"\" Name to store converged solution <code>write</code> 1 Whether to write output file"},{"location":"operating_point/#high-level-algorithm-flow","title":"High-Level Algorithm Flow","text":"<pre><code>flowchart TB\n    subgraph Init[\"Initialization\"]\n        VALIDATE[\"Set time=0&lt;br/&gt;Allocate solution/state vectors\"]\n        SETTINGS[\"Configure NR settings&lt;br/&gt;(tolerances, iteration limits)\"]\n        NODESETS[\"Process nodesets&lt;br/&gt;(from parameter or stored solution)\"]\n        VALIDATE --&gt; SETTINGS --&gt; NODESETS\n    end\n\n    subgraph InitialOP[\"Initial OP Attempt\"]\n        SOLVE1[\"Run Newton-Raphson\"]\n        CHECK1{Converged?}\n        SOLVE1 --&gt; CHECK1\n    end\n\n    subgraph Homotopy[\"Homotopy Methods\"]\n        HMTSELECT[\"Select next homotopy&lt;br/&gt;from op_homotopy list\"]\n        HMTRUN[\"Run homotopy algorithm\"]\n        HMTCHECK{Converged?}\n        HMTMORE{More methods?}\n        HMTSELECT --&gt; HMTRUN --&gt; HMTCHECK\n        HMTCHECK --&gt;|No| HMTMORE\n        HMTMORE --&gt;|Yes| HMTSELECT\n    end\n\n    subgraph Output[\"Output\"]\n        WRITE[\"Write results to .raw file\"]\n        STORESOL[\"Store solution if requested\"]\n    end\n\n    Init --&gt; InitialOP\n    CHECK1 --&gt;|Yes| Output\n    CHECK1 --&gt;|No| Homotopy\n    HMTCHECK --&gt;|Yes| Output\n    HMTMORE --&gt;|No| FAIL[\"Analysis Failed\"]\n\n    style Init fill:#e3f2fd\n    style InitialOP fill:#e8f5e9\n    style Homotopy fill:#fff3e0\n    style Output fill:#f3e5f5\n    style FAIL fill:#ffcdd2</code></pre>"},{"location":"operating_point/#step-by-step-algorithm","title":"Step-by-Step Algorithm","text":""},{"location":"operating_point/#phase-1-initialization","title":"Phase 1: Initialization","text":""},{"location":"operating_point/#11-validate-and-setup","title":"1.1 Validate and Setup","text":"<p>Location: <code>coreop.cpp:407-424</code></p> <ol> <li>Set simulation time to 0</li> <li>Allocate solution and state vectors (with bucket at index 0)</li> <li>Configure Newton-Raphson settings from simulator options</li> </ol>"},{"location":"operating_point/#12-process-nodesets","title":"1.2 Process Nodesets","text":"<p>Location: <code>coreop.cpp:204-279</code></p> <p>Nodesets provide initial guesses to help convergence:</p> <p>From stored solution (string parameter): <pre><code>op myop (nodeset=\"previous_solution\")\n</code></pre> - Retrieve named solution from repository - Apply as forced values in first iterations</p> <p>From explicit list (value vector parameter): <pre><code>op myop (nodeset=[\"vdd\", 1.8, \"vout\", 0.9])\n</code></pre> - Single node: <code>[\"node\", value]</code> - Node pair (differential): <code>[\"node1\", \"node2\", value]</code></p>"},{"location":"operating_point/#13-bind-matrix-entries","title":"1.3 Bind Matrix Entries","text":"<p>Location: <code>coreop.cpp:204-209</code></p> <ul> <li>Bind resistive Jacobian entries to KLU matrix</li> <li>Reactive entries not bound (OP is DC analysis)</li> </ul>"},{"location":"operating_point/#phase-2-newton-raphson-solver","title":"Phase 2: Newton-Raphson Solver","text":""},{"location":"operating_point/#21-nr-algorithm-overview","title":"2.1 NR Algorithm Overview","text":"<pre><code>flowchart TB\n    START[\"Initialize x = 0 or nodeset\"]\n    ITER[\"Iteration j\"]\n    EVAL[\"Evaluate devices at x^j:&lt;br/&gt;\u2022 Compute residual f(x^j)&lt;br/&gt;\u2022 Compute Jacobian J(x^j)\"]\n    LIMIT[\"Apply limiting if needed&lt;br/&gt;(prevent large voltage swings)\"]\n    FORM[\"Form linear system:&lt;br/&gt;J\u00b7\u0394x = -f(x^j)\"]\n    FORCE[\"Add nodeset/IC forces&lt;br/&gt;(first iterations only)\"]\n    GSHUNT[\"Add gshunt conductances&lt;br/&gt;(if enabled)\"]\n    SOLVE[\"Solve linear system with KLU\"]\n    UPDATE[\"Update: x^(j+1) = x^j + \u0394x\"]\n    CHECKRES{Residual OK?}\n    CHECKDELTA{Delta OK?}\n    ITLIM{Iteration limit?}\n    SUCCESS[\"Converged\"]\n    FAIL[\"Failed\"]\n\n    START --&gt; ITER --&gt; EVAL --&gt; LIMIT --&gt; FORM --&gt; FORCE --&gt; GSHUNT --&gt; SOLVE --&gt; UPDATE\n    UPDATE --&gt; CHECKRES\n    CHECKRES --&gt;|No| ITLIM\n    CHECKRES --&gt;|Yes| CHECKDELTA\n    CHECKDELTA --&gt;|No| ITLIM\n    CHECKDELTA --&gt;|Yes| SUCCESS\n    ITLIM --&gt;|No| ITER\n    ITLIM --&gt;|Yes| FAIL\n\n    style SUCCESS fill:#c8e6c9\n    style FAIL fill:#ffcdd2</code></pre>"},{"location":"operating_point/#22-device-evaluation","title":"2.2 Device Evaluation","text":"<p>Location: <code>coreopnr.cpp:636-668</code></p> <p>For each device instance: 1. Evaluate at current solution point 2. Apply limiting if voltage changes are too large (prevent numerical overflow) 3. Compute Jacobian contributions (\u2202I/\u2202V for each terminal pair) 4. Compute residual contributions (current into each terminal)</p> <p>The <code>EvalSetup</code> structure controls evaluation: <pre><code>EvalSetup {\n    .staticAnalysis = true,\n    .dcAnalysis = true,\n    .enableLimiting = true,\n    .evaluateResistiveJacobian = true,\n    .evaluateResistiveResidual = true,\n}\n</code></pre></p>"},{"location":"operating_point/#23-nodeset-forces","title":"2.3 Nodeset Forces","text":"<p>Location: <code>coreopnr.cpp:781-863</code></p> <p>During early iterations (<code>iteration \u2264 op_nsiter</code>), nodesets add penalty terms:</p> <p>For a nodeset <code>v(node) = value</code>: - Jacobian: Add <code>factor</code> to diagonal entry - Residual: Add <code>factor \u00d7 (v_node - value)</code></p> <p>Where <code>factor = rowNorm \u00d7 nr_force</code> scales the penalty relative to existing entries.</p> <p>This \"soft\" forcing gradually guides the solution toward the nodeset values.</p>"},{"location":"operating_point/#24-convergence-checking","title":"2.4 Convergence Checking","text":"<p>Location: <code>coreopnr.cpp:865-1059</code></p> <p>Two convergence criteria must be satisfied:</p> <p>Residual check (<code>coreopnr.cpp:865-964</code>): <pre><code>|f_i(x)| \u2264 max(reltol \u00d7 refval, abstol_i)\n</code></pre> Where <code>refval</code> depends on <code>relrefres</code> option (local, global, etc.)</p> <p>Delta check (<code>coreopnr.cpp:966-1059</code>): <pre><code>|\u0394x_i| \u2264 max(reltol \u00d7 refval, abstol_i)\n</code></pre> Where <code>refval</code> depends on <code>relrefsol</code> option.</p> <p>Both checks must pass, and limiting must not have been applied.</p>"},{"location":"operating_point/#phase-3-homotopy-methods","title":"Phase 3: Homotopy Methods","text":"<p>When initial NR fails, VACASK tries homotopy methods to aid convergence.</p> <pre><code>flowchart TB\n    subgraph GminStepping[\"Gmin/Gshunt Stepping\"]\n        direction TB\n        G1[\"Start with large gmin&lt;br/&gt;(easier to solve)\"]\n        G2[\"Solve at current gmin\"]\n        G3{Converged?}\n        G4[\"Reduce gmin\"]\n        G5{gmin \u2264 target?}\n        G6[\"Increase step size\"]\n        G7[\"Decrease step size&lt;br/&gt;or restore previous\"]\n        G1 --&gt; G2 --&gt; G3\n        G3 --&gt;|Yes| G5\n        G5 --&gt;|No| G4 --&gt; G6 --&gt; G2\n        G3 --&gt;|No| G7 --&gt; G2\n    end\n\n    subgraph SourceStepping[\"Source Stepping\"]\n        direction TB\n        S1[\"Set all sources to 0%\"]\n        S2[\"Solve at current level\"]\n        S3{Converged?}\n        S4[\"Increase source level\"]\n        S5{Level = 100%?}\n        S6[\"Decrease step size\"]\n        S1 --&gt; S2 --&gt; S3\n        S3 --&gt;|Yes| S5\n        S5 --&gt;|No| S4 --&gt; S2\n        S3 --&gt;|No| S6 --&gt; S2\n    end\n\n    G5 --&gt;|Yes| SUCCESS[\"Success\"]\n    S5 --&gt;|Yes| SUCCESS</code></pre>"},{"location":"operating_point/#31-homotopy-selection","title":"3.1 Homotopy Selection","text":"<p>Location: <code>coreop.cpp:444-499</code></p> <p>The <code>op_homotopy</code> option specifies which methods to try and in what order:</p> Method Description <code>gdev</code> Add conductance across device terminals, step down <code>gshunt</code> Add conductance to ground at each node, step down <code>spice3Gmin</code> SPICE3-style gshunt stepping (fixed schedule) <code>src</code> Ramp independent sources from 0% to 100% <code>spice3Src</code> SPICE3-style source stepping <p>Default order: <code>[gdev, gshunt, src]</code></p>"},{"location":"operating_point/#32-gmin-stepping","title":"3.2 Gmin Stepping","text":"<p>Location: <code>hmtpgmin.cpp:11-183</code></p> <p>Concept: Add small conductances to make the circuit easier to solve, then gradually reduce them.</p> <ol> <li>Start with large gmin (e.g., 1e-3 S)</li> <li>Solve the modified circuit</li> <li>If converged: reduce gmin by factor, continue from previous solution</li> <li>If failed:</li> <li>If no good solution yet: increase gmin</li> <li>Otherwise: restore last good solution, reduce step size</li> <li>Repeat until gmin reaches target (typically gmin option or gmin/10)</li> <li>Final solve with original circuit</li> </ol> <p>Adaptive stepping: Factor adjusts based on iteration count: - Few iterations \u2192 increase factor (take bigger steps) - Many iterations \u2192 decrease factor (take smaller steps)</p>"},{"location":"operating_point/#33-source-stepping","title":"3.3 Source Stepping","text":"<p>Location: <code>hmtpsrc.cpp</code></p> <p>Concept: Gradually ramp source values from 0 to 100%.</p> <ol> <li>Set all independent sources to 0%</li> <li>Solve (should be easy - no excitation)</li> <li>Increase source level</li> <li>Solve, using previous solution as initial guess</li> <li>If failed: reduce step size, retry</li> <li>Repeat until sources at 100%</li> </ol>"},{"location":"operating_point/#phase-4-output","title":"Phase 4: Output","text":""},{"location":"operating_point/#41-write-results","title":"4.1 Write Results","text":"<p>Location: <code>coreop.cpp:507-510</code></p> <p>If converged and <code>write=1</code>: - Write node voltages and branch currents to <code>.raw</code> file</p>"},{"location":"operating_point/#42-store-solution","title":"4.2 Store Solution","text":"<p>Location: <code>coreop.cpp:103-108</code></p> <p>If converged and <code>store</code> parameter given: - Save solution to repository for later use (e.g., as nodeset for another analysis)</p>"},{"location":"operating_point/#newton-raphson-equation-details","title":"Newton-Raphson Equation Details","text":""},{"location":"operating_point/#linearized-system","title":"Linearized System","text":"<p>The nonlinear system <code>f(x) = 0</code> is solved iteratively:</p> <pre><code>f(x^j) + J(x^j) \u00b7 (x^(j+1) - x^j) \u2248 0\n</code></pre> <p>Rearranging: <pre><code>J(x^j) \u00b7 \u0394x = -f(x^j)\nx^(j+1) = x^j + \u0394x\n</code></pre></p> <p>Where: - <code>J(x) = \u2202f/\u2202x</code> is the Jacobian matrix - <code>\u0394x = x^(j+1) - x^j</code> is the solution update</p>"},{"location":"operating_point/#with-limiting","title":"With Limiting","text":"<p>When device limiting is applied (large voltage swings clamped):</p> <pre><code>J(x_lim) \u00b7 (x^j - x^(j+1)) = f(x_lim) + J(x_lim) \u00b7 (x^j - x_lim)\n</code></pre> <p>This prevents numerical issues from exponential device equations.</p>"},{"location":"operating_point/#matrix-structure","title":"Matrix Structure","text":"<pre><code>graph LR\n    subgraph Jacobian[\"Jacobian Matrix J\"]\n        D1[\"Diagonal: \u03a3 conductances\"]\n        O1[\"Off-diagonal: -conductance\"]\n    end\n\n    subgraph RHS[\"RHS Vector -f(x)\"]\n        R1[\"KCL residual:&lt;br/&gt;\u03a3 currents into node\"]\n    end\n\n    subgraph Solution[\"Solution \u0394x\"]\n        S1[\"Voltage/current updates\"]\n    end\n\n    Jacobian --&gt; |\"KLU solve\"| Solution\n    RHS --&gt; |\"=\"| Solution</code></pre>"},{"location":"operating_point/#continuation-modes","title":"Continuation Modes","text":""},{"location":"operating_point/#standard-mode-continuepreviousfalse","title":"Standard Mode (continuePrevious=false)","text":"<ul> <li>Start from zero solution</li> <li>Apply user nodesets in first <code>op_nsiter</code> iterations</li> <li>Full NR iteration limit: <code>op_itl</code></li> </ul>"},{"location":"operating_point/#continuation-mode-continueprevioustrue","title":"Continuation Mode (continuePrevious=true)","text":"<ul> <li>Start from stored/previous solution</li> <li>Skip nodesets (already at a good point)</li> <li>Reduced iteration limit: <code>op_itlcont</code></li> </ul> <pre><code>flowchart LR\n    subgraph Standard[\"Standard Mode\"]\n        STD1[\"x = 0\"]\n        STD2[\"Apply nodesets&lt;br/&gt;(iterations 1..op_nsiter)\"]\n        STD3[\"Full iteration limit\"]\n    end\n\n    subgraph Continue[\"Continuation Mode\"]\n        CONT1[\"x = stored solution\"]\n        CONT2[\"No nodesets\"]\n        CONT3[\"Reduced iteration limit\"]\n    end</code></pre>"},{"location":"operating_point/#force-slots","title":"Force Slots","text":"<p>The solver maintains multiple force slots for different purposes:</p> Slot Purpose When Active 0 Sweep continuation / homotopy During parameter sweeps, homotopy 1 User-specified nodesets Iterations 1..op_nsiter when not continuing 2 Initial conditions (transient) When called from tran with <code>icmode=op</code>"},{"location":"operating_point/#simulator-options-affecting-op","title":"Simulator Options Affecting OP","text":"Option Description <code>op_itl</code> NR iteration limit (standard mode) <code>op_itlcont</code> NR iteration limit (continuation mode) <code>op_nsiter</code> Iterations to apply nodesets <code>op_skipinitial</code> Skip initial OP, go straight to homotopy <code>op_homotopy</code> List of homotopy methods to try <code>op_debug</code> Debug output level <code>nr_damping</code> Damping factor for solution updates <code>nr_force</code> Scale factor for nodeset penalty <code>nr_bypass</code> Enable inactive element bypass <code>nr_residualcheck</code> Enable residual convergence check <code>reltol</code> Relative tolerance <code>relref</code> Reference for relative tolerance <code>gmin</code> Minimum conductance (always present) <code>gshunt</code> Shunt conductance to ground"},{"location":"operating_point/#homotopy-options","title":"Homotopy Options","text":"Option Description <code>homotopy_debug</code> Homotopy debug output level <code>homotopy_gminsteps</code> Maximum gmin stepping iterations <code>homotopy_gminfactor</code> Gmin reduction factor per step <code>homotopy_startgmin</code> Initial gmin value <code>homotopy_maxgmin</code> Maximum gmin before giving up <code>homotopy_mingmin</code> Target minimum gmin <code>homotopy_srcsteps</code> Maximum source stepping iterations"},{"location":"operating_point/#bypass-optimization","title":"Bypass Optimization","text":"<p>When <code>nr_bypass=1</code>, instances that haven't changed significantly can skip re-evaluation:</p> <pre><code>flowchart TB\n    CHECK[\"Check if instance inputs changed\"]\n    CHANGED{Changed &gt; threshold?}\n    EVAL[\"Full device evaluation\"]\n    SKIP[\"Reuse previous Jacobian/residual\"]\n\n    CHECK --&gt; CHANGED\n    CHANGED --&gt;|Yes| EVAL\n    CHANGED --&gt;|No| SKIP\n\n    style SKIP fill:#c8e6c9</code></pre> <p>This significantly speeds up convergence when only part of the circuit is active.</p>"},{"location":"operating_point/#error-conditions","title":"Error Conditions","text":"Error Cause <code>InitialOp</code> Initial NR failed, trying homotopy <code>Homotopy</code> All homotopy methods failed <code>NoAlgorithm</code> No algorithm tried (op_skipinitial with empty homotopy list) <code>ConflictNode</code> Conflicting nodeset values for same node <code>ConflictDelta</code> Delta force conflicts with node forces"},{"location":"operating_point/#references","title":"References","text":"<ul> <li><code>lib/coreop.cpp</code> \u2014 Operating point core implementation</li> <li><code>lib/coreopnr.cpp</code> \u2014 OP Newton-Raphson solver</li> <li><code>lib/nrsolver.cpp</code> \u2014 Base NR solver</li> <li><code>lib/hmtpgmin.cpp</code> \u2014 Gmin stepping homotopy</li> <li><code>lib/hmtpsrc.cpp</code> \u2014 Source stepping homotopy</li> <li><code>include/coreop.h</code> \u2014 OperatingPointCore class</li> <li><code>include/coreopnr.h</code> \u2014 OpNRSolver class</li> <li><code>include/homotopy.h</code> \u2014 Homotopy base class</li> </ul>"},{"location":"transient/","title":"VACASK Transient Analysis","text":"<p>This document describes the steps VACASK takes when performing transient (time-domain) analysis.</p>"},{"location":"transient/#overview","title":"Overview","text":"<p>Transient analysis solves the circuit's differential-algebraic equations (DAE) over time:</p> <pre><code>f(x(t)) + d/dt q(x(t)) = 0\n</code></pre> <p>Where: - <code>x(t)</code> \u2014 circuit unknowns (node voltages, branch currents) - <code>f(x)</code> \u2014 resistive residual (conductance contributions) - <code>q(x)</code> \u2014 reactive residual (charge/flux contributions)</p>"},{"location":"transient/#key-classes","title":"Key Classes","text":"Class File Description <code>Tran</code> <code>lib/antran.cpp</code> High-level analysis wrapper <code>TranCore</code> <code>lib/coretran.cpp</code> Core transient algorithm <code>TranNRSolver</code> <code>lib/coretrannr.cpp</code> Newton-Raphson solver for transient <code>IntegratorCoeffs</code> <code>lib/coretrancoef.cpp</code> Integration formula coefficients <code>OperatingPointCore</code> <code>lib/coreop.cpp</code> Operating point for initial conditions"},{"location":"transient/#analysis-parameters","title":"Analysis Parameters","text":"<p>Defined in <code>TranParameters</code> (<code>include/coretran.h:40-56</code>):</p> Parameter Default Description <code>step</code> 0.0 Initial/output timestep <code>stop</code> 0.0 Simulation end time <code>start</code> 0.0 Time at which output recording begins <code>maxstep</code> 0.0 Maximum timestep (0 = unlimited) <code>icmode</code> \"op\" Initial condition mode: <code>op</code> or <code>uic</code> <code>ic</code> \"\" Initial conditions (solution name or list) <code>store</code> \"\" Name to store final solution <code>write</code> 1 Whether to write output file"},{"location":"transient/#high-level-data-flow","title":"High-Level Data Flow","text":"<pre><code>flowchart TB\n    subgraph Phase1[\"Phase 1: Initialization\"]\n        VALIDATE[\"Validate parameters&lt;br/&gt;(step, stop, start)\"]\n        METHOD[\"Set integration method&lt;br/&gt;(AM, BDF, Trap, Euler)\"]\n        ALLOC[\"Allocate history buffers&lt;br/&gt;(solution, states, timesteps)\"]\n        VALIDATE --&gt; METHOD --&gt; ALLOC\n    end\n\n    subgraph Phase2[\"Phase 2: Initial Conditions (t=0)\"]\n        ICMODE{icmode?}\n        OP[\"Run OP analysis&lt;br/&gt;DC-consistent state\"]\n        UIC[\"Set values directly&lt;br/&gt;May be inconsistent\"]\n        EVALQ[\"Evaluate reactive residual&lt;br/&gt;Compute breakpoints\"]\n        INITDT[\"Calculate initial timestep\"]\n        ICMODE --&gt;|op| OP\n        ICMODE --&gt;|uic| UIC\n        OP --&gt; EVALQ\n        UIC --&gt; EVALQ\n        EVALQ --&gt; INITDT\n    end\n\n    subgraph Phase3[\"Phase 3: Time-Stepping Loop\"]\n        COEF[\"Compute integrator coefficients\"]\n        PREDICT[\"Predict solution&lt;br/&gt;(polynomial extrapolation)\"]\n        NR[\"Newton-Raphson solve\"]\n        LTE[\"Estimate LTE&lt;br/&gt;(corrector - predictor)\"]\n        DECISION{Accept?}\n        ADVANCE[\"Advance time &amp; history\"]\n        REJECT[\"Reduce timestep &amp; order\"]\n        COEF --&gt; PREDICT --&gt; NR --&gt; LTE --&gt; DECISION\n        DECISION --&gt;|Yes| ADVANCE\n        DECISION --&gt;|No| REJECT\n        ADVANCE --&gt; CHECK{t \u2265 stop?}\n        REJECT --&gt; COEF\n        CHECK --&gt;|No| COEF\n    end\n\n    subgraph Phase4[\"Phase 4: Finalization\"]\n        OUTPUT[\"Write output epilogue\"]\n        STORE[\"Store final solution\"]\n        CLEANUP[\"Clean up\"]\n        OUTPUT --&gt; STORE --&gt; CLEANUP\n    end\n\n    Phase1 --&gt; Phase2 --&gt; Phase3\n    CHECK --&gt;|Yes| Phase4\n\n    style Phase1 fill:#e3f2fd\n    style Phase2 fill:#e8f5e9\n    style Phase3 fill:#fff3e0\n    style Phase4 fill:#fce4ec</code></pre>"},{"location":"transient/#step-by-step-algorithm","title":"Step-by-Step Algorithm","text":""},{"location":"transient/#phase-1-initialization","title":"Phase 1: Initialization","text":""},{"location":"transient/#11-parameter-validation","title":"1.1 Parameter Validation","text":"<p>Location: <code>coretran.cpp:559-573</code></p> <ul> <li>Verify <code>step &gt; 0</code></li> <li>Verify <code>stop &gt; 0</code></li> <li>Verify <code>start &lt; stop</code></li> </ul>"},{"location":"transient/#12-integration-method-setup","title":"1.2 Integration Method Setup","text":"<p>Location: <code>coretran.cpp:576-595</code></p> <p>VACASK supports multiple integration methods configured via <code>tran_method</code> option:</p> Method ID Description Max Order <code>am</code> Adams-Moulton (general) configurable <code>bdf</code> / <code>gear</code> Backward Differentiation Formula configurable <code>euler</code> Backward Euler 1 <code>trap</code> Trapezoidal 2 <code>bdf2</code> / <code>gear2</code> BDF order 2 2 <p>The integration method determines how the time derivative <code>dq/dt</code> is approximated.</p>"},{"location":"transient/#13-history-buffer-allocation","title":"1.3 History Buffer Allocation","text":"<p>Location: <code>coretran.cpp:604-626</code></p> <p>Three history buffers are allocated:</p> <ol> <li>Solution history \u2014 past circuit solutions for the predictor</li> <li>State history \u2014 past reactive states (charges/fluxes) for the integrator</li> <li>Filtered solution (optional) \u2014 for trapezoidal ringing filter</li> </ol> <p>Also allocated: - Predicted solution vector - Scaled LTE (Local Truncation Error) vector - Past timesteps circular buffer - Breakpoint circular buffer</p>"},{"location":"transient/#phase-2-initial-conditions","title":"Phase 2: Initial Conditions","text":""},{"location":"transient/#21-operating-point-mode-icmodeop","title":"2.1 Operating Point Mode (<code>icmode=\"op\"</code>)","text":"<p>Location: <code>coretran.cpp:636-651</code></p> <ol> <li>Enable IC forces in OP solver (slot 2)</li> <li>Run full operating point analysis at t=0</li> <li>This establishes a DC-consistent initial state</li> </ol>"},{"location":"transient/#22-uic-mode-icmodeuic","title":"2.2 UIC Mode (<code>icmode=\"uic\"</code>)","text":"<p>Location: <code>coretran.cpp:652-673</code></p> <ol> <li>Set initial values directly from user-specified conditions</li> <li>Skip operating point analysis</li> <li>May result in inconsistent initial state (like SPICE3 <code>uic</code>)</li> </ol>"},{"location":"transient/#23-initial-state-evaluation","title":"2.3 Initial State Evaluation","text":"<p>Location: <code>coretran.cpp:688-721</code></p> <p>After initial solution: 1. Compute reactive residuals (<code>q</code> values) 2. Compute initial breakpoints from sources 3. Compute maximum frequency in circuit 4. Store reactive state in history</p>"},{"location":"transient/#24-initial-timestep-calculation","title":"2.4 Initial Timestep Calculation","text":"<p>Location: <code>coretran.cpp:771-800</code></p> <p>The initial timestep <code>h0</code> is the minimum of: - User-specified <code>step</code> parameter - User-specified <code>maxstep</code> parameter - Frequency-based limit: <code>tran_ffmax / (2 \u00d7 maxFreq)</code> - Breakpoint fraction: <code>tran_fbr \u00d7 (next_breakpoint - t0)</code> - Instance-requested <code>boundStep</code> - Scaled by <code>tran_fs</code> factor</p>"},{"location":"transient/#phase-3-time-stepping-loop","title":"Phase 3: Time-Stepping Loop","text":"<p>The main loop (<code>coretran.cpp:848-1459</code>) advances time from t=0 to t=stop.</p>"},{"location":"transient/#31-coefficient-computation","title":"3.1 Coefficient Computation","text":"<p>Location: <code>coretran.cpp:867-879</code></p> <p>For each timestep:</p> <ol> <li>Predictor coefficients \u2014 compute polynomial extrapolation coefficients</li> <li>Integrator coefficients \u2014 compute and scale differentiation coefficients</li> </ol> <p>The integrator formula (from <code>coretran.cpp:18-40</code>):</p> <pre><code>qdot(t_{k+1}) =\n    1/(h_k \u00d7 b_{-1}) \u00d7 q(t_{k+1})                    // future reactive\n  - \u03a3 a_i/(h_k \u00d7 b_{-1}) \u00d7 q_{k-i}                   // past reactive values\n  - \u03a3 b_i/b_{-1} \u00d7 qdot_{k-i}                        // past derivatives\n</code></pre> <p>Where coefficients <code>a_i</code>, <code>b_i</code>, <code>b_{-1}</code> are computed based on: - Integration method (AM, BDF, etc.) - Current order - Past timestep values (for variable-step methods)</p>"},{"location":"transient/#32-prediction","title":"3.2 Prediction","text":"<p>Location: <code>coretran.cpp:882-905</code></p> <p>If sufficient history exists: - Use polynomial extrapolation to predict solution at t_{k+1} - This provides a better starting point for Newton-Raphson</p> <p>Otherwise: - Use previous solution as initial guess</p>"},{"location":"transient/#33-newton-raphson-iteration","title":"3.3 Newton-Raphson Iteration","text":"<p>Location: <code>coretran.cpp:920-935</code></p> <pre><code>flowchart TB\n    INIT[\"Initialize with predicted solution\"]\n    EVAL[\"Evaluate devices:&lt;br/&gt;f(x), q(x), Jacobians\"]\n    FORM[\"Form linear system:&lt;br/&gt;[J_res + \u03b1\u00d7J_react]\u0394x = -RHS\"]\n    SOLVE[\"Solve with KLU sparse solver\"]\n    UPDATE[\"Update: x^(j+1) = x^j + \u0394x\"]\n    CHECK{Converged?}\n    ITLIM{Iteration limit?}\n\n    INIT --&gt; EVAL --&gt; FORM --&gt; SOLVE --&gt; UPDATE --&gt; CHECK\n    CHECK --&gt;|No| ITLIM\n    ITLIM --&gt;|No| EVAL\n    CHECK --&gt;|Yes| SUCCESS[\"Success\"]\n    ITLIM --&gt;|Yes| FAIL[\"Failure\"]\n\n    style SUCCESS fill:#c8e6c9\n    style FAIL fill:#ffcdd2</code></pre> <p>The <code>TranNRSolver</code> solves the nonlinear system at each timepoint:</p> <ol> <li>Initialize with predicted (or previous) solution</li> <li>Evaluate devices to get residuals and Jacobian</li> <li>Form linear system:</li> <li>Resistive Jacobian: \u2202f/\u2202x</li> <li>Reactive Jacobian scaled by integrator: (1/h_k\u00d7b_{-1}) \u00d7 \u2202q/\u2202x</li> <li>Combined into transient Jacobian</li> <li>Solve linear system using KLU sparse solver</li> <li>Update solution: x^{j+1} = x^j + \u0394x</li> <li>Check convergence on both resistive and reactive residuals</li> <li>Repeat until converged or iteration limit</li> </ol> <p>The Jacobian contribution from reactive terms: <pre><code>di/dx|_{t_{k+1}} = 1/(h_k \u00d7 b_{-1}) \u00d7 dq/dx|_{t_{k+1}}\n</code></pre></p>"},{"location":"transient/#34-trapezoidal-ringing-filter-optional","title":"3.4 Trapezoidal Ringing Filter (Optional)","text":"<p>Location: <code>coretran.cpp:937-996</code></p> <p>When using trapezoidal integration (<code>tran_trapltefilter</code> enabled): - Detect and filter oscillations caused by trapezoidal method - Uses envelope-based correction on past 3+ points</p>"},{"location":"transient/#35-local-truncation-error-lte-estimation","title":"3.5 Local Truncation Error (LTE) Estimation","text":"<p>Location: <code>coretran.cpp:1061-1222</code></p> <pre><code>flowchart TB\n    COMPUTE[\"Compute LTE = factor \u00d7 (corrector - predictor)\"]\n    TOLREF[\"Compute tolerance reference&lt;br/&gt;(global/local/pointlocal)\"]\n    RATIO[\"Compute ratio = |LTE| / (tol \u00d7 lteratio)\"]\n    NEWDT[\"Calculate h_new = h_k \u00d7 ratio^(-1/(order+1))\"]\n    DECIDE{h_k/h_new &gt; redofactor?}\n    REJECT[\"Reject timepoint&lt;br/&gt;Use smaller step\"]\n    ACCEPT[\"Accept timepoint&lt;br/&gt;Possibly increase order\"]\n\n    COMPUTE --&gt; TOLREF --&gt; RATIO --&gt; NEWDT --&gt; DECIDE\n    DECIDE --&gt;|Yes| REJECT\n    DECIDE --&gt;|No| ACCEPT\n\n    style REJECT fill:#ffcdd2\n    style ACCEPT fill:#c8e6c9</code></pre> <p>LTE control determines whether to accept/reject the timepoint and calculates the next timestep:</p> <ol> <li>Compute LTE = factor \u00d7 (corrector - predictor)</li> <li> <p>Factor accounts for error coefficients of both methods</p> </li> <li> <p>Compute tolerance reference based on <code>relreflte</code> option:</p> </li> <li><code>global</code> \u2014 max over all unknowns and time</li> <li><code>pointglobal</code> \u2014 max over all unknowns at this point</li> <li><code>local</code> \u2014 max over time for each unknown</li> <li> <p><code>pointlocal</code> \u2014 current value for each unknown</p> </li> <li> <p>Compute ratio = |LTE| / (tolerance \u00d7 <code>tran_lteratio</code>)</p> </li> <li> <p>Determine new timestep:    <pre><code>h_{new} = h_k \u00d7 ratio^{-1/(order+1)}\n</code></pre></p> </li> <li> <p>Accept/Reject decision:</p> </li> <li>If <code>h_k / h_{new} &gt; tran_redofactor</code> \u2192 reject timepoint</li> <li>Otherwise \u2192 accept and possibly increase order</li> </ol>"},{"location":"transient/#36-timestep-adjustment-and-breakpoint-handling","title":"3.6 Timestep Adjustment and Breakpoint Handling","text":"<p>Location: <code>coretran.cpp:1229-1343</code></p> <pre><code>flowchart TB\n    START[\"After accept/reject decision\"]\n    UPDATEBP[\"Update breakpoints if at/past one\"]\n    LIMIT[\"Limit timestep by:&lt;br/&gt;\u2022 hmax&lt;br/&gt;\u2022 boundStep&lt;br/&gt;\u2022 tran_fbr \u00d7 breakpoint_distance\"]\n    CROSS{Next step crosses breakpoint?}\n    CUT[\"Cut step to exactly hit breakpoint\"]\n    CLOSE{Very close to breakpoint?}\n    SHORTEN[\"Shorten step by half\"]\n    DONE[\"Set new timestep\"]\n\n    START --&gt; UPDATEBP --&gt; LIMIT --&gt; CROSS\n    CROSS --&gt;|Yes| CUT --&gt; DONE\n    CROSS --&gt;|No| CLOSE\n    CLOSE --&gt;|Yes| SHORTEN --&gt; DONE\n    CLOSE --&gt;|No| DONE</code></pre> <p>After accept/reject decision:</p> <ol> <li>Update breakpoints if at or past a breakpoint</li> <li>Limit timestep by:</li> <li>Maximum timestep (<code>hmax</code>)</li> <li>Instance-requested bound (<code>boundStep</code>)</li> <li>Breakpoint fraction (<code>tran_fbr \u00d7 breakpoint_distance</code>)</li> <li>Handle breakpoint crossing:</li> <li>If next step would cross breakpoint \u2192 cut to exactly hit breakpoint</li> <li>If very close to breakpoint \u2192 shorten step to avoid tiny final step</li> </ol>"},{"location":"transient/#37-accept-timepoint","title":"3.7 Accept Timepoint","text":"<p>Location: <code>coretran.cpp:1359-1429</code></p> <p>When accepting a timepoint:</p> <ol> <li>Increment point counter</li> <li>Handle discontinuity (reset order to 1 if at breakpoint)</li> <li>Write output if <code>t \u2265 start</code></li> <li>Update progress indicator</li> <li>Check for stop/finish requests from Verilog-A <code>$stop</code>/<code>$finish</code></li> <li>Store timestep in history</li> <li>Advance solution/state history buffers</li> </ol>"},{"location":"transient/#38-reject-timepoint","title":"3.8 Reject Timepoint","text":"<p>Location: <code>coretran.cpp:1430-1440</code></p> <p>When rejecting a timepoint:</p> <ol> <li>Keep solution at previous accepted point</li> <li>Reduce timestep (already calculated in step 3.5)</li> <li>Reduce order to 1</li> <li>Retry with smaller step</li> </ol>"},{"location":"transient/#phase-4-termination","title":"Phase 4: Termination","text":""},{"location":"transient/#41-normal-completion","title":"4.1 Normal Completion","text":"<p>Location: <code>coretran.cpp:1396-1400</code></p> <p>Analysis completes when: - <code>tSolve \u2265 stop</code> (within relative tolerance) - <code>$finish</code> called from Verilog-A device</p>"},{"location":"transient/#42-error-conditions","title":"4.2 Error Conditions","text":"<ul> <li>Timestep too small (<code>coretran.cpp:1448-1451</code>)</li> <li>Solver failed to converge</li> <li>Abort requested from device</li> <li>Breakpoint handling panic</li> </ul>"},{"location":"transient/#43-output-finalization","title":"4.3 Output Finalization","text":"<p>Location: <code>coretran.cpp:481-496</code></p> <ol> <li>Write epilogue to raw file</li> <li>Optionally store final solution to repository</li> </ol>"},{"location":"transient/#integration-formulas","title":"Integration Formulas","text":""},{"location":"transient/#adams-moulton-am","title":"Adams-Moulton (AM)","text":"<p>Implicit multistep method using past derivative values.</p> Order Name Formula 1 Backward Euler q\u0307{k+1} = (q - q_k) / h 2 Trapezoidal q\u0307{k+1} = 2(q - q_k)/h - q\u0307_k <p>Trapezoidal with xmu parameter (<code>coretran.cpp:164-173</code>): <pre><code>b_0 = xmu       (past derivative weight)\nb_{-1} = 1-xmu  (future derivative weight)\n</code></pre> Where xmu=0.5 gives pure trapezoidal, xmu=0 gives backward Euler.</p>"},{"location":"transient/#backward-differentiation-formula-bdfgear","title":"Backward Differentiation Formula (BDF/Gear)","text":"<p>Implicit multistep using only past values (no past derivatives).</p> <p>More stable for stiff systems but lower accuracy per order.</p>"},{"location":"transient/#polynomial-extrapolation-predictor","title":"Polynomial Extrapolation (Predictor)","text":"<p>Used only for prediction, not as corrector: <pre><code>x_{k+1,predicted} = \u03a3 a_i \u00d7 x_{k-i}\n</code></pre></p>"},{"location":"transient/#newton-raphson-iteration-detail","title":"Newton-Raphson Iteration Detail","text":"<p>At each NR iteration, the linearized system is:</p> <pre><code>[J_resistive + \u03b1 \u00d7 J_reactive] \u00d7 \u0394x = -RHS\n</code></pre> <p>Where: - <code>J_resistive = \u2202f/\u2202x</code> \u2014 resistive Jacobian from devices - <code>J_reactive = \u2202q/\u2202x</code> \u2014 reactive Jacobian from devices - <code>\u03b1 = 1/(h_k \u00d7 b_{-1})</code> \u2014 integrator leading coefficient - <code>RHS = f(x^j) + q\u0307(x^j)</code> \u2014 combined residual</p> <p>The reactive derivative <code>q\u0307(x^j)</code> is computed using the integration formula with past history.</p>"},{"location":"transient/#history-buffer-management","title":"History Buffer Management","text":"<pre><code>flowchart LR\n    subgraph Slots[\"Solution/State Slots\"]\n        FUTURE[\"Slot -1&lt;br/&gt;Future (NR working)\"]\n        CURRENT[\"Slot 0&lt;br/&gt;Current iteration\"]\n        T_K[\"Slot 1&lt;br/&gt;t_k (last accepted)\"]\n        T_K1[\"Slot 2&lt;br/&gt;t_{k-1}\"]\n        T_K2[\"Slot 3&lt;br/&gt;t_{k-2}\"]\n        MORE[\"...\"]\n    end\n\n    FUTURE --&gt; CURRENT --&gt; T_K --&gt; T_K1 --&gt; T_K2 --&gt; MORE\n\n    style FUTURE fill:#fff3e0\n    style CURRENT fill:#e8f5e9\n    style T_K fill:#e3f2fd\n    style T_K1 fill:#e3f2fd\n    style T_K2 fill:#e3f2fd</code></pre> <ul> <li>Slot -1: Future solution being computed by NR</li> <li>Slot 0: Previous NR iteration result</li> <li>Slots 1, 2, 3, ...: Past accepted timepoints (t_k, t_{k-1}, ...)</li> </ul> <p>When a timepoint is accepted, buffers are advanced so current becomes past.</p>"},{"location":"transient/#simulator-options-affecting-transient","title":"Simulator Options Affecting Transient","text":"Option Description <code>tran_method</code> Integration method <code>tran_maxord</code> Maximum integration order <code>tran_xmu</code> Trapezoidal damping (0-0.5) <code>tran_itl</code> NR iteration limit <code>tran_lteratio</code> LTE tolerance multiplier <code>tran_redofactor</code> Threshold for rejecting timepoint <code>tran_fbr</code> Breakpoint fraction for timestep limit <code>tran_ffmax</code> Frequency-based timestep factor <code>tran_fs</code> Initial timestep scale factor <code>tran_ft</code> Timestep reduction on failure <code>tran_rmax</code> Max timestep as multiple of step <code>tran_minpts</code> Minimum points in simulation <code>tran_predictor</code> Enable/disable predictor <code>tran_trapltefilter</code> Enable trapezoidal ringing filter <code>tran_spicelte</code> Use SPICE-style LTE calculation <code>tran_debug</code> Debug output level"},{"location":"transient/#references","title":"References","text":"<ul> <li><code>lib/coretran.cpp</code> \u2014 Main transient algorithm implementation</li> <li><code>lib/coretrannr.cpp</code> \u2014 Transient Newton-Raphson solver</li> <li><code>lib/coretrancoef.cpp</code> \u2014 Integration coefficient computation</li> <li><code>include/coretran.h</code> \u2014 TranCore class and TranParameters</li> <li><code>include/coretrancoef.h</code> \u2014 IntegratorCoeffs class</li> </ul>"}]}